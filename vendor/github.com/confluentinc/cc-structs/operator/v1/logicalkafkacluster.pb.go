// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: operator/v1/logicalkafkacluster.proto

package v1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LogicalKafkaClusterList struct {
	*v1.TypeMeta         `protobuf:"bytes,1,opt,name=type_meta,json=typeMeta,proto3,embedded=type_meta" json:",inline" db:"type_meta,omitempty" url:"type_meta,omitempty"`
	*v1.ListMeta         `protobuf:"bytes,2,opt,name=list_meta,json=listMeta,proto3,embedded=list_meta" json:"metadata,omitempty" db:"list_meta,omitempty" url:"list_meta,omitempty"`
	Items                []*LogicalKafkaCluster `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty" db:"items,omitempty" url:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *LogicalKafkaClusterList) Reset()         { *m = LogicalKafkaClusterList{} }
func (m *LogicalKafkaClusterList) String() string { return proto.CompactTextString(m) }
func (*LogicalKafkaClusterList) ProtoMessage()    {}
func (*LogicalKafkaClusterList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c34326b9a9f2734, []int{0}
}
func (m *LogicalKafkaClusterList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalKafkaClusterList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalKafkaClusterList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicalKafkaClusterList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalKafkaClusterList.Merge(m, src)
}
func (m *LogicalKafkaClusterList) XXX_Size() int {
	return m.Size()
}
func (m *LogicalKafkaClusterList) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalKafkaClusterList.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalKafkaClusterList proto.InternalMessageInfo

func (m *LogicalKafkaClusterList) GetItems() []*LogicalKafkaCluster {
	if m != nil {
		return m.Items
	}
	return nil
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LogicalKafkaCluster struct {
	*v1.TypeMeta              `protobuf:"bytes,1,opt,name=type_meta,json=typeMeta,proto3,embedded=type_meta" json:",inline" db:"type_meta,omitempty" url:"type_meta,omitempty"`
	*v1.ObjectMeta            `protobuf:"bytes,2,opt,name=object_meta,json=objectMeta,proto3,embedded=object_meta" json:"metadata,omitempty" db:"object_meta,omitempty" url:"object_meta,omitempty"`
	LogicalClusterId          string   `protobuf:"bytes,3,opt,name=logical_cluster_id,json=logicalClusterId,proto3" json:"logical_cluster_id,omitempty" db:"logical_cluster_id,omitempty" url:"logical_cluster_id,omitempty"`
	PhysicalClusterId         string   `protobuf:"bytes,4,opt,name=physical_cluster_id,json=physicalClusterId,proto3" json:"physical_cluster_id,omitempty" db:"physical_cluster_id,omitempty" url:"physical_cluster_id,omitempty"`
	LogicalClusterName        string   `protobuf:"bytes,5,opt,name=logical_cluster_name,json=logicalClusterName,proto3" json:"logical_cluster_name,omitempty" db:"logical_cluster_name,omitempty" url:"logical_cluster_name,omitempty"`
	AccountId                 string   `protobuf:"bytes,6,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty" db:"account_id,omitempty" url:"account_id,omitempty"`
	K8SClusterId              string   `protobuf:"bytes,7,opt,name=k8s_cluster_id,json=k8sClusterId,proto3" json:"k8s_cluster_id,omitempty" db:"k8s_cluster_id,omitempty" url:"k8s_cluster_id,omitempty"`
	LogicalClusterType        string   `protobuf:"bytes,8,opt,name=logical_cluster_type,json=logicalClusterType,proto3" json:"logical_cluster_type,omitempty" db:"logical_cluster_type,omitempty" url:"logical_cluster_type,omitempty"`
	StorageBytes              uint64   `protobuf:"varint,9,opt,name=storage_bytes,json=storageBytes,proto3" json:"storage_bytes,omitempty" db:"storage_bytes,omitempty" url:"storage_bytes,omitempty"`
	NetworkIngressByteRate    uint64   `protobuf:"varint,10,opt,name=network_ingress_byte_rate,json=networkIngressByteRate,proto3" json:"network_ingress_byte_rate,omitempty" db:"network_ingress_byte_rate,omitempty" url:"network_ingress_byte_rate,omitempty"`
	NetworkEgressByteRate     uint64   `protobuf:"varint,11,opt,name=network_egress_byte_rate,json=networkEgressByteRate,proto3" json:"network_egress_byte_rate,omitempty" db:"network_egress_byte_rate,omitempty" url:"network_egress_byte_rate,omitempty"`
	BrokerRequestPercentage   uint64   `protobuf:"varint,12,opt,name=broker_request_percentage,json=brokerRequestPercentage,proto3" json:"broker_request_percentage,omitempty" db:"broker_request_percentage,omitempty" url:"broker_request_percentage,omitempty"`
	MaxNetworkIngressByteRate uint64   `protobuf:"varint,13,opt,name=max_network_ingress_byte_rate,json=maxNetworkIngressByteRate,proto3" json:"max_network_ingress_byte_rate,omitempty" db:"max_network_ingress_byte_rate,omitempty" url:"max_network_ingress_byte_rate,omitempty"`
	MaxNetworkEgressByteRate  uint64   `protobuf:"varint,14,opt,name=max_network_egress_byte_rate,json=maxNetworkEgressByteRate,proto3" json:"max_network_egress_byte_rate,omitempty" db:"max_network_egress_byte_rate,omitempty" url:"max_network_egress_byte_rate,omitempty"`
	MaxPartitions             int32    `protobuf:"varint,15,opt,name=max_partitions,json=maxPartitions,proto3" json:"max_partitions,omitempty" db:"max_partitions,omitempty" url:"max_partitions,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *LogicalKafkaCluster) Reset()         { *m = LogicalKafkaCluster{} }
func (m *LogicalKafkaCluster) String() string { return proto.CompactTextString(m) }
func (*LogicalKafkaCluster) ProtoMessage()    {}
func (*LogicalKafkaCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c34326b9a9f2734, []int{1}
}
func (m *LogicalKafkaCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalKafkaCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalKafkaCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicalKafkaCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalKafkaCluster.Merge(m, src)
}
func (m *LogicalKafkaCluster) XXX_Size() int {
	return m.Size()
}
func (m *LogicalKafkaCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalKafkaCluster.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalKafkaCluster proto.InternalMessageInfo

func (m *LogicalKafkaCluster) GetLogicalClusterId() string {
	if m != nil {
		return m.LogicalClusterId
	}
	return ""
}

func (m *LogicalKafkaCluster) GetPhysicalClusterId() string {
	if m != nil {
		return m.PhysicalClusterId
	}
	return ""
}

func (m *LogicalKafkaCluster) GetLogicalClusterName() string {
	if m != nil {
		return m.LogicalClusterName
	}
	return ""
}

func (m *LogicalKafkaCluster) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *LogicalKafkaCluster) GetK8SClusterId() string {
	if m != nil {
		return m.K8SClusterId
	}
	return ""
}

func (m *LogicalKafkaCluster) GetLogicalClusterType() string {
	if m != nil {
		return m.LogicalClusterType
	}
	return ""
}

func (m *LogicalKafkaCluster) GetStorageBytes() uint64 {
	if m != nil {
		return m.StorageBytes
	}
	return 0
}

func (m *LogicalKafkaCluster) GetNetworkIngressByteRate() uint64 {
	if m != nil {
		return m.NetworkIngressByteRate
	}
	return 0
}

func (m *LogicalKafkaCluster) GetNetworkEgressByteRate() uint64 {
	if m != nil {
		return m.NetworkEgressByteRate
	}
	return 0
}

func (m *LogicalKafkaCluster) GetBrokerRequestPercentage() uint64 {
	if m != nil {
		return m.BrokerRequestPercentage
	}
	return 0
}

func (m *LogicalKafkaCluster) GetMaxNetworkIngressByteRate() uint64 {
	if m != nil {
		return m.MaxNetworkIngressByteRate
	}
	return 0
}

func (m *LogicalKafkaCluster) GetMaxNetworkEgressByteRate() uint64 {
	if m != nil {
		return m.MaxNetworkEgressByteRate
	}
	return 0
}

func (m *LogicalKafkaCluster) GetMaxPartitions() int32 {
	if m != nil {
		return m.MaxPartitions
	}
	return 0
}

func init() {
	proto.RegisterType((*LogicalKafkaClusterList)(nil), "operator.v1.LogicalKafkaClusterList")
	proto.RegisterType((*LogicalKafkaCluster)(nil), "operator.v1.LogicalKafkaCluster")
}

func init() {
	proto.RegisterFile("operator/v1/logicalkafkacluster.proto", fileDescriptor_0c34326b9a9f2734)
}

var fileDescriptor_0c34326b9a9f2734 = []byte{
	// 897 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x96, 0x4f, 0x6f, 0xdc, 0x44,
	0x18, 0xc6, 0x35, 0xa4, 0x69, 0xb3, 0xb3, 0x49, 0x0a, 0x6e, 0xa1, 0x4e, 0x05, 0xf1, 0x2a, 0x12,
	0x62, 0x85, 0x8a, 0xcd, 0x86, 0x0a, 0x45, 0x05, 0x21, 0xb4, 0x50, 0xd4, 0x40, 0x28, 0xab, 0x51,
	0x04, 0xa8, 0x42, 0x58, 0xb3, 0xde, 0x59, 0x67, 0xf0, 0x9f, 0x31, 0x9e, 0xf1, 0x92, 0xe5, 0xc0,
	0x89, 0x2b, 0x07, 0x7a, 0x06, 0x89, 0x1b, 0xdf, 0x80, 0xcf, 0xc0, 0xb1, 0xe2, 0x03, 0x58, 0x28,
	0x47, 0x8e, 0xfe, 0x04, 0x68, 0xc6, 0xce, 0xae, 0xd7, 0xf6, 0x6e, 0xb7, 0xb7, 0xde, 0xa2, 0x79,
	0x9e, 0x79, 0x7f, 0xcf, 0xbc, 0xaf, 0x27, 0x3b, 0xf0, 0x75, 0x16, 0x91, 0x18, 0x0b, 0x16, 0x5b,
	0x93, 0x9e, 0xe5, 0x33, 0x97, 0x3a, 0xd8, 0xf7, 0xf0, 0xd8, 0xc3, 0x8e, 0x9f, 0x70, 0x41, 0x62,
	0x33, 0x8a, 0x99, 0x60, 0x5a, 0xfb, 0xd2, 0x66, 0x4e, 0x7a, 0xb7, 0x6f, 0xba, 0xcc, 0x65, 0x6a,
	0xdd, 0x92, 0x7f, 0xe5, 0x96, 0xdb, 0x77, 0xbd, 0x23, 0x6e, 0x52, 0x66, 0xe1, 0x88, 0x06, 0xd8,
	0x39, 0xa3, 0x21, 0x89, 0xa7, 0x56, 0xe4, 0xb9, 0x72, 0x81, 0x5b, 0x01, 0x11, 0x58, 0x22, 0x5c,
	0x12, 0xca, 0x42, 0x64, 0x94, 0xef, 0x3a, 0xf8, 0x6b, 0x03, 0xde, 0x3a, 0xc9, 0xb1, 0x9f, 0x49,
	0xec, 0x47, 0x39, 0xf6, 0x84, 0x72, 0xa1, 0x3d, 0x06, 0xb0, 0x25, 0xa6, 0x11, 0xb1, 0xe5, 0x66,
	0x1d, 0x74, 0x40, 0xb7, 0x7d, 0x68, 0x9a, 0x39, 0xc6, 0x2c, 0x63, 0xcc, 0xc8, 0x73, 0xe5, 0x02,
	0x37, 0xa5, 0xd3, 0x9c, 0xf4, 0xcc, 0xd3, 0x69, 0x44, 0x3e, 0x27, 0x02, 0xf7, 0xef, 0x3f, 0x49,
	0x0d, 0xf0, 0x5f, 0x6a, 0x5c, 0xbb, 0x43, 0x43, 0x9f, 0x86, 0x24, 0x4b, 0x8d, 0xc3, 0xd1, 0xf0,
	0xde, 0xc1, 0xac, 0xee, 0x1d, 0x16, 0x50, 0x41, 0x82, 0x48, 0x4c, 0x0f, 0x3a, 0x49, 0xec, 0x37,
	0x2b, 0x68, 0x4b, 0x14, 0x05, 0xb5, 0xdf, 0x01, 0x6c, 0xf9, 0x94, 0x8b, 0x3c, 0xd4, 0x0b, 0xcf,
	0x12, 0x4a, 0x1e, 0x4a, 0x85, 0x1a, 0x14, 0xa1, 0x34, 0xa9, 0x8c, 0x70, 0x19, 0x75, 0x99, 0x6f,
	0x86, 0xa8, 0xe5, 0x6b, 0x52, 0xd0, 0x96, 0x5f, 0xd4, 0xd6, 0xc6, 0x70, 0x53, 0xae, 0x72, 0x7d,
	0xa3, 0xb3, 0xd1, 0x6d, 0x1f, 0x76, 0xcc, 0xd2, 0xe4, 0xcc, 0x86, 0x4e, 0xf7, 0xcd, 0x2c, 0x35,
	0xde, 0x94, 0x48, 0xb5, 0xad, 0x86, 0xab, 0xae, 0xa2, 0xbc, 0xfc, 0xc1, 0x3f, 0xd7, 0xe1, 0x8d,
	0x86, 0x72, 0xcf, 0xe7, 0xd0, 0xfe, 0x04, 0xb0, 0xcd, 0x86, 0xdf, 0x11, 0x67, 0x61, 0x6c, 0x6f,
	0xaf, 0x17, 0xeb, 0x0b, 0xb5, 0x51, 0x05, 0x3b, 0x5d, 0x39, 0xb8, 0x77, 0x65, 0xc6, 0x12, 0xa6,
	0x96, 0xb2, 0x59, 0x43, 0x90, 0xcd, 0x08, 0xda, 0x04, 0x6a, 0xc5, 0x2d, 0xb4, 0x8b, 0x1b, 0x68,
	0xd3, 0x91, 0xbe, 0xd1, 0x01, 0xdd, 0x56, 0xff, 0x41, 0x96, 0x1a, 0x1f, 0xab, 0x8f, 0xa3, 0xe6,
	0xa8, 0x7f, 0x25, 0xab, 0x2c, 0xe8, 0xc5, 0x42, 0x2e, 0x86, 0x76, 0x3c, 0xd2, 0x7e, 0x84, 0x37,
	0xa2, 0xb3, 0x29, 0xaf, 0x82, 0xaf, 0x28, 0xf0, 0xa7, 0x59, 0x6a, 0x7c, 0x22, 0xc1, 0x0d, 0x96,
	0x1a, 0x79, 0xb5, 0x07, 0xbd, 0x74, 0xa9, 0xcf, 0xd9, 0x3f, 0xc1, 0x9b, 0xd5, 0xb8, 0x21, 0x0e,
	0x88, 0xbe, 0xa9, 0xe0, 0x27, 0x59, 0x6a, 0x3c, 0x68, 0x3a, 0xb5, 0xf4, 0x3c, 0xf5, 0xdc, 0x15,
	0x13, 0xd2, 0x16, 0x4f, 0xfe, 0x10, 0x07, 0x44, 0xfb, 0x0a, 0x42, 0xec, 0x38, 0x2c, 0x09, 0x85,
	0x3c, 0xf2, 0x55, 0x45, 0x3d, 0xca, 0x52, 0xe3, 0xae, 0xa4, 0xce, 0x95, 0x1a, 0xab, 0x51, 0x42,
	0xad, 0x62, 0xf9, 0x78, 0xa4, 0x8d, 0xe1, 0xae, 0x77, 0xc4, 0xcb, 0xfd, 0xbc, 0xa6, 0x8a, 0x7f,
	0x98, 0xa5, 0xc6, 0xfb, 0xb2, 0xf8, 0xa2, 0x5a, 0x03, 0x2c, 0x95, 0xd1, 0xb6, 0x77, 0xc4, 0x57,
	0x36, 0x50, 0x7e, 0xfa, 0xfa, 0xd6, 0xea, 0x06, 0x4a, 0xcf, 0x53, 0x1b, 0x58, 0x31, 0x55, 0x1b,
	0x28, 0xef, 0xac, 0xe6, 0xc0, 0x1d, 0x2e, 0x58, 0x8c, 0x5d, 0x62, 0x0f, 0xa7, 0x82, 0x70, 0xbd,
	0xd5, 0x01, 0xdd, 0x2b, 0xfd, 0x0f, 0xb2, 0xd4, 0xb8, 0x27, 0xc1, 0x0b, 0x62, 0x8d, 0xb8, 0x4c,
	0x45, 0xdb, 0x85, 0xd2, 0x97, 0x82, 0xf6, 0x2b, 0x80, 0x7b, 0x21, 0x11, 0x3f, 0xb0, 0xd8, 0xb3,
	0x69, 0xe8, 0xc6, 0x84, 0x73, 0xb5, 0xc5, 0x96, 0x3f, 0x27, 0x3a, 0x54, 0xc4, 0x2f, 0xb3, 0xd4,
	0x40, 0x92, 0xb8, 0xd4, 0x58, 0xa3, 0xaf, 0xe3, 0x44, 0xaf, 0x14, 0xae, 0xe3, 0xdc, 0x24, 0x03,
	0x21, 0x2c, 0x88, 0xf6, 0x0b, 0x80, 0xfa, 0x65, 0x01, 0x52, 0x8d, 0xd4, 0x56, 0x91, 0x4e, 0xb3,
	0xd4, 0x18, 0x94, 0x23, 0x91, 0x75, 0x13, 0xad, 0x30, 0xa2, 0x97, 0x0b, 0xd3, 0xfd, 0xc5, 0x3c,
	0x8f, 0x01, 0xdc, 0x1b, 0xc6, 0xcc, 0x23, 0xb1, 0x1d, 0x93, 0xef, 0x13, 0xc2, 0x85, 0x1d, 0x91,
	0xd8, 0x21, 0xa1, 0xc0, 0x2e, 0xd1, 0xb7, 0x17, 0x7b, 0xb4, 0xd4, 0x58, 0x4b, 0xb4, 0x8e, 0x13,
	0xdd, 0xca, 0x5d, 0x28, 0x37, 0x0d, 0x66, 0x1e, 0xed, 0x0f, 0x00, 0x5f, 0x0b, 0xf0, 0xb9, 0xbd,
	0x7c, 0x78, 0x3b, 0x2a, 0xd8, 0xb7, 0x59, 0x6a, 0x3c, 0x92, 0xc1, 0x56, 0x9a, 0x6b, 0xe1, 0xd6,
	0x75, 0xa3, 0xbd, 0x00, 0x9f, 0x3f, 0x6c, 0x9e, 0xe3, 0x6f, 0x00, 0xbe, 0x5a, 0xae, 0x53, 0x9b,
	0xe5, 0xae, 0x4a, 0xf8, 0x4d, 0x96, 0x1a, 0x5f, 0x57, 0x13, 0x92, 0x67, 0x09, 0xb8, 0x6a, 0xa6,
	0xfa, 0x3c, 0x5f, 0x65, 0xac, 0x2e, 0xdc, 0x95, 0x45, 0x22, 0x1c, 0x0b, 0x2a, 0x28, 0x0b, 0xb9,
	0x7e, 0xbd, 0x03, 0xba, 0x9b, 0xf3, 0xff, 0x23, 0x8b, 0x6a, 0x63, 0x82, 0x46, 0x19, 0xed, 0x04,
	0xf8, 0x7c, 0x30, 0x53, 0xfa, 0x3f, 0x83, 0xbf, 0x2f, 0xf6, 0xc1, 0x93, 0x8b, 0x7d, 0xf0, 0xef,
	0xc5, 0x3e, 0x80, 0x6f, 0x50, 0x66, 0x3a, 0x2c, 0x1c, 0xfb, 0x09, 0x09, 0x85, 0xe9, 0xf8, 0x2c,
	0x29, 0x9e, 0x6d, 0xc3, 0x64, 0x5c, 0x7e, 0x57, 0xf4, 0xf5, 0x86, 0x97, 0xc0, 0x40, 0x1a, 0x07,
	0xe0, 0x51, 0xcf, 0xa5, 0xe2, 0x2c, 0x19, 0x9a, 0x0e, 0x0b, 0xac, 0x59, 0x31, 0x1a, 0x3a, 0x96,
	0xe3, 0xbc, 0xc5, 0x45, 0x9c, 0x38, 0x82, 0x5b, 0xa5, 0x47, 0xe8, 0x7b, 0x93, 0xde, 0xf0, 0xaa,
	0x82, 0xbc, 0xf3, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x52, 0x97, 0x84, 0x70, 0x9d, 0x0a, 0x00,
	0x00,
}

func (m *LogicalKafkaClusterList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalKafkaClusterList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.TypeMeta.Size()))
		n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ListMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.ListMeta.Size()))
		n2, err := m.ListMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LogicalKafkaCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalKafkaCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.TypeMeta.Size()))
		n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ObjectMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.ObjectMeta.Size()))
		n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.LogicalClusterId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(len(m.LogicalClusterId)))
		i += copy(dAtA[i:], m.LogicalClusterId)
	}
	if len(m.PhysicalClusterId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(len(m.PhysicalClusterId)))
		i += copy(dAtA[i:], m.PhysicalClusterId)
	}
	if len(m.LogicalClusterName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(len(m.LogicalClusterName)))
		i += copy(dAtA[i:], m.LogicalClusterName)
	}
	if len(m.AccountId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	if len(m.K8SClusterId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(len(m.K8SClusterId)))
		i += copy(dAtA[i:], m.K8SClusterId)
	}
	if len(m.LogicalClusterType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(len(m.LogicalClusterType)))
		i += copy(dAtA[i:], m.LogicalClusterType)
	}
	if m.StorageBytes != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.StorageBytes))
	}
	if m.NetworkIngressByteRate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.NetworkIngressByteRate))
	}
	if m.NetworkEgressByteRate != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.NetworkEgressByteRate))
	}
	if m.BrokerRequestPercentage != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.BrokerRequestPercentage))
	}
	if m.MaxNetworkIngressByteRate != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.MaxNetworkIngressByteRate))
	}
	if m.MaxNetworkEgressByteRate != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.MaxNetworkEgressByteRate))
	}
	if m.MaxPartitions != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintLogicalkafkacluster(dAtA, i, uint64(m.MaxPartitions))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintLogicalkafkacluster(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LogicalKafkaClusterList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	if m.ListMeta != nil {
		l = m.ListMeta.Size()
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovLogicalkafkacluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogicalKafkaCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	l = len(m.LogicalClusterId)
	if l > 0 {
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	l = len(m.PhysicalClusterId)
	if l > 0 {
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	l = len(m.LogicalClusterName)
	if l > 0 {
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	l = len(m.K8SClusterId)
	if l > 0 {
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	l = len(m.LogicalClusterType)
	if l > 0 {
		n += 1 + l + sovLogicalkafkacluster(uint64(l))
	}
	if m.StorageBytes != 0 {
		n += 1 + sovLogicalkafkacluster(uint64(m.StorageBytes))
	}
	if m.NetworkIngressByteRate != 0 {
		n += 1 + sovLogicalkafkacluster(uint64(m.NetworkIngressByteRate))
	}
	if m.NetworkEgressByteRate != 0 {
		n += 1 + sovLogicalkafkacluster(uint64(m.NetworkEgressByteRate))
	}
	if m.BrokerRequestPercentage != 0 {
		n += 1 + sovLogicalkafkacluster(uint64(m.BrokerRequestPercentage))
	}
	if m.MaxNetworkIngressByteRate != 0 {
		n += 1 + sovLogicalkafkacluster(uint64(m.MaxNetworkIngressByteRate))
	}
	if m.MaxNetworkEgressByteRate != 0 {
		n += 1 + sovLogicalkafkacluster(uint64(m.MaxNetworkEgressByteRate))
	}
	if m.MaxPartitions != 0 {
		n += 1 + sovLogicalkafkacluster(uint64(m.MaxPartitions))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLogicalkafkacluster(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLogicalkafkacluster(x uint64) (n int) {
	return sovLogicalkafkacluster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LogicalKafkaClusterList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalkafkacluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalKafkaClusterList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalKafkaClusterList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &v1.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ListMeta == nil {
				m.ListMeta = &v1.ListMeta{}
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &LogicalKafkaCluster{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalkafkacluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalKafkaCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogicalkafkacluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalKafkaCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalKafkaCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &v1.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &v1.ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogicalClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogicalClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalClusterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogicalClusterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBytes", wireType)
			}
			m.StorageBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkIngressByteRate", wireType)
			}
			m.NetworkIngressByteRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkIngressByteRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkEgressByteRate", wireType)
			}
			m.NetworkEgressByteRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkEgressByteRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerRequestPercentage", wireType)
			}
			m.BrokerRequestPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrokerRequestPercentage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNetworkIngressByteRate", wireType)
			}
			m.MaxNetworkIngressByteRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNetworkIngressByteRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNetworkEgressByteRate", wireType)
			}
			m.MaxNetworkEgressByteRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNetworkEgressByteRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPartitions", wireType)
			}
			m.MaxPartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPartitions |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogicalkafkacluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLogicalkafkacluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLogicalkafkacluster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLogicalkafkacluster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogicalkafkacluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLogicalkafkacluster
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLogicalkafkacluster
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLogicalkafkacluster
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLogicalkafkacluster(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLogicalkafkacluster
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLogicalkafkacluster = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLogicalkafkacluster   = fmt.Errorf("proto: integer overflow")
)
