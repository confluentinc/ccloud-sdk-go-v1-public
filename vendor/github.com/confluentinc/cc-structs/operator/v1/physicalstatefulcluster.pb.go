// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: operator/v1/physicalstatefulcluster.proto

package v1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	v11 "k8s.io/api/core/v1"
	v12 "k8s.io/api/networking/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type UpdateStrategyType int32

const (
	UpdateStrategyType_ROLLING_UPDATE UpdateStrategyType = 0
	UpdateStrategyType_ON_DELETE      UpdateStrategyType = 1
)

var UpdateStrategyType_name = map[int32]string{
	0: "ROLLING_UPDATE",
	1: "ON_DELETE",
}

var UpdateStrategyType_value = map[string]int32{
	"ROLLING_UPDATE": 0,
	"ON_DELETE":      1,
}

func (x UpdateStrategyType) String() string {
	return proto.EnumName(UpdateStrategyType_name, int32(x))
}

func (UpdateStrategyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{0}
}

type PodManagementPolicy int32

const (
	PodManagementPolicy_PARALLEL      PodManagementPolicy = 0
	PodManagementPolicy_ORDERED_READY PodManagementPolicy = 1
)

var PodManagementPolicy_name = map[int32]string{
	0: "PARALLEL",
	1: "ORDERED_READY",
}

var PodManagementPolicy_value = map[string]int32{
	"PARALLEL":      0,
	"ORDERED_READY": 1,
}

func (x PodManagementPolicy) String() string {
	return proto.EnumName(PodManagementPolicy_name, int32(x))
}

func (PodManagementPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{1}
}

type AffinityRule int32

const (
	AffinityRule_PREFERRED AffinityRule = 0
	AffinityRule_REQUIRED  AffinityRule = 1
)

var AffinityRule_name = map[int32]string{
	0: "PREFERRED",
	1: "REQUIRED",
}

var AffinityRule_value = map[string]int32{
	"PREFERRED": 0,
	"REQUIRED":  1,
}

func (x AffinityRule) String() string {
	return proto.EnumName(AffinityRule_name, int32(x))
}

func (AffinityRule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{2}
}

// Confluent Storage Type mapping to each Cloud Provider
// STANDARD_MAGNETIC: AWS -> st1, GCP -> Standard persistent disks, Azure -> Standard HDD
// STANDARD_SSD: AWS -> gp2, GCP -> Balanced persistent disks, Azure -> Standard SSD
// SLOW_MAGNETIC: AWS -> sc1, GCP -> Standard persistent disks, Azure -> Standard HDD
// DEFAULT: *This is not a real storage class. It is being used as an empty placeholder for CLI inputs.*
// NEXT_GEN_SSD: AWS -> gp3, GCP -> Performance persistent disks, Azure -> Premium SSD
// HIGH_IOPS_SSD: AWS -> io2, GCP -> Extreme persistent disks, Azure -> Ultra disk
type StorageType int32

const (
	StorageType_STANDARD_MAGNETIC StorageType = 0
	StorageType_STANDARD_SSD      StorageType = 1
	StorageType_SLOW_MAGNETIC     StorageType = 2
	StorageType_DEFAULT           StorageType = 3
	StorageType_NEXT_GEN_SSD      StorageType = 4
	StorageType_HIGH_IOPS_SSD     StorageType = 5
)

var StorageType_name = map[int32]string{
	0: "STANDARD_MAGNETIC",
	1: "STANDARD_SSD",
	2: "SLOW_MAGNETIC",
	3: "DEFAULT",
	4: "NEXT_GEN_SSD",
	5: "HIGH_IOPS_SSD",
}

var StorageType_value = map[string]int32{
	"STANDARD_MAGNETIC": 0,
	"STANDARD_SSD":      1,
	"SLOW_MAGNETIC":     2,
	"DEFAULT":           3,
	"NEXT_GEN_SSD":      4,
	"HIGH_IOPS_SSD":     5,
}

func (x StorageType) String() string {
	return proto.EnumName(StorageType_name, int32(x))
}

func (StorageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{3}
}

type ProxyAccess int32

const (
	ProxyAccess_PRIVATE ProxyAccess = 0
	ProxyAccess_PUBLIC  ProxyAccess = 1
)

var ProxyAccess_name = map[int32]string{
	0: "PRIVATE",
	1: "PUBLIC",
}

var ProxyAccess_value = map[string]int32{
	"PRIVATE": 0,
	"PUBLIC":  1,
}

func (x ProxyAccess) String() string {
	return proto.EnumName(ProxyAccess_name, int32(x))
}

func (ProxyAccess) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{4}
}

type HTTPHandler_URIScheme int32

const (
	HTTPHandler_HTTP  HTTPHandler_URIScheme = 0
	HTTPHandler_HTTPS HTTPHandler_URIScheme = 1
)

var HTTPHandler_URIScheme_name = map[int32]string{
	0: "HTTP",
	1: "HTTPS",
}

var HTTPHandler_URIScheme_value = map[string]int32{
	"HTTP":  0,
	"HTTPS": 1,
}

func (x HTTPHandler_URIScheme) String() string {
	return proto.EnumName(HTTPHandler_URIScheme_name, int32(x))
}

func (HTTPHandler_URIScheme) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{32, 0}
}

type PhysicalStatefulClusterStatus_ClusterSummary int32

const (
	// if phase == Phase_PENDING
	PhysicalStatefulClusterStatus_PROVISIONING PhysicalStatefulClusterStatus_ClusterSummary = 0
	// if phase == Phase_DELETING
	PhysicalStatefulClusterStatus_DELETING PhysicalStatefulClusterStatus_ClusterSummary = 1
	// if phase == Phase_DELETED
	PhysicalStatefulClusterStatus_DELETED PhysicalStatefulClusterStatus_ClusterSummary = 2
	// if phase == Phase_RUNNING && PSCResourcesReady ConditionUnknown . For Phase 2, delegate to component check and its result takes precedence.
	PhysicalStatefulClusterStatus_UNKNOWN PhysicalStatefulClusterStatus_ClusterSummary = 3
	// if phase == Phase_RUNNING && PSCResourcesReady ConditionTrue.  For Phase 2, delegate to component check and its result takes precedence.
	PhysicalStatefulClusterStatus_UP PhysicalStatefulClusterStatus_ClusterSummary = 4
	// if phase == Phase_ERROR || phase == Phase_RUNNING && PSCResourcesReady ConditionFalse. For Phase 2, delegate to component check and its result takes precedence.
	PhysicalStatefulClusterStatus_DOWN PhysicalStatefulClusterStatus_ClusterSummary = 5
	// For Phase 2 only, delegate to component check and its result takes precedence.
	PhysicalStatefulClusterStatus_DEGRADED PhysicalStatefulClusterStatus_ClusterSummary = 6
	// Set when psc controller reconcile is blocked due to potential roll.
	// Removed once reconcile is unblocked by either a psc spec change, reverting an out of band pod template spec change, or deleting the pod template spec diff annotation
	PhysicalStatefulClusterStatus_BLOCKED PhysicalStatefulClusterStatus_ClusterSummary = 7
)

var PhysicalStatefulClusterStatus_ClusterSummary_name = map[int32]string{
	0: "PROVISIONING",
	1: "DELETING",
	2: "DELETED",
	3: "UNKNOWN",
	4: "UP",
	5: "DOWN",
	6: "DEGRADED",
	7: "BLOCKED",
}

var PhysicalStatefulClusterStatus_ClusterSummary_value = map[string]int32{
	"PROVISIONING": 0,
	"DELETING":     1,
	"DELETED":      2,
	"UNKNOWN":      3,
	"UP":           4,
	"DOWN":         5,
	"DEGRADED":     6,
	"BLOCKED":      7,
}

func (x PhysicalStatefulClusterStatus_ClusterSummary) String() string {
	return proto.EnumName(PhysicalStatefulClusterStatus_ClusterSummary_name, int32(x))
}

func (PhysicalStatefulClusterStatus_ClusterSummary) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{67, 0}
}

type PostRollConfig_Validation int32

const (
	PostRollConfig_BROKER_STATE          PostRollConfig_Validation = 0
	PostRollConfig_NETWORK_HEALTH_STATUS PostRollConfig_Validation = 1
)

var PostRollConfig_Validation_name = map[int32]string{
	0: "BROKER_STATE",
	1: "NETWORK_HEALTH_STATUS",
}

var PostRollConfig_Validation_value = map[string]int32{
	"BROKER_STATE":          0,
	"NETWORK_HEALTH_STATUS": 1,
}

func (x PostRollConfig_Validation) String() string {
	return proto.EnumName(PostRollConfig_Validation_name, int32(x))
}

func (PostRollConfig_Validation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{72, 0}
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type PhysicalStatefulClusterList struct {
	*v1.TypeMeta         `protobuf:"bytes,1,opt,name=type_meta,json=typeMeta,proto3,embedded=type_meta" json:",inline" db:"type_meta,omitempty" url:"type_meta,omitempty"`
	*v1.ListMeta         `protobuf:"bytes,2,opt,name=list_meta,json=listMeta,proto3,embedded=list_meta" json:"metadata,omitempty" db:"list_meta,omitempty" url:"list_meta,omitempty"`
	Items                []*PhysicalStatefulCluster `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty" db:"items,omitempty" url:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *PhysicalStatefulClusterList) Reset()         { *m = PhysicalStatefulClusterList{} }
func (m *PhysicalStatefulClusterList) String() string { return proto.CompactTextString(m) }
func (*PhysicalStatefulClusterList) ProtoMessage()    {}
func (*PhysicalStatefulClusterList) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{0}
}
func (m *PhysicalStatefulClusterList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterList.Merge(m, src)
}
func (m *PhysicalStatefulClusterList) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterList) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterList.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterList proto.InternalMessageInfo

func (m *PhysicalStatefulClusterList) GetItems() []*PhysicalStatefulCluster {
	if m != nil {
		return m.Items
	}
	return nil
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type PhysicalStatefulCluster struct {
	*v1.TypeMeta         `protobuf:"bytes,1,opt,name=type_meta,json=typeMeta,proto3,embedded=type_meta" json:",inline" db:"type_meta,omitempty" url:"type_meta,omitempty"`
	*v1.ObjectMeta       `protobuf:"bytes,2,opt,name=object_meta,json=objectMeta,proto3,embedded=object_meta" json:"metadata,omitempty" db:"object_meta,omitempty" url:"object_meta,omitempty"`
	Status               *PhysicalStatefulClusterStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty" db:"status,omitempty" url:"status,omitempty"`
	Spec                 *PhysicalStatefulClusterSpec   `protobuf:"bytes,4,opt,name=spec,proto3" json:"spec,omitempty" db:"spec,omitempty" url:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *PhysicalStatefulCluster) Reset()         { *m = PhysicalStatefulCluster{} }
func (m *PhysicalStatefulCluster) String() string { return proto.CompactTextString(m) }
func (*PhysicalStatefulCluster) ProtoMessage()    {}
func (*PhysicalStatefulCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{1}
}
func (m *PhysicalStatefulCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulCluster.Merge(m, src)
}
func (m *PhysicalStatefulCluster) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulCluster.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulCluster proto.InternalMessageInfo

func (m *PhysicalStatefulCluster) GetStatus() *PhysicalStatefulClusterStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *PhysicalStatefulCluster) GetSpec() *PhysicalStatefulClusterSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

type PhysicalStatefulClusterSpec struct {
	Type                 string                             `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	Common               *PhysicalStatefulClusterCommonSpec `protobuf:"bytes,2,opt,name=common,proto3" json:"common,omitempty" db:"common,omitempty" url:"common,omitempty"`
	Cloud                *Cloud                             `protobuf:"bytes,3,opt,name=cloud,proto3" json:"cloud,omitempty" db:"cloud,omitempty" url:"cloud,omitempty"`
	Policy               *PhysicalStatefulClusterPolicy     `protobuf:"bytes,4,opt,name=policy,proto3" json:"policy,omitempty" db:"policy,omitempty" url:"policy,omitempty"`
	ClusterId            string                             `protobuf:"bytes,5,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty" db:"cluster_id,omitempty" url:"cluster_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *PhysicalStatefulClusterSpec) Reset()         { *m = PhysicalStatefulClusterSpec{} }
func (m *PhysicalStatefulClusterSpec) String() string { return proto.CompactTextString(m) }
func (*PhysicalStatefulClusterSpec) ProtoMessage()    {}
func (*PhysicalStatefulClusterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{2}
}
func (m *PhysicalStatefulClusterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterSpec.Merge(m, src)
}
func (m *PhysicalStatefulClusterSpec) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterSpec proto.InternalMessageInfo

func (m *PhysicalStatefulClusterSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PhysicalStatefulClusterSpec) GetCommon() *PhysicalStatefulClusterCommonSpec {
	if m != nil {
		return m.Common
	}
	return nil
}

func (m *PhysicalStatefulClusterSpec) GetCloud() *Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *PhysicalStatefulClusterSpec) GetPolicy() *PhysicalStatefulClusterPolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *PhysicalStatefulClusterSpec) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

type PhysicalStatefulClusterPolicy struct {
	ExternalSlaInEffect  bool     `protobuf:"varint,1,opt,name=external_sla_in_effect,json=externalSlaInEffect,proto3" json:"external_sla_in_effect,omitempty" db:"external_sla_in_effect,omitempty" url:"external_sla_in_effect,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PhysicalStatefulClusterPolicy) Reset()         { *m = PhysicalStatefulClusterPolicy{} }
func (m *PhysicalStatefulClusterPolicy) String() string { return proto.CompactTextString(m) }
func (*PhysicalStatefulClusterPolicy) ProtoMessage()    {}
func (*PhysicalStatefulClusterPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{3}
}
func (m *PhysicalStatefulClusterPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterPolicy.Merge(m, src)
}
func (m *PhysicalStatefulClusterPolicy) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterPolicy proto.InternalMessageInfo

func (m *PhysicalStatefulClusterPolicy) GetExternalSlaInEffect() bool {
	if m != nil {
		return m.ExternalSlaInEffect
	}
	return false
}

type Version struct {
	Plugin               string   `protobuf:"bytes,1,opt,name=plugin,proto3" json:"plugin,omitempty" db:"plugin,omitempty" url:"plugin,omitempty"`
	Psc                  string   `protobuf:"bytes,2,opt,name=psc,proto3" json:"psc,omitempty" db:"psc,omitempty" url:"psc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{4}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetPlugin() string {
	if m != nil {
		return m.Plugin
	}
	return ""
}

func (m *Version) GetPsc() string {
	if m != nil {
		return m.Psc
	}
	return ""
}

// This message defines list of pod attributes to be exposed to
// the container enviroment variables through Downward APIs, the list
// of the fields can be expanded in the future to include more variables
// to be exposed as described in the following link:
// https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api
type PodInfoExportPolicy struct {
	// pod attribute: "status.hostIP", env name: "HOST_IP"
	HostIp bool `protobuf:"varint,1,opt,name=host_ip,json=hostIp,proto3" json:"host_ip,omitempty" db:"host_ip,omitempty" url:"host_ip,omitempty"`
	// pod attribute: "metadata.namespace", env name: "POD_NAMESPACE"
	PodNamespace         bool     `protobuf:"varint,2,opt,name=pod_namespace,json=podNamespace,proto3" json:"pod_namespace,omitempty" db:"pod_namespace,omitempty" url:"pod_namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PodInfoExportPolicy) Reset()         { *m = PodInfoExportPolicy{} }
func (m *PodInfoExportPolicy) String() string { return proto.CompactTextString(m) }
func (*PodInfoExportPolicy) ProtoMessage()    {}
func (*PodInfoExportPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{5}
}
func (m *PodInfoExportPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodInfoExportPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodInfoExportPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodInfoExportPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodInfoExportPolicy.Merge(m, src)
}
func (m *PodInfoExportPolicy) XXX_Size() int {
	return m.Size()
}
func (m *PodInfoExportPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_PodInfoExportPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_PodInfoExportPolicy proto.InternalMessageInfo

func (m *PodInfoExportPolicy) GetHostIp() bool {
	if m != nil {
		return m.HostIp
	}
	return false
}

func (m *PodInfoExportPolicy) GetPodNamespace() bool {
	if m != nil {
		return m.PodNamespace
	}
	return false
}

// Information regarding secret to mount
// Secret keys are mounted in /mnt/secrets/secret-name/
// https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets
type MountedSecret struct {
	// secret name
	SecretRef string `protobuf:"bytes,1,opt,name=secret_ref,json=secretRef,proto3" json:"secret_ref,omitempty" db:"secret_ref,omitempty" url:"secret_ref,omitempty"`
	// optional information at key level
	KeyItems             []*KeyItem `protobuf:"bytes,2,rep,name=key_items,json=keyItems,proto3" json:"key_items,omitempty" db:"key_items,omitempty" url:"key_items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MountedSecret) Reset()         { *m = MountedSecret{} }
func (m *MountedSecret) String() string { return proto.CompactTextString(m) }
func (*MountedSecret) ProtoMessage()    {}
func (*MountedSecret) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{6}
}
func (m *MountedSecret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MountedSecret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MountedSecret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MountedSecret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountedSecret.Merge(m, src)
}
func (m *MountedSecret) XXX_Size() int {
	return m.Size()
}
func (m *MountedSecret) XXX_DiscardUnknown() {
	xxx_messageInfo_MountedSecret.DiscardUnknown(m)
}

var xxx_messageInfo_MountedSecret proto.InternalMessageInfo

func (m *MountedSecret) GetSecretRef() string {
	if m != nil {
		return m.SecretRef
	}
	return ""
}

func (m *MountedSecret) GetKeyItems() []*KeyItem {
	if m != nil {
		return m.KeyItems
	}
	return nil
}

type KeyItem struct {
	// secret key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" db:"key,omitempty" url:"key,omitempty"`
	// mount path relative to /mnt/secrets/secret-name/
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty" db:"path,omitempty" url:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyItem) Reset()         { *m = KeyItem{} }
func (m *KeyItem) String() string { return proto.CompactTextString(m) }
func (*KeyItem) ProtoMessage()    {}
func (*KeyItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{7}
}
func (m *KeyItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyItem.Merge(m, src)
}
func (m *KeyItem) XXX_Size() int {
	return m.Size()
}
func (m *KeyItem) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyItem.DiscardUnknown(m)
}

var xxx_messageInfo_KeyItem proto.InternalMessageInfo

func (m *KeyItem) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyItem) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

//This part of the spec is common across all clouds (minikube, AWS, GKE, Azure)
type PhysicalStatefulClusterCommonSpec struct {
	Container                    *Container                     `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty" db:"container,omitempty" url:"container,omitempty"`
	Replicas                     uint32                         `protobuf:"varint,2,opt,name=replicas,proto3" json:"replicas,omitempty" db:"replicas,omitempty" url:"replicas,omitempty"`
	Resources                    *PodResources                  `protobuf:"bytes,3,opt,name=resources,proto3" json:"resources,omitempty" db:"resources,omitempty" url:"resources,omitempty"`
	Placement                    map[string]*PodList            `protobuf:"bytes,4,rep,name=placement,proto3" json:"placement,omitempty" db:"placement,omitempty" url:"placement,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Network                      *Network                       `protobuf:"bytes,5,opt,name=network,proto3" json:"network,omitempty" db:"network,omitempty" url:"network,omitempty"`
	Config                       *PhysicalStatefulClusterConfig `protobuf:"bytes,6,opt,name=config,proto3" json:"config,omitempty" db:"config,omitempty" url:"config,omitempty"`
	Logs                         map[string]*Logs               `protobuf:"bytes,9,rep,name=logs,proto3" json:"logs,omitempty" db:"logs,omitempty" url:"logs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	HealthChecks                 []*HealthCheck                 `protobuf:"bytes,10,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty" db:"health_checks,omitempty" url:"health_checks,omitempty"`
	Ingress                      *Ingress                       `protobuf:"bytes,11,opt,name=ingress,proto3" json:"ingress,omitempty" db:"ingress,omitempty" url:"ingress,omitempty"`
	Metrics                      *Metrics                       `protobuf:"bytes,12,opt,name=metrics,proto3" json:"metrics,omitempty" db:"metrics,omitempty" url:"metrics,omitempty"`
	Version                      *Version                       `protobuf:"bytes,13,opt,name=version,proto3" json:"version,omitempty" db:"version,omitempty" url:"version,omitempty"`
	MinimumReplicas              uint32                         `protobuf:"varint,14,opt,name=minimum_replicas,json=minimumReplicas,proto3" json:"minimum_replicas,omitempty" db:"minimum_replicas,omitempty" url:"minimum_replicas,omitempty"`
	ClusterDeletionHandler       *ClusterDeletionHandler        `protobuf:"bytes,15,opt,name=cluster_deletion_handler,json=clusterDeletionHandler,proto3" json:"cluster_deletion_handler,omitempty" db:"cluster_deletion_handler,omitempty" url:"cluster_deletion_handler,omitempty"`
	PodSecurityContext           *PodSecurityContext            `protobuf:"bytes,16,opt,name=pod_security_context,json=podSecurityContext,proto3" json:"pod_security_context,omitempty" db:"pod_security_context,omitempty" url:"pod_security_context,omitempty"`
	PodAnnotations               map[string]string              `protobuf:"bytes,17,rep,name=pod_annotations,json=podAnnotations,proto3" json:"pod_annotations,omitempty" db:"pod_annotations,omitempty" url:"pod_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	InitContainers               []*InitContainer               `protobuf:"bytes,18,rep,name=init_containers,json=initContainers,proto3" json:"init_containers,omitempty" db:"init_containers,omitempty" url:"init_containers,omitempty"`
	PodManagementPolicy          PodManagementPolicy            `protobuf:"varint,19,opt,name=pod_management_policy,json=podManagementPolicy,proto3,enum=operator.v1.PodManagementPolicy" json:"pod_management_policy,omitempty" db:"pod_management_policy,omitempty" url:"pod_management_policy,omitempty"`
	Affinity                     *Affinity                      `protobuf:"bytes,20,opt,name=affinity,proto3" json:"affinity,omitempty" db:"affinity,omitempty" url:"affinity,omitempty"`
	SkipHostPort                 bool                           `protobuf:"varint,21,opt,name=skip_host_port,json=skipHostPort,proto3" json:"skip_host_port,omitempty" db:"skip_host_port,omitempty" url:"skip_host_port,omitempty"`
	UpdateStrategy               *UpdateStrategy                `protobuf:"bytes,22,opt,name=update_strategy,json=updateStrategy,proto3" json:"update_strategy,omitempty" db:"update_strategy,omitempty" url:"update_strategy,omitempty"`
	PscAnnotations               map[string]string              `protobuf:"bytes,23,rep,name=psc_annotations,json=pscAnnotations,proto3" json:"psc_annotations,omitempty" db:"psc_annotations,omitempty" url:"psc_annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ServiceAccount               *ServiceAccount                `protobuf:"bytes,24,opt,name=service_account,json=serviceAccount,proto3" json:"service_account,omitempty" db:"service_account,omitempty" url:"service_account,omitempty"`
	ExtraVolumes                 []*ExtraVolume                 `protobuf:"bytes,25,rep,name=extra_volumes,json=extraVolumes,proto3" json:"extra_volumes,omitempty" db:"extra_volumes,omitempty" url:"extra_volumes,omitempty"`
	PodTolerations               []*v11.Toleration              `protobuf:"bytes,28,rep,name=pod_tolerations,json=podTolerations,proto3" json:"pod_tolerations,omitempty" db:"pod_tolerations,omitempty" url:"pod_tolerations,omitempty"`
	NetworkPolicy                *NetworkPolicy                 `protobuf:"bytes,29,opt,name=network_policy,json=networkPolicy,proto3" json:"network_policy,omitempty" db:"network_policy,omitempty" url:"network_policy,omitempty"`
	AdditionalPodLabels          map[string]string              `protobuf:"bytes,30,rep,name=additional_pod_labels,json=additionalPodLabels,proto3" json:"additional_pod_labels,omitempty" db:"additional_pod_labels,omitempty" url:"additional_pod_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RuntimeClassName             string                         `protobuf:"bytes,31,opt,name=runtime_class_name,json=runtimeClassName,proto3" json:"runtime_class_name,omitempty" db:"runtime_class_name,omitempty" url:"runtime_class_name,omitempty"`
	EnableBrokerRackZoneIds      bool                           `protobuf:"varint,32,opt,name=enable_broker_rack_zone_ids,json=enableBrokerRackZoneIds,proto3" json:"enable_broker_rack_zone_ids,omitempty" db:"enable_broker_rack_zone_ids,omitempty" url:"enable_broker_rack_zone_ids,omitempty"`
	CniNetworkPolicy             *CNIProviderNetworkPolicy      `protobuf:"bytes,33,opt,name=cni_network_policy,json=cniNetworkPolicy,proto3" json:"cni_network_policy,omitempty" db:"cni_network_policy,omitempty" url:"cni_network_policy,omitempty"`
	AutoMountServiceAccountToken *BooleanType                   `protobuf:"bytes,34,opt,name=auto_mount_service_account_token,json=autoMountServiceAccountToken,proto3" json:"auto_mount_service_account_token,omitempty" db:"auto_mount_service_account_token,omitempty" url:"auto_mount_service_account_token,omitempty"`
	XXX_NoUnkeyedLiteral         struct{}                       `json:"-"`
	XXX_unrecognized             []byte                         `json:"-"`
	XXX_sizecache                int32                          `json:"-"`
}

func (m *PhysicalStatefulClusterCommonSpec) Reset()         { *m = PhysicalStatefulClusterCommonSpec{} }
func (m *PhysicalStatefulClusterCommonSpec) String() string { return proto.CompactTextString(m) }
func (*PhysicalStatefulClusterCommonSpec) ProtoMessage()    {}
func (*PhysicalStatefulClusterCommonSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{8}
}
func (m *PhysicalStatefulClusterCommonSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterCommonSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterCommonSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterCommonSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterCommonSpec.Merge(m, src)
}
func (m *PhysicalStatefulClusterCommonSpec) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterCommonSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterCommonSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterCommonSpec proto.InternalMessageInfo

func (m *PhysicalStatefulClusterCommonSpec) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetReplicas() uint32 {
	if m != nil {
		return m.Replicas
	}
	return 0
}

func (m *PhysicalStatefulClusterCommonSpec) GetResources() *PodResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetPlacement() map[string]*PodList {
	if m != nil {
		return m.Placement
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetConfig() *PhysicalStatefulClusterConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetLogs() map[string]*Logs {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetHealthChecks() []*HealthCheck {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetIngress() *Ingress {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetMetrics() *Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetMinimumReplicas() uint32 {
	if m != nil {
		return m.MinimumReplicas
	}
	return 0
}

func (m *PhysicalStatefulClusterCommonSpec) GetClusterDeletionHandler() *ClusterDeletionHandler {
	if m != nil {
		return m.ClusterDeletionHandler
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetPodSecurityContext() *PodSecurityContext {
	if m != nil {
		return m.PodSecurityContext
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetPodAnnotations() map[string]string {
	if m != nil {
		return m.PodAnnotations
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetInitContainers() []*InitContainer {
	if m != nil {
		return m.InitContainers
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetPodManagementPolicy() PodManagementPolicy {
	if m != nil {
		return m.PodManagementPolicy
	}
	return PodManagementPolicy_PARALLEL
}

func (m *PhysicalStatefulClusterCommonSpec) GetAffinity() *Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetSkipHostPort() bool {
	if m != nil {
		return m.SkipHostPort
	}
	return false
}

func (m *PhysicalStatefulClusterCommonSpec) GetUpdateStrategy() *UpdateStrategy {
	if m != nil {
		return m.UpdateStrategy
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetPscAnnotations() map[string]string {
	if m != nil {
		return m.PscAnnotations
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetServiceAccount() *ServiceAccount {
	if m != nil {
		return m.ServiceAccount
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetExtraVolumes() []*ExtraVolume {
	if m != nil {
		return m.ExtraVolumes
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetPodTolerations() []*v11.Toleration {
	if m != nil {
		return m.PodTolerations
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetNetworkPolicy() *NetworkPolicy {
	if m != nil {
		return m.NetworkPolicy
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetAdditionalPodLabels() map[string]string {
	if m != nil {
		return m.AdditionalPodLabels
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetRuntimeClassName() string {
	if m != nil {
		return m.RuntimeClassName
	}
	return ""
}

func (m *PhysicalStatefulClusterCommonSpec) GetEnableBrokerRackZoneIds() bool {
	if m != nil {
		return m.EnableBrokerRackZoneIds
	}
	return false
}

func (m *PhysicalStatefulClusterCommonSpec) GetCniNetworkPolicy() *CNIProviderNetworkPolicy {
	if m != nil {
		return m.CniNetworkPolicy
	}
	return nil
}

func (m *PhysicalStatefulClusterCommonSpec) GetAutoMountServiceAccountToken() *BooleanType {
	if m != nil {
		return m.AutoMountServiceAccountToken
	}
	return nil
}

type BooleanType struct {
	Value                bool     `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty" db:"value,omitempty" url:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BooleanType) Reset()         { *m = BooleanType{} }
func (m *BooleanType) String() string { return proto.CompactTextString(m) }
func (*BooleanType) ProtoMessage()    {}
func (*BooleanType) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{9}
}
func (m *BooleanType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BooleanType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BooleanType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BooleanType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BooleanType.Merge(m, src)
}
func (m *BooleanType) XXX_Size() int {
	return m.Size()
}
func (m *BooleanType) XXX_DiscardUnknown() {
	xxx_messageInfo_BooleanType.DiscardUnknown(m)
}

var xxx_messageInfo_BooleanType proto.InternalMessageInfo

func (m *BooleanType) GetValue() bool {
	if m != nil {
		return m.Value
	}
	return false
}

type NetworkPolicy struct {
	Ingress              []*v12.NetworkPolicyIngressRule `protobuf:"bytes,1,rep,name=ingress,proto3" json:"ingress,omitempty" db:"ingress,omitempty" url:"ingress,omitempty"`
	Egress               []*v12.NetworkPolicyEgressRule  `protobuf:"bytes,2,rep,name=egress,proto3" json:"egress,omitempty" db:"egress,omitempty" url:"egress,omitempty"`
	PolicyTypes          []string                        `protobuf:"bytes,3,rep,name=policy_types,json=policyTypes,proto3" json:"policy_types,omitempty" db:"policy_types,omitempty" url:"policy_types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *NetworkPolicy) Reset()         { *m = NetworkPolicy{} }
func (m *NetworkPolicy) String() string { return proto.CompactTextString(m) }
func (*NetworkPolicy) ProtoMessage()    {}
func (*NetworkPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{10}
}
func (m *NetworkPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkPolicy.Merge(m, src)
}
func (m *NetworkPolicy) XXX_Size() int {
	return m.Size()
}
func (m *NetworkPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkPolicy proto.InternalMessageInfo

func (m *NetworkPolicy) GetIngress() []*v12.NetworkPolicyIngressRule {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *NetworkPolicy) GetEgress() []*v12.NetworkPolicyEgressRule {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *NetworkPolicy) GetPolicyTypes() []string {
	if m != nil {
		return m.PolicyTypes
	}
	return nil
}

type ExtraVolume struct {
	// deprecated, use host_path_volume.path instead
	HostPath               string                    `protobuf:"bytes,1,opt,name=host_path,json=hostPath,proto3" json:"host_path,omitempty" db:"host_path,omitempty" url:"host_path,omitempty"` // Deprecated: Do not use.
	MountPath              string                    `protobuf:"bytes,2,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty" db:"mount_path,omitempty" url:"mount_path,omitempty"`
	Attachable             bool                      `protobuf:"varint,3,opt,name=attachable,proto3" json:"attachable,omitempty" db:"attachable,omitempty" url:"attachable,omitempty"`
	AttachToInitContainers []string                  `protobuf:"bytes,4,rep,name=attach_to_init_containers,json=attachToInitContainers,proto3" json:"attach_to_init_containers,omitempty" db:"attach_to_init_containers,omitempty" url:"attach_to_init_containers,omitempty"`
	EmptyDirVolume         *v11.EmptyDirVolumeSource `protobuf:"bytes,5,opt,name=empty_dir_volume,json=emptyDirVolume,proto3" json:"empty_dir_volume,omitempty" db:"empty_dir_volume,omitempty" url:"empty_dir_volume,omitempty"`
	HostPathVolume         *v11.HostPathVolumeSource `protobuf:"bytes,6,opt,name=host_path_volume,json=hostPathVolume,proto3" json:"host_path_volume,omitempty" db:"host_path_volume,omitempty" url:"host_path_volume,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *ExtraVolume) Reset()         { *m = ExtraVolume{} }
func (m *ExtraVolume) String() string { return proto.CompactTextString(m) }
func (*ExtraVolume) ProtoMessage()    {}
func (*ExtraVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{11}
}
func (m *ExtraVolume) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtraVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtraVolume.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtraVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtraVolume.Merge(m, src)
}
func (m *ExtraVolume) XXX_Size() int {
	return m.Size()
}
func (m *ExtraVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtraVolume.DiscardUnknown(m)
}

var xxx_messageInfo_ExtraVolume proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *ExtraVolume) GetHostPath() string {
	if m != nil {
		return m.HostPath
	}
	return ""
}

func (m *ExtraVolume) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *ExtraVolume) GetAttachable() bool {
	if m != nil {
		return m.Attachable
	}
	return false
}

func (m *ExtraVolume) GetAttachToInitContainers() []string {
	if m != nil {
		return m.AttachToInitContainers
	}
	return nil
}

func (m *ExtraVolume) GetEmptyDirVolume() *v11.EmptyDirVolumeSource {
	if m != nil {
		return m.EmptyDirVolume
	}
	return nil
}

func (m *ExtraVolume) GetHostPathVolume() *v11.HostPathVolumeSource {
	if m != nil {
		return m.HostPathVolume
	}
	return nil
}

type ServiceAccount struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Annotations          map[string]string `protobuf:"bytes,2,rep,name=annotations,proto3" json:"annotations,omitempty" db:"annotations,omitempty" url:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Apply                bool              `protobuf:"varint,3,opt,name=apply,proto3" json:"apply,omitempty" db:"apply,omitempty" url:"apply,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ServiceAccount) Reset()         { *m = ServiceAccount{} }
func (m *ServiceAccount) String() string { return proto.CompactTextString(m) }
func (*ServiceAccount) ProtoMessage()    {}
func (*ServiceAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{12}
}
func (m *ServiceAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceAccount.Merge(m, src)
}
func (m *ServiceAccount) XXX_Size() int {
	return m.Size()
}
func (m *ServiceAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceAccount.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceAccount proto.InternalMessageInfo

func (m *ServiceAccount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ServiceAccount) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ServiceAccount) GetApply() bool {
	if m != nil {
		return m.Apply
	}
	return false
}

type UpdateStrategy struct {
	Type UpdateStrategyType `protobuf:"varint,1,opt,name=type,proto3,enum=operator.v1.UpdateStrategyType" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	// Number of replicas to keep in the older version during an update, if it is rolling update, its similar to statefulset partition, if it is OnDelete, it will update num_replicas - replicas_to_not_update.
	ReplicasToNotUpdate uint32 `protobuf:"varint,2,opt,name=replicas_to_not_update,json=replicasToNotUpdate,proto3" json:"replicas_to_not_update,omitempty" db:"replicas_to_not_update,omitempty" url:"replicas_to_not_update,omitempty"`
	// The update is paused or not
	Pause bool `protobuf:"varint,3,opt,name=pause,proto3" json:"pause,omitempty" db:"pause,omitempty" url:"pause,omitempty"`
	// The update is aborted. See roll/v1/roll.proto/Roll.Operation.ABORT
	Abort                bool     `protobuf:"varint,4,opt,name=abort,proto3" json:"abort,omitempty" db:"abort,omitempty" url:"abort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateStrategy) Reset()         { *m = UpdateStrategy{} }
func (m *UpdateStrategy) String() string { return proto.CompactTextString(m) }
func (*UpdateStrategy) ProtoMessage()    {}
func (*UpdateStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{13}
}
func (m *UpdateStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateStrategy.Merge(m, src)
}
func (m *UpdateStrategy) XXX_Size() int {
	return m.Size()
}
func (m *UpdateStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateStrategy proto.InternalMessageInfo

func (m *UpdateStrategy) GetType() UpdateStrategyType {
	if m != nil {
		return m.Type
	}
	return UpdateStrategyType_ROLLING_UPDATE
}

func (m *UpdateStrategy) GetReplicasToNotUpdate() uint32 {
	if m != nil {
		return m.ReplicasToNotUpdate
	}
	return 0
}

func (m *UpdateStrategy) GetPause() bool {
	if m != nil {
		return m.Pause
	}
	return false
}

func (m *UpdateStrategy) GetAbort() bool {
	if m != nil {
		return m.Abort
	}
	return false
}

type PodSecurityContext struct {
	FsGroup              int64           `protobuf:"varint,1,opt,name=fs_group,json=fsGroup,proto3" json:"fs_group,omitempty" db:"fs_group,omitempty" url:"fs_group,omitempty"`
	RunAsGroup           int64           `protobuf:"varint,2,opt,name=run_as_group,json=runAsGroup,proto3" json:"run_as_group,omitempty" db:"run_as_group,omitempty" url:"run_as_group,omitempty"`
	RunAsNonRoot         bool            `protobuf:"varint,3,opt,name=run_as_non_root,json=runAsNonRoot,proto3" json:"run_as_non_root,omitempty" db:"run_as_non_root,omitempty" url:"run_as_non_root,omitempty"`
	RunAsUser            int64           `protobuf:"varint,4,opt,name=run_as_user,json=runAsUser,proto3" json:"run_as_user,omitempty" db:"run_as_user,omitempty" url:"run_as_user,omitempty"`
	SelinuxOptions       *SELinuxOptions `protobuf:"bytes,5,opt,name=selinux_options,json=selinuxOptions,proto3" json:"selinux_options,omitempty" db:"selinux_options,omitempty" url:"selinux_options,omitempty"`
	SupplementalGroups   []int64         `protobuf:"varint,6,rep,packed,name=supplemental_groups,json=supplementalGroups,proto3" json:"supplemental_groups,omitempty" db:"supplemental_groups,omitempty" url:"supplemental_groups,omitempty"`
	Systls               []*Sysctl       `protobuf:"bytes,7,rep,name=systls,proto3" json:"systls,omitempty" db:"systls,omitempty" url:"systls,omitempty"`
	SeccompProfile       *SeccompProfile `protobuf:"bytes,8,opt,name=seccomp_profile,json=seccompProfile,proto3" json:"seccomp_profile,omitempty" db:"seccomp_profile,omitempty" url:"seccomp_profile,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PodSecurityContext) Reset()         { *m = PodSecurityContext{} }
func (m *PodSecurityContext) String() string { return proto.CompactTextString(m) }
func (*PodSecurityContext) ProtoMessage()    {}
func (*PodSecurityContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{14}
}
func (m *PodSecurityContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodSecurityContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodSecurityContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodSecurityContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodSecurityContext.Merge(m, src)
}
func (m *PodSecurityContext) XXX_Size() int {
	return m.Size()
}
func (m *PodSecurityContext) XXX_DiscardUnknown() {
	xxx_messageInfo_PodSecurityContext.DiscardUnknown(m)
}

var xxx_messageInfo_PodSecurityContext proto.InternalMessageInfo

func (m *PodSecurityContext) GetFsGroup() int64 {
	if m != nil {
		return m.FsGroup
	}
	return 0
}

func (m *PodSecurityContext) GetRunAsGroup() int64 {
	if m != nil {
		return m.RunAsGroup
	}
	return 0
}

func (m *PodSecurityContext) GetRunAsNonRoot() bool {
	if m != nil {
		return m.RunAsNonRoot
	}
	return false
}

func (m *PodSecurityContext) GetRunAsUser() int64 {
	if m != nil {
		return m.RunAsUser
	}
	return 0
}

func (m *PodSecurityContext) GetSelinuxOptions() *SELinuxOptions {
	if m != nil {
		return m.SelinuxOptions
	}
	return nil
}

func (m *PodSecurityContext) GetSupplementalGroups() []int64 {
	if m != nil {
		return m.SupplementalGroups
	}
	return nil
}

func (m *PodSecurityContext) GetSystls() []*Sysctl {
	if m != nil {
		return m.Systls
	}
	return nil
}

func (m *PodSecurityContext) GetSeccompProfile() *SeccompProfile {
	if m != nil {
		return m.SeccompProfile
	}
	return nil
}

type SeccompProfile struct {
	Type                 string   `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	LocalhostProfile     string   `protobuf:"bytes,2,opt,name=localhost_profile,json=localhostProfile,proto3" json:"localhost_profile,omitempty" db:"localhost_profile,omitempty" url:"localhost_profile,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SeccompProfile) Reset()         { *m = SeccompProfile{} }
func (m *SeccompProfile) String() string { return proto.CompactTextString(m) }
func (*SeccompProfile) ProtoMessage()    {}
func (*SeccompProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{15}
}
func (m *SeccompProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeccompProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeccompProfile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeccompProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeccompProfile.Merge(m, src)
}
func (m *SeccompProfile) XXX_Size() int {
	return m.Size()
}
func (m *SeccompProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_SeccompProfile.DiscardUnknown(m)
}

var xxx_messageInfo_SeccompProfile proto.InternalMessageInfo

func (m *SeccompProfile) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SeccompProfile) GetLocalhostProfile() string {
	if m != nil {
		return m.LocalhostProfile
	}
	return ""
}

type SELinuxOptions struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty" db:"user,omitempty" url:"user,omitempty"`
	Role                 string   `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty" db:"role,omitempty" url:"role,omitempty"`
	Type                 string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	Level                string   `protobuf:"bytes,4,opt,name=level,proto3" json:"level,omitempty" db:"level,omitempty" url:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SELinuxOptions) Reset()         { *m = SELinuxOptions{} }
func (m *SELinuxOptions) String() string { return proto.CompactTextString(m) }
func (*SELinuxOptions) ProtoMessage()    {}
func (*SELinuxOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{16}
}
func (m *SELinuxOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SELinuxOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SELinuxOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SELinuxOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SELinuxOptions.Merge(m, src)
}
func (m *SELinuxOptions) XXX_Size() int {
	return m.Size()
}
func (m *SELinuxOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SELinuxOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SELinuxOptions proto.InternalMessageInfo

func (m *SELinuxOptions) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SELinuxOptions) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SELinuxOptions) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SELinuxOptions) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

type Sysctl struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" db:"value,omitempty" url:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Sysctl) Reset()         { *m = Sysctl{} }
func (m *Sysctl) String() string { return proto.CompactTextString(m) }
func (*Sysctl) ProtoMessage()    {}
func (*Sysctl) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{17}
}
func (m *Sysctl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sysctl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sysctl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sysctl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sysctl.Merge(m, src)
}
func (m *Sysctl) XXX_Size() int {
	return m.Size()
}
func (m *Sysctl) XXX_DiscardUnknown() {
	xxx_messageInfo_Sysctl.DiscardUnknown(m)
}

var xxx_messageInfo_Sysctl proto.InternalMessageInfo

func (m *Sysctl) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Sysctl) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type ClusterDeletionHandler struct {
	ExecCommand          []string `protobuf:"bytes,1,rep,name=exec_command,json=execCommand,proto3" json:"exec_command,omitempty" db:"exec_command,omitempty" url:"exec_command,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterDeletionHandler) Reset()         { *m = ClusterDeletionHandler{} }
func (m *ClusterDeletionHandler) String() string { return proto.CompactTextString(m) }
func (*ClusterDeletionHandler) ProtoMessage()    {}
func (*ClusterDeletionHandler) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{18}
}
func (m *ClusterDeletionHandler) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterDeletionHandler) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterDeletionHandler.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterDeletionHandler) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterDeletionHandler.Merge(m, src)
}
func (m *ClusterDeletionHandler) XXX_Size() int {
	return m.Size()
}
func (m *ClusterDeletionHandler) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterDeletionHandler.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterDeletionHandler proto.InternalMessageInfo

func (m *ClusterDeletionHandler) GetExecCommand() []string {
	if m != nil {
		return m.ExecCommand
	}
	return nil
}

type PodList struct {
	Pods                 []string `protobuf:"bytes,1,rep,name=pods,proto3" json:"pods,omitempty" db:"pods,omitempty" url:"pods,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PodList) Reset()         { *m = PodList{} }
func (m *PodList) String() string { return proto.CompactTextString(m) }
func (*PodList) ProtoMessage()    {}
func (*PodList) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{19}
}
func (m *PodList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodList.Merge(m, src)
}
func (m *PodList) XXX_Size() int {
	return m.Size()
}
func (m *PodList) XXX_DiscardUnknown() {
	xxx_messageInfo_PodList.DiscardUnknown(m)
}

var xxx_messageInfo_PodList proto.InternalMessageInfo

func (m *PodList) GetPods() []string {
	if m != nil {
		return m.Pods
	}
	return nil
}

type Container struct {
	Image                         string               `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty" db:"image,omitempty" url:"image,omitempty"`
	Command                       []string             `protobuf:"bytes,2,rep,name=command,proto3" json:"command,omitempty" db:"command,omitempty" url:"command,omitempty"`
	Args                          []string             `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty" db:"args,omitempty" url:"args,omitempty"`
	TerminationGracePeriodSeconds int64                `protobuf:"varint,6,opt,name=termination_grace_period_seconds,json=terminationGracePeriodSeconds,proto3" json:"termination_grace_period_seconds,omitempty" db:"termination_grace_period_seconds,omitempty" url:"termination_grace_period_seconds,omitempty"`
	PreStopHandler                *PreStopHandler      `protobuf:"bytes,7,opt,name=pre_stop_handler,json=preStopHandler,proto3" json:"pre_stop_handler,omitempty" db:"pre_stop_handler,omitempty" url:"pre_stop_handler,omitempty"`
	ReadinessProbe                *Probe               `protobuf:"bytes,8,opt,name=readiness_probe,json=readinessProbe,proto3" json:"readiness_probe,omitempty" db:"readiness_probe,omitempty" url:"readiness_probe,omitempty"`
	LivenessProbe                 *Probe               `protobuf:"bytes,9,opt,name=liveness_probe,json=livenessProbe,proto3" json:"liveness_probe,omitempty" db:"liveness_probe,omitempty" url:"liveness_probe,omitempty"`
	EnvVar                        map[string]string    `protobuf:"bytes,10,rep,name=env_var,json=envVar,proto3" json:"env_var,omitempty" db:"env_var,omitempty" url:"env_var,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ServiceAccount                string               `protobuf:"bytes,11,opt,name=service_account,json=serviceAccount,proto3" json:"service_account,omitempty" db:"service_account,omitempty" url:"service_account,omitempty"`
	NodeAffinity                  *NodeAffinity        `protobuf:"bytes,12,opt,name=node_affinity,json=nodeAffinity,proto3" json:"node_affinity,omitempty" db:"node_affinity,omitempty" url:"node_affinity,omitempty"`
	Rack                          *Rack                `protobuf:"bytes,13,opt,name=rack,proto3" json:"rack,omitempty" db:"rack,omitempty" url:"rack,omitempty"`
	PodInfoExportPolicy           *PodInfoExportPolicy `protobuf:"bytes,14,opt,name=pod_info_export_policy,json=podInfoExportPolicy,proto3" json:"pod_info_export_policy,omitempty" db:"pod_info_export_policy,omitempty" url:"pod_info_export_policy,omitempty"`
	MountedSecrets                []*MountedSecret     `protobuf:"bytes,15,rep,name=mounted_secrets,json=mountedSecrets,proto3" json:"mounted_secrets,omitempty" db:"mounted_secrets,omitempty" url:"mounted_secrets,omitempty"`
	SecurityContext               *SecurityContext     `protobuf:"bytes,16,opt,name=security_context,json=securityContext,proto3" json:"security_context,omitempty" db:"security_context,omitempty" url:"security_context,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}             `json:"-"`
	XXX_unrecognized              []byte               `json:"-"`
	XXX_sizecache                 int32                `json:"-"`
}

func (m *Container) Reset()         { *m = Container{} }
func (m *Container) String() string { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()    {}
func (*Container) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{20}
}
func (m *Container) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Container.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Container) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Container.Merge(m, src)
}
func (m *Container) XXX_Size() int {
	return m.Size()
}
func (m *Container) XXX_DiscardUnknown() {
	xxx_messageInfo_Container.DiscardUnknown(m)
}

var xxx_messageInfo_Container proto.InternalMessageInfo

func (m *Container) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Container) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *Container) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Container) GetTerminationGracePeriodSeconds() int64 {
	if m != nil {
		return m.TerminationGracePeriodSeconds
	}
	return 0
}

func (m *Container) GetPreStopHandler() *PreStopHandler {
	if m != nil {
		return m.PreStopHandler
	}
	return nil
}

func (m *Container) GetReadinessProbe() *Probe {
	if m != nil {
		return m.ReadinessProbe
	}
	return nil
}

func (m *Container) GetLivenessProbe() *Probe {
	if m != nil {
		return m.LivenessProbe
	}
	return nil
}

func (m *Container) GetEnvVar() map[string]string {
	if m != nil {
		return m.EnvVar
	}
	return nil
}

func (m *Container) GetServiceAccount() string {
	if m != nil {
		return m.ServiceAccount
	}
	return ""
}

func (m *Container) GetNodeAffinity() *NodeAffinity {
	if m != nil {
		return m.NodeAffinity
	}
	return nil
}

func (m *Container) GetRack() *Rack {
	if m != nil {
		return m.Rack
	}
	return nil
}

func (m *Container) GetPodInfoExportPolicy() *PodInfoExportPolicy {
	if m != nil {
		return m.PodInfoExportPolicy
	}
	return nil
}

func (m *Container) GetMountedSecrets() []*MountedSecret {
	if m != nil {
		return m.MountedSecrets
	}
	return nil
}

func (m *Container) GetSecurityContext() *SecurityContext {
	if m != nil {
		return m.SecurityContext
	}
	return nil
}

type SecurityContext struct {
	RunAsGroup               int64    `protobuf:"varint,1,opt,name=run_as_group,json=runAsGroup,proto3" json:"run_as_group,omitempty" db:"run_as_group,omitempty" url:"run_as_group,omitempty"`
	RunAsNonRoot             bool     `protobuf:"varint,2,opt,name=run_as_non_root,json=runAsNonRoot,proto3" json:"run_as_non_root,omitempty" db:"run_as_non_root,omitempty" url:"run_as_non_root,omitempty"`
	RunAsUser                int64    `protobuf:"varint,3,opt,name=run_as_user,json=runAsUser,proto3" json:"run_as_user,omitempty" db:"run_as_user,omitempty" url:"run_as_user,omitempty"`
	Privileged               bool     `protobuf:"varint,4,opt,name=privileged,proto3" json:"privileged,omitempty" db:"privileged,omitempty" url:"privileged,omitempty"`
	AllowPrivilegeEscalation bool     `protobuf:"varint,5,opt,name=allow_privilege_escalation,json=allowPrivilegeEscalation,proto3" json:"allow_privilege_escalation,omitempty" db:"allow_privilege_escalation,omitempty" url:"allow_privilege_escalation,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *SecurityContext) Reset()         { *m = SecurityContext{} }
func (m *SecurityContext) String() string { return proto.CompactTextString(m) }
func (*SecurityContext) ProtoMessage()    {}
func (*SecurityContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{21}
}
func (m *SecurityContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityContext.Merge(m, src)
}
func (m *SecurityContext) XXX_Size() int {
	return m.Size()
}
func (m *SecurityContext) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityContext.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityContext proto.InternalMessageInfo

func (m *SecurityContext) GetRunAsGroup() int64 {
	if m != nil {
		return m.RunAsGroup
	}
	return 0
}

func (m *SecurityContext) GetRunAsNonRoot() bool {
	if m != nil {
		return m.RunAsNonRoot
	}
	return false
}

func (m *SecurityContext) GetRunAsUser() int64 {
	if m != nil {
		return m.RunAsUser
	}
	return 0
}

func (m *SecurityContext) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *SecurityContext) GetAllowPrivilegeEscalation() bool {
	if m != nil {
		return m.AllowPrivilegeEscalation
	}
	return false
}

type InitContainer struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Image                string            `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty" db:"image,omitempty" url:"image,omitempty"`
	Command              []string          `protobuf:"bytes,3,rep,name=command,proto3" json:"command,omitempty" db:"command,omitempty" url:"command,omitempty"`
	Args                 []string          `protobuf:"bytes,4,rep,name=args,proto3" json:"args,omitempty" db:"args,omitempty" url:"args,omitempty"`
	EnvVar               map[string]string `protobuf:"bytes,5,rep,name=env_var,json=envVar,proto3" json:"env_var,omitempty" db:"env_var,omitempty" url:"env_var,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Resources            *PodResources     `protobuf:"bytes,6,opt,name=resources,proto3" json:"resources,omitempty" db:"resources,omitempty" url:"resources,omitempty"`
	SecurityContext      *SecurityContext  `protobuf:"bytes,7,opt,name=security_context,json=securityContext,proto3" json:"security_context,omitempty" db:"security_context,omitempty" url:"security_context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *InitContainer) Reset()         { *m = InitContainer{} }
func (m *InitContainer) String() string { return proto.CompactTextString(m) }
func (*InitContainer) ProtoMessage()    {}
func (*InitContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{22}
}
func (m *InitContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitContainer.Merge(m, src)
}
func (m *InitContainer) XXX_Size() int {
	return m.Size()
}
func (m *InitContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_InitContainer.DiscardUnknown(m)
}

var xxx_messageInfo_InitContainer proto.InternalMessageInfo

func (m *InitContainer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InitContainer) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *InitContainer) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *InitContainer) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *InitContainer) GetEnvVar() map[string]string {
	if m != nil {
		return m.EnvVar
	}
	return nil
}

func (m *InitContainer) GetResources() *PodResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *InitContainer) GetSecurityContext() *SecurityContext {
	if m != nil {
		return m.SecurityContext
	}
	return nil
}

type Affinity struct {
	NodeAffinity         *NodeAffinity     `protobuf:"bytes,1,opt,name=node_affinity,json=nodeAffinity,proto3" json:"node_affinity,omitempty" db:"node_affinity,omitempty" url:"node_affinity,omitempty"`
	PodAffinity          *PodLevelAffinity `protobuf:"bytes,2,opt,name=pod_affinity,json=podAffinity,proto3" json:"pod_affinity,omitempty" db:"pod_affinity,omitempty" url:"pod_affinity,omitempty"`
	PodAntiAffinity      *PodLevelAffinity `protobuf:"bytes,3,opt,name=pod_anti_affinity,json=podAntiAffinity,proto3" json:"pod_anti_affinity,omitempty" db:"pod_anti_affinity,omitempty" url:"pod_anti_affinity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Affinity) Reset()         { *m = Affinity{} }
func (m *Affinity) String() string { return proto.CompactTextString(m) }
func (*Affinity) ProtoMessage()    {}
func (*Affinity) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{23}
}
func (m *Affinity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Affinity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Affinity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Affinity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Affinity.Merge(m, src)
}
func (m *Affinity) XXX_Size() int {
	return m.Size()
}
func (m *Affinity) XXX_DiscardUnknown() {
	xxx_messageInfo_Affinity.DiscardUnknown(m)
}

var xxx_messageInfo_Affinity proto.InternalMessageInfo

func (m *Affinity) GetNodeAffinity() *NodeAffinity {
	if m != nil {
		return m.NodeAffinity
	}
	return nil
}

func (m *Affinity) GetPodAffinity() *PodLevelAffinity {
	if m != nil {
		return m.PodAffinity
	}
	return nil
}

func (m *Affinity) GetPodAntiAffinity() *PodLevelAffinity {
	if m != nil {
		return m.PodAntiAffinity
	}
	return nil
}

type NodeAffinity struct {
	Key                  string       `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" db:"key,omitempty" url:"key,omitempty"`
	Values               []string     `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty" db:"values,omitempty" url:"values,omitempty"`
	Rule                 AffinityRule `protobuf:"varint,3,opt,name=rule,proto3,enum=operator.v1.AffinityRule" json:"rule,omitempty" db:"rule,omitempty" url:"rule,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NodeAffinity) Reset()         { *m = NodeAffinity{} }
func (m *NodeAffinity) String() string { return proto.CompactTextString(m) }
func (*NodeAffinity) ProtoMessage()    {}
func (*NodeAffinity) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{24}
}
func (m *NodeAffinity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAffinity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeAffinity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeAffinity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAffinity.Merge(m, src)
}
func (m *NodeAffinity) XXX_Size() int {
	return m.Size()
}
func (m *NodeAffinity) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAffinity.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAffinity proto.InternalMessageInfo

func (m *NodeAffinity) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *NodeAffinity) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *NodeAffinity) GetRule() AffinityRule {
	if m != nil {
		return m.Rule
	}
	return AffinityRule_PREFERRED
}

type PodLevelAffinity struct {
	Rule                 AffinityRule            `protobuf:"varint,1,opt,name=rule,proto3,enum=operator.v1.AffinityRule" json:"rule,omitempty" db:"rule,omitempty" url:"rule,omitempty"`
	Terms                []*PodLevelAffinityTerm `protobuf:"bytes,2,rep,name=terms,proto3" json:"terms,omitempty" db:"terms,omitempty" url:"terms,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *PodLevelAffinity) Reset()         { *m = PodLevelAffinity{} }
func (m *PodLevelAffinity) String() string { return proto.CompactTextString(m) }
func (*PodLevelAffinity) ProtoMessage()    {}
func (*PodLevelAffinity) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{25}
}
func (m *PodLevelAffinity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodLevelAffinity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodLevelAffinity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodLevelAffinity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodLevelAffinity.Merge(m, src)
}
func (m *PodLevelAffinity) XXX_Size() int {
	return m.Size()
}
func (m *PodLevelAffinity) XXX_DiscardUnknown() {
	xxx_messageInfo_PodLevelAffinity.DiscardUnknown(m)
}

var xxx_messageInfo_PodLevelAffinity proto.InternalMessageInfo

func (m *PodLevelAffinity) GetRule() AffinityRule {
	if m != nil {
		return m.Rule
	}
	return AffinityRule_PREFERRED
}

func (m *PodLevelAffinity) GetTerms() []*PodLevelAffinityTerm {
	if m != nil {
		return m.Terms
	}
	return nil
}

type PodLevelAffinityTerm struct {
	Key                  string       `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" db:"key,omitempty" url:"key,omitempty"`
	Values               []string     `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty" db:"values,omitempty" url:"values,omitempty"`
	Namespaces           []string     `protobuf:"bytes,3,rep,name=namespaces,proto3" json:"namespaces,omitempty" db:"namespaces,omitempty" url:"namespaces,omitempty"`
	TopologyKey          *TopologyKey `protobuf:"bytes,4,opt,name=topology_key,json=topologyKey,proto3" json:"topology_key,omitempty" db:"topology_key,omitempty" url:"topology_key,omitempty"`
	Weight               *Weight      `protobuf:"bytes,5,opt,name=weight,proto3" json:"weight,omitempty" db:"weight,omitempty" url:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PodLevelAffinityTerm) Reset()         { *m = PodLevelAffinityTerm{} }
func (m *PodLevelAffinityTerm) String() string { return proto.CompactTextString(m) }
func (*PodLevelAffinityTerm) ProtoMessage()    {}
func (*PodLevelAffinityTerm) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{26}
}
func (m *PodLevelAffinityTerm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodLevelAffinityTerm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodLevelAffinityTerm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodLevelAffinityTerm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodLevelAffinityTerm.Merge(m, src)
}
func (m *PodLevelAffinityTerm) XXX_Size() int {
	return m.Size()
}
func (m *PodLevelAffinityTerm) XXX_DiscardUnknown() {
	xxx_messageInfo_PodLevelAffinityTerm.DiscardUnknown(m)
}

var xxx_messageInfo_PodLevelAffinityTerm proto.InternalMessageInfo

func (m *PodLevelAffinityTerm) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *PodLevelAffinityTerm) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *PodLevelAffinityTerm) GetNamespaces() []string {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func (m *PodLevelAffinityTerm) GetTopologyKey() *TopologyKey {
	if m != nil {
		return m.TopologyKey
	}
	return nil
}

func (m *PodLevelAffinityTerm) GetWeight() *Weight {
	if m != nil {
		return m.Weight
	}
	return nil
}

type TopologyKey struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" db:"key,omitempty" url:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopologyKey) Reset()         { *m = TopologyKey{} }
func (m *TopologyKey) String() string { return proto.CompactTextString(m) }
func (*TopologyKey) ProtoMessage()    {}
func (*TopologyKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{27}
}
func (m *TopologyKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopologyKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopologyKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopologyKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopologyKey.Merge(m, src)
}
func (m *TopologyKey) XXX_Size() int {
	return m.Size()
}
func (m *TopologyKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TopologyKey.DiscardUnknown(m)
}

var xxx_messageInfo_TopologyKey proto.InternalMessageInfo

func (m *TopologyKey) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type Weight struct {
	Weight               int32    `protobuf:"varint,1,opt,name=weight,proto3" json:"weight,omitempty" db:"weight,omitempty" url:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Weight) Reset()         { *m = Weight{} }
func (m *Weight) String() string { return proto.CompactTextString(m) }
func (*Weight) ProtoMessage()    {}
func (*Weight) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{28}
}
func (m *Weight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Weight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Weight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Weight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Weight.Merge(m, src)
}
func (m *Weight) XXX_Size() int {
	return m.Size()
}
func (m *Weight) XXX_DiscardUnknown() {
	xxx_messageInfo_Weight.DiscardUnknown(m)
}

var xxx_messageInfo_Weight proto.InternalMessageInfo

func (m *Weight) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

type Rack struct {
	TopologyKey          string   `protobuf:"bytes,1,opt,name=topology_key,json=topologyKey,proto3" json:"topology_key,omitempty" db:"topology_key,omitempty" url:"topology_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rack) Reset()         { *m = Rack{} }
func (m *Rack) String() string { return proto.CompactTextString(m) }
func (*Rack) ProtoMessage()    {}
func (*Rack) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{29}
}
func (m *Rack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rack.Merge(m, src)
}
func (m *Rack) XXX_Size() int {
	return m.Size()
}
func (m *Rack) XXX_DiscardUnknown() {
	xxx_messageInfo_Rack.DiscardUnknown(m)
}

var xxx_messageInfo_Rack proto.InternalMessageInfo

func (m *Rack) GetTopologyKey() string {
	if m != nil {
		return m.TopologyKey
	}
	return ""
}

type Probe struct {
	InitialDelaySeconds int32 `protobuf:"varint,2,opt,name=initial_delay_seconds,json=initialDelaySeconds,proto3" json:"initial_delay_seconds,omitempty" db:"initial_delay_seconds,omitempty" url:"initial_delay_seconds,omitempty"`
	TimeoutSeconds      int32 `protobuf:"varint,3,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty" db:"timeout_seconds,omitempty" url:"timeout_seconds,omitempty"`
	PeriodSeconds       int32 `protobuf:"varint,4,opt,name=period_seconds,json=periodSeconds,proto3" json:"period_seconds,omitempty" db:"period_seconds,omitempty" url:"period_seconds,omitempty"`
	SuccessThreshold    int32 `protobuf:"varint,5,opt,name=success_threshold,json=successThreshold,proto3" json:"success_threshold,omitempty" db:"success_threshold,omitempty" url:"success_threshold,omitempty"`
	FailureThreshold    int32 `protobuf:"varint,6,opt,name=failure_threshold,json=failureThreshold,proto3" json:"failure_threshold,omitempty" db:"failure_threshold,omitempty" url:"failure_threshold,omitempty"`
	// must only specify one of 'exec', 'http', or 'tcp'
	Exec                 *ExecHandler `protobuf:"bytes,8,opt,name=exec,proto3" json:"exec,omitempty" db:"exec,omitempty" url:"exec,omitempty"`
	Http                 *HTTPHandler `protobuf:"bytes,9,opt,name=http,proto3" json:"http,omitempty" db:"http,omitempty" url:"http,omitempty"`
	Tcp                  *TCPHandler  `protobuf:"bytes,10,opt,name=tcp,proto3" json:"tcp,omitempty" db:"tcp,omitempty" url:"tcp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Probe) Reset()         { *m = Probe{} }
func (m *Probe) String() string { return proto.CompactTextString(m) }
func (*Probe) ProtoMessage()    {}
func (*Probe) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{30}
}
func (m *Probe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Probe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Probe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Probe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Probe.Merge(m, src)
}
func (m *Probe) XXX_Size() int {
	return m.Size()
}
func (m *Probe) XXX_DiscardUnknown() {
	xxx_messageInfo_Probe.DiscardUnknown(m)
}

var xxx_messageInfo_Probe proto.InternalMessageInfo

func (m *Probe) GetInitialDelaySeconds() int32 {
	if m != nil {
		return m.InitialDelaySeconds
	}
	return 0
}

func (m *Probe) GetTimeoutSeconds() int32 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

func (m *Probe) GetPeriodSeconds() int32 {
	if m != nil {
		return m.PeriodSeconds
	}
	return 0
}

func (m *Probe) GetSuccessThreshold() int32 {
	if m != nil {
		return m.SuccessThreshold
	}
	return 0
}

func (m *Probe) GetFailureThreshold() int32 {
	if m != nil {
		return m.FailureThreshold
	}
	return 0
}

func (m *Probe) GetExec() *ExecHandler {
	if m != nil {
		return m.Exec
	}
	return nil
}

func (m *Probe) GetHttp() *HTTPHandler {
	if m != nil {
		return m.Http
	}
	return nil
}

func (m *Probe) GetTcp() *TCPHandler {
	if m != nil {
		return m.Tcp
	}
	return nil
}

type ExecHandler struct {
	Command              []string `protobuf:"bytes,1,rep,name=command,proto3" json:"command,omitempty" db:"command,omitempty" url:"command,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecHandler) Reset()         { *m = ExecHandler{} }
func (m *ExecHandler) String() string { return proto.CompactTextString(m) }
func (*ExecHandler) ProtoMessage()    {}
func (*ExecHandler) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{31}
}
func (m *ExecHandler) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecHandler) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecHandler.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecHandler) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecHandler.Merge(m, src)
}
func (m *ExecHandler) XXX_Size() int {
	return m.Size()
}
func (m *ExecHandler) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecHandler.DiscardUnknown(m)
}

var xxx_messageInfo_ExecHandler proto.InternalMessageInfo

func (m *ExecHandler) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

type HTTPHandler struct {
	Scheme               HTTPHandler_URIScheme `protobuf:"varint,1,opt,name=scheme,proto3,enum=operator.v1.HTTPHandler_URIScheme" json:"scheme,omitempty" db:"scheme,omitempty" url:"scheme,omitempty"`
	Port                 uint32                `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty" db:"port,omitempty" url:"port,omitempty"`
	Path                 string                `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty" db:"path,omitempty" url:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *HTTPHandler) Reset()         { *m = HTTPHandler{} }
func (m *HTTPHandler) String() string { return proto.CompactTextString(m) }
func (*HTTPHandler) ProtoMessage()    {}
func (*HTTPHandler) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{32}
}
func (m *HTTPHandler) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPHandler) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPHandler.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTPHandler) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPHandler.Merge(m, src)
}
func (m *HTTPHandler) XXX_Size() int {
	return m.Size()
}
func (m *HTTPHandler) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPHandler.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPHandler proto.InternalMessageInfo

func (m *HTTPHandler) GetScheme() HTTPHandler_URIScheme {
	if m != nil {
		return m.Scheme
	}
	return HTTPHandler_HTTP
}

func (m *HTTPHandler) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *HTTPHandler) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type TCPHandler struct {
	Port                 uint32   `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty" db:"port,omitempty" url:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TCPHandler) Reset()         { *m = TCPHandler{} }
func (m *TCPHandler) String() string { return proto.CompactTextString(m) }
func (*TCPHandler) ProtoMessage()    {}
func (*TCPHandler) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{33}
}
func (m *TCPHandler) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPHandler) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCPHandler.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TCPHandler) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPHandler.Merge(m, src)
}
func (m *TCPHandler) XXX_Size() int {
	return m.Size()
}
func (m *TCPHandler) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPHandler.DiscardUnknown(m)
}

var xxx_messageInfo_TCPHandler proto.InternalMessageInfo

func (m *TCPHandler) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type PreStopHandler struct {
	ExecCommand          []string `protobuf:"bytes,1,rep,name=exec_command,json=execCommand,proto3" json:"exec_command,omitempty" db:"exec_command,omitempty" url:"exec_command,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PreStopHandler) Reset()         { *m = PreStopHandler{} }
func (m *PreStopHandler) String() string { return proto.CompactTextString(m) }
func (*PreStopHandler) ProtoMessage()    {}
func (*PreStopHandler) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{34}
}
func (m *PreStopHandler) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreStopHandler) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreStopHandler.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreStopHandler) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreStopHandler.Merge(m, src)
}
func (m *PreStopHandler) XXX_Size() int {
	return m.Size()
}
func (m *PreStopHandler) XXX_DiscardUnknown() {
	xxx_messageInfo_PreStopHandler.DiscardUnknown(m)
}

var xxx_messageInfo_PreStopHandler proto.InternalMessageInfo

func (m *PreStopHandler) GetExecCommand() []string {
	if m != nil {
		return m.ExecCommand
	}
	return nil
}

type Network struct {
	Proxy                            *Proxy            `protobuf:"bytes,1,opt,name=proxy,proto3" json:"proxy,omitempty" db:"proxy,omitempty" url:"proxy,omitempty"`
	Ports                            []*Port           `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty" db:"ports,omitempty" url:"ports,omitempty"`
	ClientEndpoints                  *ClientEndpoints  `protobuf:"bytes,3,opt,name=client_endpoints,json=clientEndpoints,proto3" json:"client_endpoints,omitempty" db:"client_endpoints,omitempty" url:"client_endpoints,omitempty"`
	DiscoveryService                 *DiscoveryService `protobuf:"bytes,4,opt,name=discovery_service,json=discoveryService,proto3" json:"discovery_service,omitempty" db:"discovery_service,omitempty" url:"discovery_service,omitempty"`
	ServiceType                      string            `protobuf:"bytes,5,opt,name=service_type,json=serviceType,proto3" json:"service_type,omitempty" db:"service_type,omitempty" url:"service_type,omitempty"` // Deprecated: Do not use.
	UseDefaultResolverForHealthcheck bool              `protobuf:"varint,6,opt,name=use_default_resolver_for_healthcheck,json=useDefaultResolverForHealthcheck,proto3" json:"use_default_resolver_for_healthcheck,omitempty" db:"use_default_resolver_for_healthcheck,omitempty" url:"use_default_resolver_for_healthcheck,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}          `json:"-"`
	XXX_unrecognized                 []byte            `json:"-"`
	XXX_sizecache                    int32             `json:"-"`
}

func (m *Network) Reset()         { *m = Network{} }
func (m *Network) String() string { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()    {}
func (*Network) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{35}
}
func (m *Network) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Network) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Network.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Network) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Network.Merge(m, src)
}
func (m *Network) XXX_Size() int {
	return m.Size()
}
func (m *Network) XXX_DiscardUnknown() {
	xxx_messageInfo_Network.DiscardUnknown(m)
}

var xxx_messageInfo_Network proto.InternalMessageInfo

func (m *Network) GetProxy() *Proxy {
	if m != nil {
		return m.Proxy
	}
	return nil
}

func (m *Network) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Network) GetClientEndpoints() *ClientEndpoints {
	if m != nil {
		return m.ClientEndpoints
	}
	return nil
}

func (m *Network) GetDiscoveryService() *DiscoveryService {
	if m != nil {
		return m.DiscoveryService
	}
	return nil
}

// Deprecated: Do not use.
func (m *Network) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

func (m *Network) GetUseDefaultResolverForHealthcheck() bool {
	if m != nil {
		return m.UseDefaultResolverForHealthcheck
	}
	return false
}

type DiscoveryService struct {
	Annotations          map[string]string `protobuf:"bytes,1,rep,name=annotations,proto3" json:"annotations,omitempty" db:"annotations,omitempty" url:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Labels               map[string]string `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels,omitempty" db:"labels,omitempty" url:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DiscoveryService) Reset()         { *m = DiscoveryService{} }
func (m *DiscoveryService) String() string { return proto.CompactTextString(m) }
func (*DiscoveryService) ProtoMessage()    {}
func (*DiscoveryService) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{36}
}
func (m *DiscoveryService) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoveryService) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscoveryService.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscoveryService) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoveryService.Merge(m, src)
}
func (m *DiscoveryService) XXX_Size() int {
	return m.Size()
}
func (m *DiscoveryService) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoveryService.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoveryService proto.InternalMessageInfo

func (m *DiscoveryService) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *DiscoveryService) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type ClientEndpoints struct {
	// This field is deprecated as physical clusters no longer
	// have external endpoints. More details can be found in MCM-266
	External             string   `protobuf:"bytes,1,opt,name=external,proto3" json:"external,omitempty" db:"external,omitempty" url:"external,omitempty"`
	Internal             string   `protobuf:"bytes,2,opt,name=internal,proto3" json:"internal,omitempty" db:"internal,omitempty" url:"internal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientEndpoints) Reset()         { *m = ClientEndpoints{} }
func (m *ClientEndpoints) String() string { return proto.CompactTextString(m) }
func (*ClientEndpoints) ProtoMessage()    {}
func (*ClientEndpoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{37}
}
func (m *ClientEndpoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientEndpoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientEndpoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientEndpoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientEndpoints.Merge(m, src)
}
func (m *ClientEndpoints) XXX_Size() int {
	return m.Size()
}
func (m *ClientEndpoints) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientEndpoints.DiscardUnknown(m)
}

var xxx_messageInfo_ClientEndpoints proto.InternalMessageInfo

func (m *ClientEndpoints) GetExternal() string {
	if m != nil {
		return m.External
	}
	return ""
}

func (m *ClientEndpoints) GetInternal() string {
	if m != nil {
		return m.Internal
	}
	return ""
}

type Metrics struct {
	IntervalSecs         uint32        `protobuf:"varint,1,opt,name=interval_secs,json=intervalSecs,proto3" json:"interval_secs,omitempty" db:"interval_secs,omitempty" url:"interval_secs,omitempty"`
	RetentionMonths      uint32        `protobuf:"varint,3,opt,name=retention_months,json=retentionMonths,proto3" json:"retention_months,omitempty" db:"retention_months,omitempty" url:"retention_months,omitempty"`
	Port                 uint32        `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty" db:"port,omitempty" url:"port,omitempty"`
	Scheme               string        `protobuf:"bytes,5,opt,name=scheme,proto3" json:"scheme,omitempty" db:"scheme,omitempty" url:"scheme,omitempty"`
	MetricsPath          string        `protobuf:"bytes,6,opt,name=metrics_path,json=metricsPath,proto3" json:"metrics_path,omitempty" db:"metrics_path,omitempty" url:"metrics_path,omitempty"`
	Sinks                []*MetricSink `protobuf:"bytes,7,rep,name=sinks,proto3" json:"sinks,omitempty" db:"sinks,omitempty" url:"sinks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{38}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetIntervalSecs() uint32 {
	if m != nil {
		return m.IntervalSecs
	}
	return 0
}

func (m *Metrics) GetRetentionMonths() uint32 {
	if m != nil {
		return m.RetentionMonths
	}
	return 0
}

func (m *Metrics) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Metrics) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *Metrics) GetMetricsPath() string {
	if m != nil {
		return m.MetricsPath
	}
	return ""
}

func (m *Metrics) GetSinks() []*MetricSink {
	if m != nil {
		return m.Sinks
	}
	return nil
}

type MetricSink struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	Blacklist            []string `protobuf:"bytes,2,rep,name=blacklist,proto3" json:"blacklist,omitempty" db:"blacklist,omitempty" url:"blacklist,omitempty"`
	Whitelist            []string `protobuf:"bytes,3,rep,name=whitelist,proto3" json:"whitelist,omitempty" db:"whitelist,omitempty" url:"whitelist,omitempty"`
	Deltalist            []string `protobuf:"bytes,4,rep,name=deltalist,proto3" json:"deltalist,omitempty" db:"deltalist,omitempty" url:"deltalist,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetricSink) Reset()         { *m = MetricSink{} }
func (m *MetricSink) String() string { return proto.CompactTextString(m) }
func (*MetricSink) ProtoMessage()    {}
func (*MetricSink) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{39}
}
func (m *MetricSink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricSink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricSink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricSink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricSink.Merge(m, src)
}
func (m *MetricSink) XXX_Size() int {
	return m.Size()
}
func (m *MetricSink) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricSink.DiscardUnknown(m)
}

var xxx_messageInfo_MetricSink proto.InternalMessageInfo

func (m *MetricSink) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MetricSink) GetBlacklist() []string {
	if m != nil {
		return m.Blacklist
	}
	return nil
}

func (m *MetricSink) GetWhitelist() []string {
	if m != nil {
		return m.Whitelist
	}
	return nil
}

func (m *MetricSink) GetDeltalist() []string {
	if m != nil {
		return m.Deltalist
	}
	return nil
}

type Logs struct {
	RetentionMonths      uint32   `protobuf:"varint,1,opt,name=retention_months,json=retentionMonths,proto3" json:"retention_months,omitempty" db:"retention_months,omitempty" url:"retention_months,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Logs) Reset()         { *m = Logs{} }
func (m *Logs) String() string { return proto.CompactTextString(m) }
func (*Logs) ProtoMessage()    {}
func (*Logs) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{40}
}
func (m *Logs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Logs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Logs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Logs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Logs.Merge(m, src)
}
func (m *Logs) XXX_Size() int {
	return m.Size()
}
func (m *Logs) XXX_DiscardUnknown() {
	xxx_messageInfo_Logs.DiscardUnknown(m)
}

var xxx_messageInfo_Logs proto.InternalMessageInfo

func (m *Logs) GetRetentionMonths() uint32 {
	if m != nil {
		return m.RetentionMonths
	}
	return 0
}

type ProxyPorts struct {
	Ports                map[string]*ProxyPort `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty" db:"ports,omitempty" url:"ports,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ProxyPorts) Reset()         { *m = ProxyPorts{} }
func (m *ProxyPorts) String() string { return proto.CompactTextString(m) }
func (*ProxyPorts) ProtoMessage()    {}
func (*ProxyPorts) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{41}
}
func (m *ProxyPorts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyPorts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyPorts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyPorts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyPorts.Merge(m, src)
}
func (m *ProxyPorts) XXX_Size() int {
	return m.Size()
}
func (m *ProxyPorts) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyPorts.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyPorts proto.InternalMessageInfo

func (m *ProxyPorts) GetPorts() map[string]*ProxyPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

type Proxy struct {
	Routes               map[string]*ProxyPorts `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty" db:"routes,omitempty" url:"routes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"` // Deprecated: Do not use.
	Ssl                  bool                   `protobuf:"varint,3,opt,name=ssl,proto3" json:"ssl,omitempty" db:"ssl,omitempty" url:"ssl,omitempty"`
	Internal             bool                   `protobuf:"varint,4,opt,name=internal,proto3" json:"internal,omitempty" db:"internal,omitempty" url:"internal,omitempty"`
	Bootstrap            *Bootstrap             `protobuf:"bytes,5,opt,name=bootstrap,proto3" json:"bootstrap,omitempty" db:"bootstrap,omitempty" url:"bootstrap,omitempty"`
	Pods                 []*ProxyPods           `protobuf:"bytes,6,rep,name=pods,proto3" json:"pods,omitempty" db:"pods,omitempty" url:"pods,omitempty"`
	Annotations          map[string]string      `protobuf:"bytes,7,rep,name=annotations,proto3" json:"annotations,omitempty" db:"annotations,omitempty" url:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CCloudManagedLb      bool                   `protobuf:"varint,8,opt,name=c_cloud_managed_lb,json=cCloudManagedLb,proto3" json:"c_cloud_managed_lb,omitempty" db:"c_cloud_managed_lb,omitempty" url:"c_cloud_managed_lb,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Proxy) Reset()         { *m = Proxy{} }
func (m *Proxy) String() string { return proto.CompactTextString(m) }
func (*Proxy) ProtoMessage()    {}
func (*Proxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{42}
}
func (m *Proxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proxy.Merge(m, src)
}
func (m *Proxy) XXX_Size() int {
	return m.Size()
}
func (m *Proxy) XXX_DiscardUnknown() {
	xxx_messageInfo_Proxy.DiscardUnknown(m)
}

var xxx_messageInfo_Proxy proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *Proxy) GetRoutes() map[string]*ProxyPorts {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *Proxy) GetSsl() bool {
	if m != nil {
		return m.Ssl
	}
	return false
}

func (m *Proxy) GetInternal() bool {
	if m != nil {
		return m.Internal
	}
	return false
}

func (m *Proxy) GetBootstrap() *Bootstrap {
	if m != nil {
		return m.Bootstrap
	}
	return nil
}

func (m *Proxy) GetPods() []*ProxyPods {
	if m != nil {
		return m.Pods
	}
	return nil
}

func (m *Proxy) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Proxy) GetCCloudManagedLb() bool {
	if m != nil {
		return m.CCloudManagedLb
	}
	return false
}

type ProxyPods struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Dns                  string   `protobuf:"bytes,2,opt,name=dns,proto3" json:"dns,omitempty" db:"dns,omitempty" url:"dns,omitempty"`
	NodePort             uint32   `protobuf:"varint,3,opt,name=node_port,json=nodePort,proto3" json:"node_port,omitempty" db:"node_port,omitempty" url:"node_port,omitempty"`
	Port                 uint32   `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty" db:"port,omitempty" url:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyPods) Reset()         { *m = ProxyPods{} }
func (m *ProxyPods) String() string { return proto.CompactTextString(m) }
func (*ProxyPods) ProtoMessage()    {}
func (*ProxyPods) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{43}
}
func (m *ProxyPods) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyPods) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyPods.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyPods) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyPods.Merge(m, src)
}
func (m *ProxyPods) XXX_Size() int {
	return m.Size()
}
func (m *ProxyPods) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyPods.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyPods proto.InternalMessageInfo

func (m *ProxyPods) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProxyPods) GetDns() string {
	if m != nil {
		return m.Dns
	}
	return ""
}

func (m *ProxyPods) GetNodePort() uint32 {
	if m != nil {
		return m.NodePort
	}
	return 0
}

func (m *ProxyPods) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Bootstrap struct {
	Dns                   string           `protobuf:"bytes,1,opt,name=dns,proto3" json:"dns,omitempty" db:"dns,omitempty" url:"dns,omitempty"`
	Port                  uint32           `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty" db:"port,omitempty" url:"port,omitempty"`
	NodePort              uint32           `protobuf:"varint,3,opt,name=node_port,json=nodePort,proto3" json:"node_port,omitempty" db:"node_port,omitempty" url:"node_port,omitempty"`
	AdditionalPorts       []*BootstrapPort `protobuf:"bytes,4,rep,name=additional_ports,json=additionalPorts,proto3" json:"additional_ports,omitempty" db:"additional_ports,omitempty" url:"additional_ports,omitempty"`
	ExternalTrafficPolicy string           `protobuf:"bytes,5,opt,name=external_traffic_policy,json=externalTrafficPolicy,proto3" json:"external_traffic_policy,omitempty" db:"external_traffic_policy,omitempty" url:"external_traffic_policy,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}         `json:"-"`
	XXX_unrecognized      []byte           `json:"-"`
	XXX_sizecache         int32            `json:"-"`
}

func (m *Bootstrap) Reset()         { *m = Bootstrap{} }
func (m *Bootstrap) String() string { return proto.CompactTextString(m) }
func (*Bootstrap) ProtoMessage()    {}
func (*Bootstrap) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{44}
}
func (m *Bootstrap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bootstrap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bootstrap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bootstrap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bootstrap.Merge(m, src)
}
func (m *Bootstrap) XXX_Size() int {
	return m.Size()
}
func (m *Bootstrap) XXX_DiscardUnknown() {
	xxx_messageInfo_Bootstrap.DiscardUnknown(m)
}

var xxx_messageInfo_Bootstrap proto.InternalMessageInfo

func (m *Bootstrap) GetDns() string {
	if m != nil {
		return m.Dns
	}
	return ""
}

func (m *Bootstrap) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Bootstrap) GetNodePort() uint32 {
	if m != nil {
		return m.NodePort
	}
	return 0
}

func (m *Bootstrap) GetAdditionalPorts() []*BootstrapPort {
	if m != nil {
		return m.AdditionalPorts
	}
	return nil
}

func (m *Bootstrap) GetExternalTrafficPolicy() string {
	if m != nil {
		return m.ExternalTrafficPolicy
	}
	return ""
}

type BootstrapPort struct {
	InternalPortName     string   `protobuf:"bytes,1,opt,name=internal_port_name,json=internalPortName,proto3" json:"internal_port_name,omitempty" db:"internal_port_name,omitempty" url:"internal_port_name,omitempty"`
	Port                 uint32   `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty" db:"port,omitempty" url:"port,omitempty"`
	NodePort             uint32   `protobuf:"varint,3,opt,name=node_port,json=nodePort,proto3" json:"node_port,omitempty" db:"node_port,omitempty" url:"node_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BootstrapPort) Reset()         { *m = BootstrapPort{} }
func (m *BootstrapPort) String() string { return proto.CompactTextString(m) }
func (*BootstrapPort) ProtoMessage()    {}
func (*BootstrapPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{45}
}
func (m *BootstrapPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BootstrapPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BootstrapPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BootstrapPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BootstrapPort.Merge(m, src)
}
func (m *BootstrapPort) XXX_Size() int {
	return m.Size()
}
func (m *BootstrapPort) XXX_DiscardUnknown() {
	xxx_messageInfo_BootstrapPort.DiscardUnknown(m)
}

var xxx_messageInfo_BootstrapPort proto.InternalMessageInfo

func (m *BootstrapPort) GetInternalPortName() string {
	if m != nil {
		return m.InternalPortName
	}
	return ""
}

func (m *BootstrapPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *BootstrapPort) GetNodePort() uint32 {
	if m != nil {
		return m.NodePort
	}
	return 0
}

type ProxyPort struct {
	External             uint32   `protobuf:"varint,1,opt,name=external,proto3" json:"external,omitempty" db:"external,omitempty" url:"external,omitempty"`
	Internal             uint32   `protobuf:"varint,2,opt,name=internal,proto3" json:"internal,omitempty" db:"internal,omitempty" url:"internal,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyPort) Reset()         { *m = ProxyPort{} }
func (m *ProxyPort) String() string { return proto.CompactTextString(m) }
func (*ProxyPort) ProtoMessage()    {}
func (*ProxyPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{46}
}
func (m *ProxyPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyPort.Merge(m, src)
}
func (m *ProxyPort) XXX_Size() int {
	return m.Size()
}
func (m *ProxyPort) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyPort.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyPort proto.InternalMessageInfo

func (m *ProxyPort) GetExternal() uint32 {
	if m != nil {
		return m.External
	}
	return 0
}

func (m *ProxyPort) GetInternal() uint32 {
	if m != nil {
		return m.Internal
	}
	return 0
}

type PodResources struct {
	Cpu                  string     `protobuf:"bytes,1,opt,name=cpu,proto3" json:"cpu,omitempty" db:"cpu,omitempty" url:"cpu,omitempty"`
	Memory               string     `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty" db:"memory,omitempty" url:"memory,omitempty"`
	Storage              []*Storage `protobuf:"bytes,3,rep,name=storage,proto3" json:"storage,omitempty" db:"storage,omitempty" url:"storage,omitempty"`
	Requests             *Resources `protobuf:"bytes,4,opt,name=requests,proto3" json:"requests,omitempty" db:"requests,omitempty" url:"requests,omitempty"`
	Limits               *Resources `protobuf:"bytes,5,opt,name=limits,proto3" json:"limits,omitempty" db:"limits,omitempty" url:"limits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PodResources) Reset()         { *m = PodResources{} }
func (m *PodResources) String() string { return proto.CompactTextString(m) }
func (*PodResources) ProtoMessage()    {}
func (*PodResources) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{47}
}
func (m *PodResources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodResources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodResources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodResources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodResources.Merge(m, src)
}
func (m *PodResources) XXX_Size() int {
	return m.Size()
}
func (m *PodResources) XXX_DiscardUnknown() {
	xxx_messageInfo_PodResources.DiscardUnknown(m)
}

var xxx_messageInfo_PodResources proto.InternalMessageInfo

func (m *PodResources) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

func (m *PodResources) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

func (m *PodResources) GetStorage() []*Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *PodResources) GetRequests() *Resources {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *PodResources) GetLimits() *Resources {
	if m != nil {
		return m.Limits
	}
	return nil
}

type Resources struct {
	Cpu                  string   `protobuf:"bytes,1,opt,name=cpu,proto3" json:"cpu,omitempty" db:"cpu,omitempty" url:"cpu,omitempty"`
	Memory               string   `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty" db:"memory,omitempty" url:"memory,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Resources) Reset()         { *m = Resources{} }
func (m *Resources) String() string { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()    {}
func (*Resources) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{48}
}
func (m *Resources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resources.Merge(m, src)
}
func (m *Resources) XXX_Size() int {
	return m.Size()
}
func (m *Resources) XXX_DiscardUnknown() {
	xxx_messageInfo_Resources.DiscardUnknown(m)
}

var xxx_messageInfo_Resources proto.InternalMessageInfo

func (m *Resources) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

func (m *Resources) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

type Storage struct {
	Type                 StorageType `protobuf:"varint,1,opt,name=type,proto3,enum=operator.v1.StorageType" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	Capacity             string      `protobuf:"bytes,2,opt,name=capacity,proto3" json:"capacity,omitempty" db:"capacity,omitempty" url:"capacity,omitempty"`
	Name                 string      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	StorageClassName     string      `protobuf:"bytes,4,opt,name=storage_class_name,json=storageClassName,proto3" json:"storage_class_name,omitempty" db:"storage_class_name,omitempty" url:"storage_class_name,omitempty"`
	EncryptionKeyId      string      `protobuf:"bytes,5,opt,name=encryption_key_id,json=encryptionKeyId,proto3" json:"encryption_key_id,omitempty" db:"encryption_key_id,omitempty" url:"encryption_key_id,omitempty"`
	StorageClassId       string      `protobuf:"bytes,6,opt,name=storage_class_id,json=storageClassId,proto3" json:"storage_class_id,omitempty" db:"storage_class_id,omitempty" url:"storage_class_id,omitempty"`
	Iops                 uint32      `protobuf:"varint,9,opt,name=iops,proto3" json:"iops,omitempty" db:"iops,omitempty" url:"iops,omitempty"`
	Throughput           uint32      `protobuf:"varint,10,opt,name=throughput,proto3" json:"throughput,omitempty" db:"throughput,omitempty" url:"throughput,omitempty"`
	DiskEncryptionSetId  string      `protobuf:"bytes,11,opt,name=disk_encryption_set_id,json=diskEncryptionSetId,proto3" json:"disk_encryption_set_id,omitempty" db:"disk_encryption_set_id,omitempty" url:"disk_encryption_set_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Storage) Reset()         { *m = Storage{} }
func (m *Storage) String() string { return proto.CompactTextString(m) }
func (*Storage) ProtoMessage()    {}
func (*Storage) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{49}
}
func (m *Storage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Storage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Storage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Storage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Storage.Merge(m, src)
}
func (m *Storage) XXX_Size() int {
	return m.Size()
}
func (m *Storage) XXX_DiscardUnknown() {
	xxx_messageInfo_Storage.DiscardUnknown(m)
}

var xxx_messageInfo_Storage proto.InternalMessageInfo

func (m *Storage) GetType() StorageType {
	if m != nil {
		return m.Type
	}
	return StorageType_STANDARD_MAGNETIC
}

func (m *Storage) GetCapacity() string {
	if m != nil {
		return m.Capacity
	}
	return ""
}

func (m *Storage) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Storage) GetStorageClassName() string {
	if m != nil {
		return m.StorageClassName
	}
	return ""
}

func (m *Storage) GetEncryptionKeyId() string {
	if m != nil {
		return m.EncryptionKeyId
	}
	return ""
}

func (m *Storage) GetStorageClassId() string {
	if m != nil {
		return m.StorageClassId
	}
	return ""
}

func (m *Storage) GetIops() uint32 {
	if m != nil {
		return m.Iops
	}
	return 0
}

func (m *Storage) GetThroughput() uint32 {
	if m != nil {
		return m.Throughput
	}
	return 0
}

func (m *Storage) GetDiskEncryptionSetId() string {
	if m != nil {
		return m.DiskEncryptionSetId
	}
	return ""
}

type Port struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Port                 uint32   `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty" db:"port,omitempty" url:"port,omitempty"`
	Protocol             string   `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty" db:"protocol,omitempty" url:"protocol,omitempty"`
	HostPort             uint32   `protobuf:"varint,4,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty" db:"host_port,omitempty" url:"host_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Port) Reset()         { *m = Port{} }
func (m *Port) String() string { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()    {}
func (*Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{50}
}
func (m *Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Port.Merge(m, src)
}
func (m *Port) XXX_Size() int {
	return m.Size()
}
func (m *Port) XXX_DiscardUnknown() {
	xxx_messageInfo_Port.DiscardUnknown(m)
}

var xxx_messageInfo_Port proto.InternalMessageInfo

func (m *Port) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Port) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Port) GetHostPort() uint32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

type PhysicalStatefulClusterConfig struct {
	Shared               []*Config    `protobuf:"bytes,1,rep,name=shared,proto3" json:"shared,omitempty" db:"shared,omitempty" url:"shared,omitempty"`
	Pod                  []*PodConfig `protobuf:"bytes,2,rep,name=pod,proto3" json:"pod,omitempty" db:"pod,omitempty" url:"pod,omitempty"`
	Init                 []*PodConfig `protobuf:"bytes,3,rep,name=init,proto3" json:"init,omitempty" db:"init,omitempty" url:"init,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PhysicalStatefulClusterConfig) Reset()         { *m = PhysicalStatefulClusterConfig{} }
func (m *PhysicalStatefulClusterConfig) String() string { return proto.CompactTextString(m) }
func (*PhysicalStatefulClusterConfig) ProtoMessage()    {}
func (*PhysicalStatefulClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{51}
}
func (m *PhysicalStatefulClusterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterConfig.Merge(m, src)
}
func (m *PhysicalStatefulClusterConfig) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterConfig proto.InternalMessageInfo

func (m *PhysicalStatefulClusterConfig) GetShared() []*Config {
	if m != nil {
		return m.Shared
	}
	return nil
}

func (m *PhysicalStatefulClusterConfig) GetPod() []*PodConfig {
	if m != nil {
		return m.Pod
	}
	return nil
}

func (m *PhysicalStatefulClusterConfig) GetInit() []*PodConfig {
	if m != nil {
		return m.Init
	}
	return nil
}

type PodConfig struct {
	Id                   string    `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	Config               []*Config `protobuf:"bytes,2,rep,name=config,proto3" json:"config,omitempty" db:"config,omitempty" url:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PodConfig) Reset()         { *m = PodConfig{} }
func (m *PodConfig) String() string { return proto.CompactTextString(m) }
func (*PodConfig) ProtoMessage()    {}
func (*PodConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{52}
}
func (m *PodConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodConfig.Merge(m, src)
}
func (m *PodConfig) XXX_Size() int {
	return m.Size()
}
func (m *PodConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PodConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PodConfig proto.InternalMessageInfo

func (m *PodConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PodConfig) GetConfig() []*Config {
	if m != nil {
		return m.Config
	}
	return nil
}

type Config struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" db:"value,omitempty" url:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{53}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Config) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type HealthCheck struct {
	Name          string              `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Container     *Container          `protobuf:"bytes,3,opt,name=container,proto3" json:"container,omitempty" db:"container,omitempty" url:"container,omitempty"`
	Resources     *PodResources       `protobuf:"bytes,4,opt,name=resources,proto3" json:"resources,omitempty" db:"resources,omitempty" url:"resources,omitempty"`
	Configuration []*Config           `protobuf:"bytes,5,rep,name=configuration,proto3" json:"configuration,omitempty" db:"configuration,omitempty" url:"configuration,omitempty"`
	Metrics       map[string]*Metrics `protobuf:"bytes,6,rep,name=metrics,proto3" json:"metrics,omitempty" db:"metrics,omitempty" url:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Network       *Network            `protobuf:"bytes,7,opt,name=network,proto3" json:"network,omitempty" db:"network,omitempty" url:"network,omitempty"`
	// Operator Service uses the ClusterStatusProbe to calculate URL (e.g. http://kafka-healthcheck-external.pkc-8l7pl:8080/health) to pull additional psc condition in interval, then use the result for calculating PSC status summary.
	// The URL returns json form of PhysicalStatefulClusterHealthCheckClusterStatus.
	ClusterStatusProbe *ClusterStatusProbe `protobuf:"bytes,8,opt,name=cluster_status_probe,json=clusterStatusProbe,proto3" json:"cluster_status_probe,omitempty" db:"cluster_status_probe,omitempty" url:"cluster_status_probe,omitempty"`
	Affinity           *Affinity           `protobuf:"bytes,9,opt,name=affinity,proto3" json:"affinity,omitempty" db:"affinity,omitempty" url:"affinity,omitempty"`
	SkipHostPort       bool                `protobuf:"varint,10,opt,name=skip_host_port,json=skipHostPort,proto3" json:"skip_host_port,omitempty" db:"skip_host_port,omitempty" url:"skip_host_port,omitempty"`
	// Version of the Healthcheck in order to have the ability to independently roll health checks
	Version              *Version          `protobuf:"bytes,11,opt,name=version,proto3" json:"version,omitempty" db:"version,omitempty" url:"version,omitempty"`
	AdditionalPodLabels  map[string]string `protobuf:"bytes,12,rep,name=additional_pod_labels,json=additionalPodLabels,proto3" json:"additional_pod_labels,omitempty" db:"additional_pod_labels,omitempty" url:"additional_pod_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HealthCheck) Reset()         { *m = HealthCheck{} }
func (m *HealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()    {}
func (*HealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{54}
}
func (m *HealthCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheck.Merge(m, src)
}
func (m *HealthCheck) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheck.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheck proto.InternalMessageInfo

func (m *HealthCheck) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HealthCheck) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *HealthCheck) GetResources() *PodResources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *HealthCheck) GetConfiguration() []*Config {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *HealthCheck) GetMetrics() map[string]*Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *HealthCheck) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *HealthCheck) GetClusterStatusProbe() *ClusterStatusProbe {
	if m != nil {
		return m.ClusterStatusProbe
	}
	return nil
}

func (m *HealthCheck) GetAffinity() *Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *HealthCheck) GetSkipHostPort() bool {
	if m != nil {
		return m.SkipHostPort
	}
	return false
}

func (m *HealthCheck) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *HealthCheck) GetAdditionalPodLabels() map[string]string {
	if m != nil {
		return m.AdditionalPodLabels
	}
	return nil
}

type HealthCheckStatus struct {
	// Name of the HC
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	// lowest pod HC pscVersion. Used to determine if a HC is in rolling, lowest_pod_psc_version != Healthcheck.version.psc
	LowestPodPscVersion  string   `protobuf:"bytes,2,opt,name=lowest_pod_psc_version,json=lowestPodPscVersion,proto3" json:"lowest_pod_psc_version,omitempty" db:"lowest_pod_psc_version,omitempty" url:"lowest_pod_psc_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HealthCheckStatus) Reset()         { *m = HealthCheckStatus{} }
func (m *HealthCheckStatus) String() string { return proto.CompactTextString(m) }
func (*HealthCheckStatus) ProtoMessage()    {}
func (*HealthCheckStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{55}
}
func (m *HealthCheckStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheckStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheckStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckStatus.Merge(m, src)
}
func (m *HealthCheckStatus) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckStatus.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckStatus proto.InternalMessageInfo

func (m *HealthCheckStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HealthCheckStatus) GetLowestPodPscVersion() string {
	if m != nil {
		return m.LowestPodPscVersion
	}
	return ""
}

type ClusterStatusProbe struct {
	Scheme string `protobuf:"bytes,1,opt,name=scheme,proto3" json:"scheme,omitempty" db:"scheme,omitempty" url:"scheme,omitempty"`
	Port   uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty" db:"port,omitempty" url:"port,omitempty"`
	Path   string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty" db:"path,omitempty" url:"path,omitempty"`
	// Operator uses the interval to determine if pulling from URL or not when HealthCheck deployment is ready, results will override psc status summary.
	IntervalSeconds      uint32   `protobuf:"varint,4,opt,name=interval_seconds,json=intervalSeconds,proto3" json:"interval_seconds,omitempty" db:"interval_seconds,omitempty" url:"interval_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterStatusProbe) Reset()         { *m = ClusterStatusProbe{} }
func (m *ClusterStatusProbe) String() string { return proto.CompactTextString(m) }
func (*ClusterStatusProbe) ProtoMessage()    {}
func (*ClusterStatusProbe) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{56}
}
func (m *ClusterStatusProbe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterStatusProbe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterStatusProbe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterStatusProbe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterStatusProbe.Merge(m, src)
}
func (m *ClusterStatusProbe) XXX_Size() int {
	return m.Size()
}
func (m *ClusterStatusProbe) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterStatusProbe.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterStatusProbe proto.InternalMessageInfo

func (m *ClusterStatusProbe) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *ClusterStatusProbe) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *ClusterStatusProbe) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ClusterStatusProbe) GetIntervalSeconds() uint32 {
	if m != nil {
		return m.IntervalSeconds
	}
	return 0
}

type Ingress struct {
	LoadBalanced         bool     `protobuf:"varint,1,opt,name=load_balanced,json=loadBalanced,proto3" json:"load_balanced,omitempty" db:"load_balanced,omitempty" url:"load_balanced,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ingress) Reset()         { *m = Ingress{} }
func (m *Ingress) String() string { return proto.CompactTextString(m) }
func (*Ingress) ProtoMessage()    {}
func (*Ingress) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{57}
}
func (m *Ingress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ingress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ingress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ingress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ingress.Merge(m, src)
}
func (m *Ingress) XXX_Size() int {
	return m.Size()
}
func (m *Ingress) XXX_DiscardUnknown() {
	xxx_messageInfo_Ingress.DiscardUnknown(m)
}

var xxx_messageInfo_Ingress proto.InternalMessageInfo

func (m *Ingress) GetLoadBalanced() bool {
	if m != nil {
		return m.LoadBalanced
	}
	return false
}

type Cloud struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	DockerRepo           string   `protobuf:"bytes,2,opt,name=docker_repo,json=dockerRepo,proto3" json:"docker_repo,omitempty" db:"docker_repo,omitempty" url:"docker_repo,omitempty"`
	Aws                  *Aws     `protobuf:"bytes,3,opt,name=aws,proto3" json:"aws,omitempty" db:"aws,omitempty" url:"aws,omitempty"`
	Gcp                  *Gcp     `protobuf:"bytes,4,opt,name=gcp,proto3" json:"gcp,omitempty" db:"gcp,omitempty" url:"gcp,omitempty"`
	Local                *Local   `protobuf:"bytes,5,opt,name=local,proto3" json:"local,omitempty" db:"local,omitempty" url:"local,omitempty"`
	K8SClusterId         string   `protobuf:"bytes,6,opt,name=k8s_cluster_id,json=k8sClusterId,proto3" json:"k8s_cluster_id,omitempty" db:"k8s_cluster_id,omitempty" url:"k8s_cluster_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cloud) Reset()         { *m = Cloud{} }
func (m *Cloud) String() string { return proto.CompactTextString(m) }
func (*Cloud) ProtoMessage()    {}
func (*Cloud) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{58}
}
func (m *Cloud) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cloud) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cloud.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cloud) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cloud.Merge(m, src)
}
func (m *Cloud) XXX_Size() int {
	return m.Size()
}
func (m *Cloud) XXX_DiscardUnknown() {
	xxx_messageInfo_Cloud.DiscardUnknown(m)
}

var xxx_messageInfo_Cloud proto.InternalMessageInfo

func (m *Cloud) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cloud) GetDockerRepo() string {
	if m != nil {
		return m.DockerRepo
	}
	return ""
}

func (m *Cloud) GetAws() *Aws {
	if m != nil {
		return m.Aws
	}
	return nil
}

func (m *Cloud) GetGcp() *Gcp {
	if m != nil {
		return m.Gcp
	}
	return nil
}

func (m *Cloud) GetLocal() *Local {
	if m != nil {
		return m.Local
	}
	return nil
}

func (m *Cloud) GetK8SClusterId() string {
	if m != nil {
		return m.K8SClusterId
	}
	return ""
}

type Local struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Local) Reset()         { *m = Local{} }
func (m *Local) String() string { return proto.CompactTextString(m) }
func (*Local) ProtoMessage()    {}
func (*Local) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{59}
}
func (m *Local) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Local) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Local.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Local) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Local.Merge(m, src)
}
func (m *Local) XXX_Size() int {
	return m.Size()
}
func (m *Local) XXX_DiscardUnknown() {
	xxx_messageInfo_Local.DiscardUnknown(m)
}

var xxx_messageInfo_Local proto.InternalMessageInfo

type Aws struct {
	Vpc                  string            `protobuf:"bytes,1,opt,name=vpc,proto3" json:"vpc,omitempty" db:"vpc,omitempty" url:"vpc,omitempty"`
	Zones                []string          `protobuf:"bytes,2,rep,name=zones,proto3" json:"zones,omitempty" db:"zones,omitempty" url:"zones,omitempty"`
	ProxyToZone          map[string]string `protobuf:"bytes,3,rep,name=proxy_to_zone,json=proxyToZone,proto3" json:"proxy_to_zone,omitempty" db:"proxy_to_zone,omitempty" url:"proxy_to_zone,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Route53              *Route53          `protobuf:"bytes,4,opt,name=route53,proto3" json:"route53,omitempty" db:"route53,omitempty" url:"route53,omitempty"`
	Elb                  *Elb              `protobuf:"bytes,5,opt,name=elb,proto3" json:"elb,omitempty" db:"elb,omitempty" url:"elb,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Aws) Reset()         { *m = Aws{} }
func (m *Aws) String() string { return proto.CompactTextString(m) }
func (*Aws) ProtoMessage()    {}
func (*Aws) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{60}
}
func (m *Aws) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aws) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aws.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aws) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aws.Merge(m, src)
}
func (m *Aws) XXX_Size() int {
	return m.Size()
}
func (m *Aws) XXX_DiscardUnknown() {
	xxx_messageInfo_Aws.DiscardUnknown(m)
}

var xxx_messageInfo_Aws proto.InternalMessageInfo

func (m *Aws) GetVpc() string {
	if m != nil {
		return m.Vpc
	}
	return ""
}

func (m *Aws) GetZones() []string {
	if m != nil {
		return m.Zones
	}
	return nil
}

func (m *Aws) GetProxyToZone() map[string]string {
	if m != nil {
		return m.ProxyToZone
	}
	return nil
}

func (m *Aws) GetRoute53() *Route53 {
	if m != nil {
		return m.Route53
	}
	return nil
}

func (m *Aws) GetElb() *Elb {
	if m != nil {
		return m.Elb
	}
	return nil
}

type Route53 struct {
	HostedZone           string   `protobuf:"bytes,1,opt,name=hosted_zone,json=hostedZone,proto3" json:"hosted_zone,omitempty" db:"hosted_zone,omitempty" url:"hosted_zone,omitempty"`
	TtlSecs              uint32   `protobuf:"varint,2,opt,name=ttl_secs,json=ttlSecs,proto3" json:"ttl_secs,omitempty" db:"ttl_secs,omitempty" url:"ttl_secs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Route53) Reset()         { *m = Route53{} }
func (m *Route53) String() string { return proto.CompactTextString(m) }
func (*Route53) ProtoMessage()    {}
func (*Route53) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{61}
}
func (m *Route53) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route53) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route53.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route53) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route53.Merge(m, src)
}
func (m *Route53) XXX_Size() int {
	return m.Size()
}
func (m *Route53) XXX_DiscardUnknown() {
	xxx_messageInfo_Route53.DiscardUnknown(m)
}

var xxx_messageInfo_Route53 proto.InternalMessageInfo

func (m *Route53) GetHostedZone() string {
	if m != nil {
		return m.HostedZone
	}
	return ""
}

func (m *Route53) GetTtlSecs() uint32 {
	if m != nil {
		return m.TtlSecs
	}
	return 0
}

type Elb struct {
	AccessLogConfig      *ELBAccessLogConfig `protobuf:"bytes,1,opt,name=access_log_config,json=accessLogConfig,proto3" json:"access_log_config,omitempty" db:"access_log_config,omitempty" url:"access_log_config,omitempty"`
	Healthcheck          *ELBHealthcheck     `protobuf:"bytes,2,opt,name=healthcheck,proto3" json:"healthcheck,omitempty" db:"healthcheck,omitempty" url:"healthcheck,omitempty"`
	IdleTimeoutSecs      uint32              `protobuf:"varint,3,opt,name=idle_timeout_secs,json=idleTimeoutSecs,proto3" json:"idle_timeout_secs,omitempty" db:"idle_timeout_secs,omitempty" url:"idle_timeout_secs,omitempty"`
	InstanceSelector     map[string]string   `protobuf:"bytes,4,rep,name=instance_selector,json=instanceSelector,proto3" json:"instance_selector,omitempty" db:"instance_selector,omitempty" url:"instance_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SecurityGroups       *SecurityGroup      `protobuf:"bytes,5,opt,name=security_groups,json=securityGroups,proto3" json:"security_groups,omitempty" db:"security_groups,omitempty" url:"security_groups,omitempty"`
	SslCertificateId     string              `protobuf:"bytes,6,opt,name=ssl_certificate_id,json=sslCertificateId,proto3" json:"ssl_certificate_id,omitempty" db:"ssl_certificate_id,omitempty" url:"ssl_certificate_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Elb) Reset()         { *m = Elb{} }
func (m *Elb) String() string { return proto.CompactTextString(m) }
func (*Elb) ProtoMessage()    {}
func (*Elb) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{62}
}
func (m *Elb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Elb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Elb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Elb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Elb.Merge(m, src)
}
func (m *Elb) XXX_Size() int {
	return m.Size()
}
func (m *Elb) XXX_DiscardUnknown() {
	xxx_messageInfo_Elb.DiscardUnknown(m)
}

var xxx_messageInfo_Elb proto.InternalMessageInfo

func (m *Elb) GetAccessLogConfig() *ELBAccessLogConfig {
	if m != nil {
		return m.AccessLogConfig
	}
	return nil
}

func (m *Elb) GetHealthcheck() *ELBHealthcheck {
	if m != nil {
		return m.Healthcheck
	}
	return nil
}

func (m *Elb) GetIdleTimeoutSecs() uint32 {
	if m != nil {
		return m.IdleTimeoutSecs
	}
	return 0
}

func (m *Elb) GetInstanceSelector() map[string]string {
	if m != nil {
		return m.InstanceSelector
	}
	return nil
}

func (m *Elb) GetSecurityGroups() *SecurityGroup {
	if m != nil {
		return m.SecurityGroups
	}
	return nil
}

func (m *Elb) GetSslCertificateId() string {
	if m != nil {
		return m.SslCertificateId
	}
	return ""
}

type SecurityGroup struct {
	IngressName          string   `protobuf:"bytes,1,opt,name=ingress_name,json=ingressName,proto3" json:"ingress_name,omitempty" db:"ingress_name,omitempty" url:"ingress_name,omitempty"`
	IngressCustomCidr    []string `protobuf:"bytes,2,rep,name=ingress_custom_cidr,json=ingressCustomCidr,proto3" json:"ingress_custom_cidr,omitempty" db:"ingress_custom_cidr,omitempty" url:"ingress_custom_cidr,omitempty"`
	EgressName           string   `protobuf:"bytes,3,opt,name=egress_name,json=egressName,proto3" json:"egress_name,omitempty" db:"egress_name,omitempty" url:"egress_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecurityGroup) Reset()         { *m = SecurityGroup{} }
func (m *SecurityGroup) String() string { return proto.CompactTextString(m) }
func (*SecurityGroup) ProtoMessage()    {}
func (*SecurityGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{63}
}
func (m *SecurityGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityGroup.Merge(m, src)
}
func (m *SecurityGroup) XXX_Size() int {
	return m.Size()
}
func (m *SecurityGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityGroup.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityGroup proto.InternalMessageInfo

func (m *SecurityGroup) GetIngressName() string {
	if m != nil {
		return m.IngressName
	}
	return ""
}

func (m *SecurityGroup) GetIngressCustomCidr() []string {
	if m != nil {
		return m.IngressCustomCidr
	}
	return nil
}

func (m *SecurityGroup) GetEgressName() string {
	if m != nil {
		return m.EgressName
	}
	return ""
}

type ELBAccessLogConfig struct {
	//You can specify an interval of either 5 minutes or 60 minutes.
	EmitIntervalMins     uint32   `protobuf:"varint,1,opt,name=emit_interval_mins,json=emitIntervalMins,proto3" json:"emit_interval_mins,omitempty" db:"emit_interval_mins,omitempty" url:"emit_interval_mins,omitempty"`
	Enabled              bool     `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty" db:"enabled,omitempty" url:"enabled,omitempty"`
	S3BucketName         string   `protobuf:"bytes,3,opt,name=s3_bucket_name,json=s3BucketName,proto3" json:"s3_bucket_name,omitempty" db:"s3_bucket_name,omitempty" url:"s3_bucket_name,omitempty"`
	S3BucketPrefix       string   `protobuf:"bytes,4,opt,name=s3_bucket_prefix,json=s3BucketPrefix,proto3" json:"s3_bucket_prefix,omitempty" db:"s3_bucket_prefix,omitempty" url:"s3_bucket_prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ELBAccessLogConfig) Reset()         { *m = ELBAccessLogConfig{} }
func (m *ELBAccessLogConfig) String() string { return proto.CompactTextString(m) }
func (*ELBAccessLogConfig) ProtoMessage()    {}
func (*ELBAccessLogConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{64}
}
func (m *ELBAccessLogConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ELBAccessLogConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ELBAccessLogConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ELBAccessLogConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ELBAccessLogConfig.Merge(m, src)
}
func (m *ELBAccessLogConfig) XXX_Size() int {
	return m.Size()
}
func (m *ELBAccessLogConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ELBAccessLogConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ELBAccessLogConfig proto.InternalMessageInfo

func (m *ELBAccessLogConfig) GetEmitIntervalMins() uint32 {
	if m != nil {
		return m.EmitIntervalMins
	}
	return 0
}

func (m *ELBAccessLogConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *ELBAccessLogConfig) GetS3BucketName() string {
	if m != nil {
		return m.S3BucketName
	}
	return ""
}

func (m *ELBAccessLogConfig) GetS3BucketPrefix() string {
	if m != nil {
		return m.S3BucketPrefix
	}
	return ""
}

type ELBHealthcheck struct {
	HealthyThreshold     uint32   `protobuf:"varint,1,opt,name=healthy_threshold,json=healthyThreshold,proto3" json:"healthy_threshold,omitempty" db:"healthy_threshold,omitempty" url:"healthy_threshold,omitempty"`
	IntervalSecs         uint32   `protobuf:"varint,2,opt,name=interval_secs,json=intervalSecs,proto3" json:"interval_secs,omitempty" db:"interval_secs,omitempty" url:"interval_secs,omitempty"`
	Target               string   `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty" db:"target,omitempty" url:"target,omitempty"`
	TimeoutSecs          uint32   `protobuf:"varint,4,opt,name=timeout_secs,json=timeoutSecs,proto3" json:"timeout_secs,omitempty" db:"timeout_secs,omitempty" url:"timeout_secs,omitempty"`
	UnhealthyThreshold   uint32   `protobuf:"varint,5,opt,name=unhealthy_threshold,json=unhealthyThreshold,proto3" json:"unhealthy_threshold,omitempty" db:"unhealthy_threshold,omitempty" url:"unhealthy_threshold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ELBHealthcheck) Reset()         { *m = ELBHealthcheck{} }
func (m *ELBHealthcheck) String() string { return proto.CompactTextString(m) }
func (*ELBHealthcheck) ProtoMessage()    {}
func (*ELBHealthcheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{65}
}
func (m *ELBHealthcheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ELBHealthcheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ELBHealthcheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ELBHealthcheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ELBHealthcheck.Merge(m, src)
}
func (m *ELBHealthcheck) XXX_Size() int {
	return m.Size()
}
func (m *ELBHealthcheck) XXX_DiscardUnknown() {
	xxx_messageInfo_ELBHealthcheck.DiscardUnknown(m)
}

var xxx_messageInfo_ELBHealthcheck proto.InternalMessageInfo

func (m *ELBHealthcheck) GetHealthyThreshold() uint32 {
	if m != nil {
		return m.HealthyThreshold
	}
	return 0
}

func (m *ELBHealthcheck) GetIntervalSecs() uint32 {
	if m != nil {
		return m.IntervalSecs
	}
	return 0
}

func (m *ELBHealthcheck) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *ELBHealthcheck) GetTimeoutSecs() uint32 {
	if m != nil {
		return m.TimeoutSecs
	}
	return 0
}

func (m *ELBHealthcheck) GetUnhealthyThreshold() uint32 {
	if m != nil {
		return m.UnhealthyThreshold
	}
	return 0
}

type Gcp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Gcp) Reset()         { *m = Gcp{} }
func (m *Gcp) String() string { return proto.CompactTextString(m) }
func (*Gcp) ProtoMessage()    {}
func (*Gcp) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{66}
}
func (m *Gcp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gcp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Gcp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Gcp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gcp.Merge(m, src)
}
func (m *Gcp) XXX_Size() int {
	return m.Size()
}
func (m *Gcp) XXX_DiscardUnknown() {
	xxx_messageInfo_Gcp.DiscardUnknown(m)
}

var xxx_messageInfo_Gcp proto.InternalMessageInfo

type PhysicalStatefulClusterStatus struct {
	Phase       string                              `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase,omitempty" db:"phase,omitempty" url:"phase,omitempty"`
	ProxyStatus *ProxyStatus                        `protobuf:"bytes,3,opt,name=proxy_status,json=proxyStatus,proto3" json:"proxy_status,omitempty" db:"proxy_status,omitempty" url:"proxy_status,omitempty"`
	Version     *Version                            `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty" db:"version,omitempty" url:"version,omitempty"`
	Conditions  []*PhysicalStatefulClusterCondition `protobuf:"bytes,7,rep,name=conditions,proto3" json:"conditions,omitempty" db:"conditions,omitempty" url:"conditions,omitempty"`
	// last time Summary is evaluated
	LastProbeTime *v1.Time `protobuf:"bytes,8,opt,name=last_probe_time,json=lastProbeTime,proto3" json:"last_probe_time,omitempty" db:"last_probe_time,omitempty" url:"last_probe_time,omitempty"`
	// last time Summary is changed
	LastTransitionTime *v1.Time `protobuf:"bytes,9,opt,name=last_transition_time,json=lastTransitionTime,proto3" json:"last_transition_time,omitempty" db:"last_transition_time,omitempty" url:"last_transition_time,omitempty"`
	// ClusterSummary's string form
	Summary string `protobuf:"bytes,10,opt,name=summary,proto3" json:"summary,omitempty" db:"summary,omitempty" url:"summary,omitempty"`
	// lowest pod pscVersion. Used to determine if a PSC is in rolling, lowest_pod_psc_version != version.psc
	LowestPodPscVersion string `protobuf:"bytes,11,opt,name=lowest_pod_psc_version,json=lowestPodPscVersion,proto3" json:"lowest_pod_psc_version,omitempty" db:"lowest_pod_psc_version,omitempty" url:"lowest_pod_psc_version,omitempty"`
	// the diff shows changes between desired and actual pod template specs. Used to help identify the potential cause of a roll
	PodTemplateSpecDiff  string               `protobuf:"bytes,12,opt,name=pod_template_spec_diff,json=podTemplateSpecDiff,proto3" json:"pod_template_spec_diff,omitempty" db:"pod_template_spec_diff,omitempty" url:"pod_template_spec_diff,omitempty"`
	HealthCheckStatus    []*HealthCheckStatus `protobuf:"bytes,13,rep,name=health_check_status,json=healthCheckStatus,proto3" json:"health_check_status,omitempty" db:"health_check_status,omitempty" url:"health_check_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PhysicalStatefulClusterStatus) Reset()         { *m = PhysicalStatefulClusterStatus{} }
func (m *PhysicalStatefulClusterStatus) String() string { return proto.CompactTextString(m) }
func (*PhysicalStatefulClusterStatus) ProtoMessage()    {}
func (*PhysicalStatefulClusterStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{67}
}
func (m *PhysicalStatefulClusterStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterStatus.Merge(m, src)
}
func (m *PhysicalStatefulClusterStatus) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterStatus proto.InternalMessageInfo

func (m *PhysicalStatefulClusterStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *PhysicalStatefulClusterStatus) GetProxyStatus() *ProxyStatus {
	if m != nil {
		return m.ProxyStatus
	}
	return nil
}

func (m *PhysicalStatefulClusterStatus) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *PhysicalStatefulClusterStatus) GetConditions() []*PhysicalStatefulClusterCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *PhysicalStatefulClusterStatus) GetLastProbeTime() *v1.Time {
	if m != nil {
		return m.LastProbeTime
	}
	return nil
}

func (m *PhysicalStatefulClusterStatus) GetLastTransitionTime() *v1.Time {
	if m != nil {
		return m.LastTransitionTime
	}
	return nil
}

func (m *PhysicalStatefulClusterStatus) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *PhysicalStatefulClusterStatus) GetLowestPodPscVersion() string {
	if m != nil {
		return m.LowestPodPscVersion
	}
	return ""
}

func (m *PhysicalStatefulClusterStatus) GetPodTemplateSpecDiff() string {
	if m != nil {
		return m.PodTemplateSpecDiff
	}
	return ""
}

func (m *PhysicalStatefulClusterStatus) GetHealthCheckStatus() []*HealthCheckStatus {
	if m != nil {
		return m.HealthCheckStatus
	}
	return nil
}

// reference: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#typical-status-properties
type PhysicalStatefulClusterCondition struct {
	// Set by operator to calculate PhysicalStatefulClusterStatus Summary
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	// Same as defined in api.core.v1.ConditionStatus. reference https://github.com/kubernetes/api/blob/843ad2d9b9ae703c74f2f43959e6ce0b24cc3185/core/v1/types.go#L2209
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty" db:"status,omitempty" url:"status,omitempty"`
	// last time condition is evaluated
	LastProbeTime *v1.Time `protobuf:"bytes,3,opt,name=last_probe_time,json=lastProbeTime,proto3" json:"last_probe_time,omitempty" db:"last_probe_time,omitempty" url:"last_probe_time,omitempty"`
	// last time condition status is changed
	LastTransitionTime *v1.Time `protobuf:"bytes,4,opt,name=last_transition_time,json=lastTransitionTime,proto3" json:"last_transition_time,omitempty" db:"last_transition_time,omitempty" url:"last_transition_time,omitempty"`
	Message            string   `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty" db:"message,omitempty" url:"message,omitempty"`
	Reason             string   `protobuf:"bytes,6,opt,name=reason,proto3" json:"reason,omitempty" db:"reason,omitempty" url:"reason,omitempty"`
	// Optional information to add depending on condition type
	AdditionalInfo       *PhysicalStatefulClusterConditionAdditionalInfo `protobuf:"bytes,7,opt,name=additional_info,json=additionalInfo,proto3" json:"additional_info,omitempty" db:"additional_info,omitempty" url:"additional_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *PhysicalStatefulClusterCondition) Reset()         { *m = PhysicalStatefulClusterCondition{} }
func (m *PhysicalStatefulClusterCondition) String() string { return proto.CompactTextString(m) }
func (*PhysicalStatefulClusterCondition) ProtoMessage()    {}
func (*PhysicalStatefulClusterCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{68}
}
func (m *PhysicalStatefulClusterCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterCondition.Merge(m, src)
}
func (m *PhysicalStatefulClusterCondition) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterCondition.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterCondition proto.InternalMessageInfo

func (m *PhysicalStatefulClusterCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PhysicalStatefulClusterCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *PhysicalStatefulClusterCondition) GetLastProbeTime() *v1.Time {
	if m != nil {
		return m.LastProbeTime
	}
	return nil
}

func (m *PhysicalStatefulClusterCondition) GetLastTransitionTime() *v1.Time {
	if m != nil {
		return m.LastTransitionTime
	}
	return nil
}

func (m *PhysicalStatefulClusterCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *PhysicalStatefulClusterCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PhysicalStatefulClusterCondition) GetAdditionalInfo() *PhysicalStatefulClusterConditionAdditionalInfo {
	if m != nil {
		return m.AdditionalInfo
	}
	return nil
}

type PhysicalStatefulClusterConditionAdditionalInfo struct {
	// roll information set during roll operation
	RollProgress         *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress `protobuf:"bytes,1,opt,name=roll_progress,json=rollProgress,proto3" json:"roll_progress,omitempty" db:"roll_progress,omitempty" url:"roll_progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                     `json:"-"`
	XXX_unrecognized     []byte                                                       `json:"-"`
	XXX_sizecache        int32                                                        `json:"-"`
}

func (m *PhysicalStatefulClusterConditionAdditionalInfo) Reset() {
	*m = PhysicalStatefulClusterConditionAdditionalInfo{}
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo) String() string {
	return proto.CompactTextString(m)
}
func (*PhysicalStatefulClusterConditionAdditionalInfo) ProtoMessage() {}
func (*PhysicalStatefulClusterConditionAdditionalInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{69}
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterConditionAdditionalInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterConditionAdditionalInfo.Merge(m, src)
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterConditionAdditionalInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterConditionAdditionalInfo proto.InternalMessageInfo

func (m *PhysicalStatefulClusterConditionAdditionalInfo) GetRollProgress() *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress {
	if m != nil {
		return m.RollProgress
	}
	return nil
}

type PhysicalStatefulClusterConditionAdditionalInfo_RollProgress struct {
	PodsUpdated          int32    `protobuf:"varint,1,opt,name=pods_updated,json=podsUpdated,proto3" json:"pods_updated,omitempty" db:"pods_updated,omitempty" url:"pods_updated,omitempty"`
	TotalPods            int32    `protobuf:"varint,2,opt,name=total_pods,json=totalPods,proto3" json:"total_pods,omitempty" db:"total_pods,omitempty" url:"total_pods,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) Reset() {
	*m = PhysicalStatefulClusterConditionAdditionalInfo_RollProgress{}
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) String() string {
	return proto.CompactTextString(m)
}
func (*PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) ProtoMessage() {}
func (*PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{69, 0}
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterConditionAdditionalInfo_RollProgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterConditionAdditionalInfo_RollProgress.Merge(m, src)
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterConditionAdditionalInfo_RollProgress.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterConditionAdditionalInfo_RollProgress proto.InternalMessageInfo

func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) GetPodsUpdated() int32 {
	if m != nil {
		return m.PodsUpdated
	}
	return 0
}

func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) GetTotalPods() int32 {
	if m != nil {
		return m.TotalPods
	}
	return 0
}

// Return from pulling cluster_status_endpoint
type PhysicalStatefulClusterHealthCheckClusterStatus struct {
	// ClusterSummary' DOWN|UP|DEGRADED, is used to override PhysicalStatefulClusterStatus.Summary
	Summary PhysicalStatefulClusterStatus_ClusterSummary `protobuf:"varint,1,opt,name=summary,proto3,enum=operator.v1.PhysicalStatefulClusterStatus_ClusterSummary" json:"summary,omitempty" db:"summary,omitempty" url:"summary,omitempty"`
	// Append to PhysicalStatefulClusterStatus.conditions
	Conditions           []*PhysicalStatefulClusterCondition `protobuf:"bytes,2,rep,name=conditions,proto3" json:"conditions,omitempty" db:"conditions,omitempty" url:"conditions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *PhysicalStatefulClusterHealthCheckClusterStatus) Reset() {
	*m = PhysicalStatefulClusterHealthCheckClusterStatus{}
}
func (m *PhysicalStatefulClusterHealthCheckClusterStatus) String() string {
	return proto.CompactTextString(m)
}
func (*PhysicalStatefulClusterHealthCheckClusterStatus) ProtoMessage() {}
func (*PhysicalStatefulClusterHealthCheckClusterStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{70}
}
func (m *PhysicalStatefulClusterHealthCheckClusterStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalStatefulClusterHealthCheckClusterStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalStatefulClusterHealthCheckClusterStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalStatefulClusterHealthCheckClusterStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalStatefulClusterHealthCheckClusterStatus.Merge(m, src)
}
func (m *PhysicalStatefulClusterHealthCheckClusterStatus) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalStatefulClusterHealthCheckClusterStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalStatefulClusterHealthCheckClusterStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalStatefulClusterHealthCheckClusterStatus proto.InternalMessageInfo

func (m *PhysicalStatefulClusterHealthCheckClusterStatus) GetSummary() PhysicalStatefulClusterStatus_ClusterSummary {
	if m != nil {
		return m.Summary
	}
	return PhysicalStatefulClusterStatus_PROVISIONING
}

func (m *PhysicalStatefulClusterHealthCheckClusterStatus) GetConditions() []*PhysicalStatefulClusterCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

type ProxyStatus struct {
	Phase                string   `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase,omitempty" db:"phase,omitempty" url:"phase,omitempty"`
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty" db:"reason,omitempty" url:"reason,omitempty"`
	Time                 *v1.Time `protobuf:"bytes,3,opt,name=time,proto3" json:"time,omitempty" db:"time,omitempty" url:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyStatus) Reset()         { *m = ProxyStatus{} }
func (m *ProxyStatus) String() string { return proto.CompactTextString(m) }
func (*ProxyStatus) ProtoMessage()    {}
func (*ProxyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{71}
}
func (m *ProxyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyStatus.Merge(m, src)
}
func (m *ProxyStatus) XXX_Size() int {
	return m.Size()
}
func (m *ProxyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyStatus proto.InternalMessageInfo

func (m *ProxyStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *ProxyStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ProxyStatus) GetTime() *v1.Time {
	if m != nil {
		return m.Time
	}
	return nil
}

type PostRollConfig struct {
	Enabled              bool                        `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty" db:"enabled,omitempty" url:"enabled,omitempty"`
	Validations          []PostRollConfig_Validation `protobuf:"varint,2,rep,packed,name=validations,proto3,enum=operator.v1.PostRollConfig_Validation" json:"validations,omitempty" db:"validations,omitempty" url:"validations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PostRollConfig) Reset()         { *m = PostRollConfig{} }
func (m *PostRollConfig) String() string { return proto.CompactTextString(m) }
func (*PostRollConfig) ProtoMessage()    {}
func (*PostRollConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{72}
}
func (m *PostRollConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostRollConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostRollConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PostRollConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostRollConfig.Merge(m, src)
}
func (m *PostRollConfig) XXX_Size() int {
	return m.Size()
}
func (m *PostRollConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PostRollConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PostRollConfig proto.InternalMessageInfo

func (m *PostRollConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *PostRollConfig) GetValidations() []PostRollConfig_Validation {
	if m != nil {
		return m.Validations
	}
	return nil
}

type CNIProviderNetworkPolicy struct {
	EndpointSelector     *EndpointSelector `protobuf:"bytes,1,opt,name=endpoint_selector,json=endpointSelector,proto3" json:"endpoint_selector,omitempty" db:"endpoint_selector,omitempty" url:"endpoint_selector,omitempty"`
	Ingress              []*IngressRule    `protobuf:"bytes,2,rep,name=ingress,proto3" json:"ingress,omitempty" db:"ingress,omitempty" url:"ingress,omitempty"`
	Egress               []*EgressRule     `protobuf:"bytes,3,rep,name=egress,proto3" json:"egress,omitempty" db:"egress,omitempty" url:"egress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CNIProviderNetworkPolicy) Reset()         { *m = CNIProviderNetworkPolicy{} }
func (m *CNIProviderNetworkPolicy) String() string { return proto.CompactTextString(m) }
func (*CNIProviderNetworkPolicy) ProtoMessage()    {}
func (*CNIProviderNetworkPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{73}
}
func (m *CNIProviderNetworkPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNIProviderNetworkPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNIProviderNetworkPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNIProviderNetworkPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNIProviderNetworkPolicy.Merge(m, src)
}
func (m *CNIProviderNetworkPolicy) XXX_Size() int {
	return m.Size()
}
func (m *CNIProviderNetworkPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_CNIProviderNetworkPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_CNIProviderNetworkPolicy proto.InternalMessageInfo

func (m *CNIProviderNetworkPolicy) GetEndpointSelector() *EndpointSelector {
	if m != nil {
		return m.EndpointSelector
	}
	return nil
}

func (m *CNIProviderNetworkPolicy) GetIngress() []*IngressRule {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *CNIProviderNetworkPolicy) GetEgress() []*EgressRule {
	if m != nil {
		return m.Egress
	}
	return nil
}

type EndpointSelector struct {
	MatchLabels          map[string]string `protobuf:"bytes,1,rep,name=match_labels,json=matchLabels,proto3" json:"match_labels,omitempty" db:"match_labels,omitempty" url:"match_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EndpointSelector) Reset()         { *m = EndpointSelector{} }
func (m *EndpointSelector) String() string { return proto.CompactTextString(m) }
func (*EndpointSelector) ProtoMessage()    {}
func (*EndpointSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{74}
}
func (m *EndpointSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndpointSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndpointSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndpointSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndpointSelector.Merge(m, src)
}
func (m *EndpointSelector) XXX_Size() int {
	return m.Size()
}
func (m *EndpointSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_EndpointSelector.DiscardUnknown(m)
}

var xxx_messageInfo_EndpointSelector proto.InternalMessageInfo

func (m *EndpointSelector) GetMatchLabels() map[string]string {
	if m != nil {
		return m.MatchLabels
	}
	return nil
}

type IngressRule struct {
	FromEndpoints        []*EndpointSelector `protobuf:"bytes,1,rep,name=from_endpoints,json=fromEndpoints,proto3" json:"from_endpoints,omitempty" db:"from_endpoints,omitempty" url:"from_endpoints,omitempty"`
	ToPorts              []*PortRule         `protobuf:"bytes,2,rep,name=to_ports,json=toPorts,proto3" json:"to_ports,omitempty" db:"to_ports,omitempty" url:"to_ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *IngressRule) Reset()         { *m = IngressRule{} }
func (m *IngressRule) String() string { return proto.CompactTextString(m) }
func (*IngressRule) ProtoMessage()    {}
func (*IngressRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{75}
}
func (m *IngressRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressRule.Merge(m, src)
}
func (m *IngressRule) XXX_Size() int {
	return m.Size()
}
func (m *IngressRule) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressRule.DiscardUnknown(m)
}

var xxx_messageInfo_IngressRule proto.InternalMessageInfo

func (m *IngressRule) GetFromEndpoints() []*EndpointSelector {
	if m != nil {
		return m.FromEndpoints
	}
	return nil
}

func (m *IngressRule) GetToPorts() []*PortRule {
	if m != nil {
		return m.ToPorts
	}
	return nil
}

type EgressRule struct {
	ToFqdns              []*FQDNSelector `protobuf:"bytes,1,rep,name=to_fqdns,json=toFqdns,proto3" json:"to_fqdns,omitempty" db:"to_fqdns,omitempty" url:"to_fqdns,omitempty"`
	ToPorts              []*PortRule     `protobuf:"bytes,2,rep,name=to_ports,json=toPorts,proto3" json:"to_ports,omitempty" db:"to_ports,omitempty" url:"to_ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *EgressRule) Reset()         { *m = EgressRule{} }
func (m *EgressRule) String() string { return proto.CompactTextString(m) }
func (*EgressRule) ProtoMessage()    {}
func (*EgressRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{76}
}
func (m *EgressRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressRule.Merge(m, src)
}
func (m *EgressRule) XXX_Size() int {
	return m.Size()
}
func (m *EgressRule) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressRule.DiscardUnknown(m)
}

var xxx_messageInfo_EgressRule proto.InternalMessageInfo

func (m *EgressRule) GetToFqdns() []*FQDNSelector {
	if m != nil {
		return m.ToFqdns
	}
	return nil
}

func (m *EgressRule) GetToPorts() []*PortRule {
	if m != nil {
		return m.ToPorts
	}
	return nil
}

type FQDNSelector struct {
	MatchName            string   `protobuf:"bytes,1,opt,name=match_name,json=matchName,proto3" json:"match_name,omitempty" db:"match_name,omitempty" url:"match_name,omitempty"`
	MatchPattern         string   `protobuf:"bytes,2,opt,name=match_pattern,json=matchPattern,proto3" json:"match_pattern,omitempty" db:"match_pattern,omitempty" url:"match_pattern,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FQDNSelector) Reset()         { *m = FQDNSelector{} }
func (m *FQDNSelector) String() string { return proto.CompactTextString(m) }
func (*FQDNSelector) ProtoMessage()    {}
func (*FQDNSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{77}
}
func (m *FQDNSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FQDNSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FQDNSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FQDNSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FQDNSelector.Merge(m, src)
}
func (m *FQDNSelector) XXX_Size() int {
	return m.Size()
}
func (m *FQDNSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_FQDNSelector.DiscardUnknown(m)
}

var xxx_messageInfo_FQDNSelector proto.InternalMessageInfo

func (m *FQDNSelector) GetMatchName() string {
	if m != nil {
		return m.MatchName
	}
	return ""
}

func (m *FQDNSelector) GetMatchPattern() string {
	if m != nil {
		return m.MatchPattern
	}
	return ""
}

type PortRule struct {
	Ports                []*PortProtocol `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty" db:"ports,omitempty" url:"ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PortRule) Reset()         { *m = PortRule{} }
func (m *PortRule) String() string { return proto.CompactTextString(m) }
func (*PortRule) ProtoMessage()    {}
func (*PortRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{78}
}
func (m *PortRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortRule.Merge(m, src)
}
func (m *PortRule) XXX_Size() int {
	return m.Size()
}
func (m *PortRule) XXX_DiscardUnknown() {
	xxx_messageInfo_PortRule.DiscardUnknown(m)
}

var xxx_messageInfo_PortRule proto.InternalMessageInfo

func (m *PortRule) GetPorts() []*PortProtocol {
	if m != nil {
		return m.Ports
	}
	return nil
}

type PortProtocol struct {
	Port                 string   `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty" db:"port,omitempty" url:"port,omitempty"`
	Protocol             string   `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty" db:"protocol,omitempty" url:"protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PortProtocol) Reset()         { *m = PortProtocol{} }
func (m *PortProtocol) String() string { return proto.CompactTextString(m) }
func (*PortProtocol) ProtoMessage()    {}
func (*PortProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_819b88767f493988, []int{79}
}
func (m *PortProtocol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortProtocol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortProtocol.Merge(m, src)
}
func (m *PortProtocol) XXX_Size() int {
	return m.Size()
}
func (m *PortProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_PortProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_PortProtocol proto.InternalMessageInfo

func (m *PortProtocol) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *PortProtocol) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func init() {
	proto.RegisterEnum("operator.v1.UpdateStrategyType", UpdateStrategyType_name, UpdateStrategyType_value)
	proto.RegisterEnum("operator.v1.PodManagementPolicy", PodManagementPolicy_name, PodManagementPolicy_value)
	proto.RegisterEnum("operator.v1.AffinityRule", AffinityRule_name, AffinityRule_value)
	proto.RegisterEnum("operator.v1.StorageType", StorageType_name, StorageType_value)
	proto.RegisterEnum("operator.v1.ProxyAccess", ProxyAccess_name, ProxyAccess_value)
	proto.RegisterEnum("operator.v1.HTTPHandler_URIScheme", HTTPHandler_URIScheme_name, HTTPHandler_URIScheme_value)
	proto.RegisterEnum("operator.v1.PhysicalStatefulClusterStatus_ClusterSummary", PhysicalStatefulClusterStatus_ClusterSummary_name, PhysicalStatefulClusterStatus_ClusterSummary_value)
	proto.RegisterEnum("operator.v1.PostRollConfig_Validation", PostRollConfig_Validation_name, PostRollConfig_Validation_value)
	proto.RegisterType((*PhysicalStatefulClusterList)(nil), "operator.v1.PhysicalStatefulClusterList")
	proto.RegisterType((*PhysicalStatefulCluster)(nil), "operator.v1.PhysicalStatefulCluster")
	proto.RegisterType((*PhysicalStatefulClusterSpec)(nil), "operator.v1.PhysicalStatefulClusterSpec")
	proto.RegisterType((*PhysicalStatefulClusterPolicy)(nil), "operator.v1.PhysicalStatefulClusterPolicy")
	proto.RegisterType((*Version)(nil), "operator.v1.Version")
	proto.RegisterType((*PodInfoExportPolicy)(nil), "operator.v1.PodInfoExportPolicy")
	proto.RegisterType((*MountedSecret)(nil), "operator.v1.MountedSecret")
	proto.RegisterType((*KeyItem)(nil), "operator.v1.KeyItem")
	proto.RegisterType((*PhysicalStatefulClusterCommonSpec)(nil), "operator.v1.PhysicalStatefulClusterCommonSpec")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.PhysicalStatefulClusterCommonSpec.AdditionalPodLabelsEntry")
	proto.RegisterMapType((map[string]*Logs)(nil), "operator.v1.PhysicalStatefulClusterCommonSpec.LogsEntry")
	proto.RegisterMapType((map[string]*PodList)(nil), "operator.v1.PhysicalStatefulClusterCommonSpec.PlacementEntry")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.PhysicalStatefulClusterCommonSpec.PodAnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.PhysicalStatefulClusterCommonSpec.PscAnnotationsEntry")
	proto.RegisterType((*BooleanType)(nil), "operator.v1.BooleanType")
	proto.RegisterType((*NetworkPolicy)(nil), "operator.v1.NetworkPolicy")
	proto.RegisterType((*ExtraVolume)(nil), "operator.v1.ExtraVolume")
	proto.RegisterType((*ServiceAccount)(nil), "operator.v1.ServiceAccount")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.ServiceAccount.AnnotationsEntry")
	proto.RegisterType((*UpdateStrategy)(nil), "operator.v1.UpdateStrategy")
	proto.RegisterType((*PodSecurityContext)(nil), "operator.v1.PodSecurityContext")
	proto.RegisterType((*SeccompProfile)(nil), "operator.v1.SeccompProfile")
	proto.RegisterType((*SELinuxOptions)(nil), "operator.v1.SELinuxOptions")
	proto.RegisterType((*Sysctl)(nil), "operator.v1.Sysctl")
	proto.RegisterType((*ClusterDeletionHandler)(nil), "operator.v1.ClusterDeletionHandler")
	proto.RegisterType((*PodList)(nil), "operator.v1.PodList")
	proto.RegisterType((*Container)(nil), "operator.v1.Container")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.Container.EnvVarEntry")
	proto.RegisterType((*SecurityContext)(nil), "operator.v1.SecurityContext")
	proto.RegisterType((*InitContainer)(nil), "operator.v1.InitContainer")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.InitContainer.EnvVarEntry")
	proto.RegisterType((*Affinity)(nil), "operator.v1.Affinity")
	proto.RegisterType((*NodeAffinity)(nil), "operator.v1.NodeAffinity")
	proto.RegisterType((*PodLevelAffinity)(nil), "operator.v1.PodLevelAffinity")
	proto.RegisterType((*PodLevelAffinityTerm)(nil), "operator.v1.PodLevelAffinityTerm")
	proto.RegisterType((*TopologyKey)(nil), "operator.v1.TopologyKey")
	proto.RegisterType((*Weight)(nil), "operator.v1.Weight")
	proto.RegisterType((*Rack)(nil), "operator.v1.Rack")
	proto.RegisterType((*Probe)(nil), "operator.v1.Probe")
	proto.RegisterType((*ExecHandler)(nil), "operator.v1.ExecHandler")
	proto.RegisterType((*HTTPHandler)(nil), "operator.v1.HTTPHandler")
	proto.RegisterType((*TCPHandler)(nil), "operator.v1.TCPHandler")
	proto.RegisterType((*PreStopHandler)(nil), "operator.v1.PreStopHandler")
	proto.RegisterType((*Network)(nil), "operator.v1.Network")
	proto.RegisterType((*DiscoveryService)(nil), "operator.v1.DiscoveryService")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.DiscoveryService.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.DiscoveryService.LabelsEntry")
	proto.RegisterType((*ClientEndpoints)(nil), "operator.v1.ClientEndpoints")
	proto.RegisterType((*Metrics)(nil), "operator.v1.Metrics")
	proto.RegisterType((*MetricSink)(nil), "operator.v1.MetricSink")
	proto.RegisterType((*Logs)(nil), "operator.v1.Logs")
	proto.RegisterType((*ProxyPorts)(nil), "operator.v1.ProxyPorts")
	proto.RegisterMapType((map[string]*ProxyPort)(nil), "operator.v1.ProxyPorts.PortsEntry")
	proto.RegisterType((*Proxy)(nil), "operator.v1.Proxy")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.Proxy.AnnotationsEntry")
	proto.RegisterMapType((map[string]*ProxyPorts)(nil), "operator.v1.Proxy.RoutesEntry")
	proto.RegisterType((*ProxyPods)(nil), "operator.v1.ProxyPods")
	proto.RegisterType((*Bootstrap)(nil), "operator.v1.Bootstrap")
	proto.RegisterType((*BootstrapPort)(nil), "operator.v1.BootstrapPort")
	proto.RegisterType((*ProxyPort)(nil), "operator.v1.ProxyPort")
	proto.RegisterType((*PodResources)(nil), "operator.v1.PodResources")
	proto.RegisterType((*Resources)(nil), "operator.v1.Resources")
	proto.RegisterType((*Storage)(nil), "operator.v1.Storage")
	proto.RegisterType((*Port)(nil), "operator.v1.Port")
	proto.RegisterType((*PhysicalStatefulClusterConfig)(nil), "operator.v1.PhysicalStatefulClusterConfig")
	proto.RegisterType((*PodConfig)(nil), "operator.v1.PodConfig")
	proto.RegisterType((*Config)(nil), "operator.v1.Config")
	proto.RegisterType((*HealthCheck)(nil), "operator.v1.HealthCheck")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.HealthCheck.AdditionalPodLabelsEntry")
	proto.RegisterMapType((map[string]*Metrics)(nil), "operator.v1.HealthCheck.MetricsEntry")
	proto.RegisterType((*HealthCheckStatus)(nil), "operator.v1.HealthCheckStatus")
	proto.RegisterType((*ClusterStatusProbe)(nil), "operator.v1.ClusterStatusProbe")
	proto.RegisterType((*Ingress)(nil), "operator.v1.Ingress")
	proto.RegisterType((*Cloud)(nil), "operator.v1.Cloud")
	proto.RegisterType((*Local)(nil), "operator.v1.Local")
	proto.RegisterType((*Aws)(nil), "operator.v1.Aws")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.Aws.ProxyToZoneEntry")
	proto.RegisterType((*Route53)(nil), "operator.v1.Route53")
	proto.RegisterType((*Elb)(nil), "operator.v1.Elb")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.Elb.InstanceSelectorEntry")
	proto.RegisterType((*SecurityGroup)(nil), "operator.v1.SecurityGroup")
	proto.RegisterType((*ELBAccessLogConfig)(nil), "operator.v1.ELBAccessLogConfig")
	proto.RegisterType((*ELBHealthcheck)(nil), "operator.v1.ELBHealthcheck")
	proto.RegisterType((*Gcp)(nil), "operator.v1.Gcp")
	proto.RegisterType((*PhysicalStatefulClusterStatus)(nil), "operator.v1.PhysicalStatefulClusterStatus")
	proto.RegisterType((*PhysicalStatefulClusterCondition)(nil), "operator.v1.PhysicalStatefulClusterCondition")
	proto.RegisterType((*PhysicalStatefulClusterConditionAdditionalInfo)(nil), "operator.v1.PhysicalStatefulClusterConditionAdditionalInfo")
	proto.RegisterType((*PhysicalStatefulClusterConditionAdditionalInfo_RollProgress)(nil), "operator.v1.PhysicalStatefulClusterConditionAdditionalInfo.RollProgress")
	proto.RegisterType((*PhysicalStatefulClusterHealthCheckClusterStatus)(nil), "operator.v1.PhysicalStatefulClusterHealthCheckClusterStatus")
	proto.RegisterType((*ProxyStatus)(nil), "operator.v1.ProxyStatus")
	proto.RegisterType((*PostRollConfig)(nil), "operator.v1.PostRollConfig")
	proto.RegisterType((*CNIProviderNetworkPolicy)(nil), "operator.v1.CNIProviderNetworkPolicy")
	proto.RegisterType((*EndpointSelector)(nil), "operator.v1.EndpointSelector")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.EndpointSelector.MatchLabelsEntry")
	proto.RegisterType((*IngressRule)(nil), "operator.v1.IngressRule")
	proto.RegisterType((*EgressRule)(nil), "operator.v1.EgressRule")
	proto.RegisterType((*FQDNSelector)(nil), "operator.v1.FQDNSelector")
	proto.RegisterType((*PortRule)(nil), "operator.v1.PortRule")
	proto.RegisterType((*PortProtocol)(nil), "operator.v1.PortProtocol")
}

func init() {
	proto.RegisterFile("operator/v1/physicalstatefulcluster.proto", fileDescriptor_819b88767f493988)
}

var fileDescriptor_819b88767f493988 = []byte{
	// 8344 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x6d, 0x6c, 0x24, 0xc9,
	0x75, 0xd8, 0xf5, 0xcc, 0x90, 0x1c, 0xbe, 0xe1, 0xc7, 0x6c, 0xed, 0xed, 0xde, 0xdc, 0xde, 0xe9,
	0xb8, 0x6a, 0xcb, 0x97, 0xf3, 0xe6, 0xcc, 0xd5, 0x9d, 0x14, 0xe5, 0x2c, 0x2b, 0x82, 0x96, 0xcb,
	0xb9, 0x5d, 0xde, 0xf2, 0xb8, 0xe3, 0x22, 0xf7, 0x76, 0x73, 0xca, 0xa5, 0xdd, 0xec, 0x2e, 0x0e,
	0xfb, 0xd8, 0xd3, 0xdd, 0xea, 0xee, 0xe1, 0xee, 0xe8, 0x10, 0x27, 0xb1, 0xa3, 0x9c, 0x62, 0x25,
	0x48, 0x24, 0x25, 0x86, 0xa1, 0x44, 0x56, 0x22, 0x38, 0x51, 0x10, 0xdb, 0x32, 0xec, 0x40, 0x30,
	0x10, 0x04, 0x01, 0x12, 0x20, 0xb6, 0x02, 0xfb, 0x87, 0x11, 0xff, 0xc9, 0x9f, 0x10, 0xb6, 0x90,
	0x5f, 0xc9, 0x9f, 0x80, 0xf9, 0x97, 0x00, 0x46, 0x50, 0x1f, 0xfd, 0x51, 0x5d, 0xd5, 0xb3, 0x1f,
	0xe4, 0x9e, 0x89, 0x20, 0xff, 0x66, 0xde, 0x7b, 0xf5, 0x5e, 0x7d, 0xbe, 0x7a, 0xf5, 0xea, 0xd5,
	0x6b, 0xf8, 0x89, 0x30, 0x22, 0xb1, 0x9d, 0x86, 0xf1, 0xd5, 0xc3, 0xd7, 0xae, 0x46, 0xfb, 0x93,
	0xc4, 0x73, 0x6c, 0x3f, 0x49, 0xed, 0x94, 0xec, 0x8d, 0x7d, 0xc7, 0x1f, 0x27, 0x29, 0x89, 0x57,
	0xa3, 0x38, 0x4c, 0x43, 0xd4, 0xc9, 0x48, 0x57, 0x0f, 0x5f, 0xbb, 0xf4, 0xec, 0x30, 0x1c, 0x86,
	0x0c, 0x7e, 0x95, 0xfe, 0xe2, 0x24, 0x97, 0x3e, 0x7d, 0xf0, 0x46, 0xb2, 0xea, 0x85, 0x57, 0xed,
	0xc8, 0x1b, 0xd9, 0xce, 0xbe, 0x17, 0x90, 0x78, 0x72, 0x35, 0x3a, 0x18, 0x52, 0x40, 0x72, 0x75,
	0x44, 0x52, 0x9b, 0x8a, 0x19, 0x92, 0x80, 0x32, 0x22, 0xae, 0x28, 0x65, 0x16, 0xa5, 0xae, 0x3a,
	0x61, 0x4c, 0x74, 0x34, 0xaf, 0x94, 0x68, 0x02, 0x92, 0xde, 0x0f, 0xe3, 0x03, 0x2f, 0x18, 0x6a,
	0x28, 0xcd, 0x7f, 0xd7, 0x84, 0x17, 0x06, 0xa2, 0x21, 0xdb, 0xa2, 0x21, 0xd7, 0x79, 0x43, 0x36,
	0xbd, 0x24, 0x45, 0xdf, 0x30, 0x60, 0x3e, 0x9d, 0x44, 0xc4, 0xa2, 0xd5, 0xe9, 0x19, 0x97, 0x8d,
	0x57, 0x3a, 0xaf, 0xaf, 0xae, 0x72, 0xf6, 0xab, 0xe5, 0x8a, 0xaf, 0x46, 0x07, 0x43, 0x0a, 0x48,
	0x56, 0x29, 0xe5, 0xea, 0xe1, 0x6b, 0xab, 0x3b, 0x93, 0x88, 0xbc, 0x4d, 0x52, 0x7b, 0xad, 0xff,
	0x87, 0x47, 0x2b, 0xc6, 0x7f, 0x3f, 0x5a, 0x99, 0x7b, 0xd5, 0x0b, 0x7c, 0x2f, 0x20, 0xc7, 0x47,
	0x2b, 0xaf, 0xbb, 0xbb, 0x9f, 0x35, 0x73, 0xbe, 0xaf, 0x86, 0x23, 0x2f, 0x25, 0xa3, 0x28, 0x9d,
	0x98, 0x97, 0xc7, 0xb1, 0xaf, 0xc7, 0xe0, 0x76, 0x2a, 0x18, 0xa2, 0x6f, 0x1b, 0x30, 0xef, 0x7b,
	0x49, 0xca, 0x2b, 0xd5, 0x78, 0x9c, 0x4a, 0xd1, 0x46, 0xb1, 0x4a, 0x0d, 0x44, 0xa5, 0x10, 0xc5,
	0xb8, 0x76, 0x59, 0x54, 0x56, 0xbf, 0x5c, 0x84, 0x52, 0x3f, 0x1d, 0x06, 0xb7, 0x7d, 0xc1, 0x1b,
	0xbd, 0x0f, 0x33, 0x14, 0x9a, 0xf4, 0x9a, 0x97, 0x9b, 0xaf, 0x74, 0x5e, 0xff, 0xc4, 0x6a, 0x69,
	0x2e, 0xac, 0xd6, 0xf4, 0xf6, 0xda, 0xea, 0xf1, 0xd1, 0xca, 0x15, 0x2a, 0x96, 0x15, 0x55, 0x44,
	0x56, 0xa1, 0x98, 0x8b, 0x30, 0xff, 0x4d, 0x0b, 0x9e, 0xab, 0x61, 0x79, 0x36, 0x07, 0xef, 0x7b,
	0x06, 0x74, 0xc2, 0xdd, 0xf7, 0x89, 0x23, 0x0d, 0xdf, 0x27, 0x1f, 0xad, 0x5a, 0xb7, 0x59, 0x41,
	0x56, 0xb1, 0x9d, 0xa9, 0x03, 0xf8, 0x19, 0x5a, 0xc7, 0x92, 0x18, 0xa5, 0x96, 0x7a, 0x1c, 0x86,
	0x30, 0x97, 0x80, 0x52, 0x98, 0xa5, 0x6b, 0x7b, 0x4c, 0xc7, 0x91, 0xd6, 0xf1, 0xca, 0xa3, 0x8c,
	0xe3, 0x36, 0x2b, 0xb1, 0xf6, 0xc9, 0xe3, 0xa3, 0x95, 0x57, 0x69, 0x1d, 0x38, 0x07, 0x45, 0xbc,
	0x02, 0xc6, 0x42, 0x16, 0x7a, 0x1f, 0x5a, 0x49, 0x44, 0x9c, 0x5e, 0x8b, 0xc9, 0x7c, 0xe5, 0x91,
	0x64, 0x46, 0xc4, 0x59, 0x7b, 0xf5, 0xf8, 0x68, 0xe5, 0x15, 0x26, 0x31, 0x22, 0x8e, 0x2a, 0x4f,
	0x06, 0x62, 0x26, 0xc3, 0xfc, 0xf9, 0x56, 0xed, 0xea, 0xa7, 0x3c, 0xd1, 0x17, 0xa0, 0x45, 0xc7,
	0x8d, 0x4d, 0x9d, 0xf9, 0x42, 0x02, 0x85, 0x69, 0x87, 0x5d, 0x92, 0x40, 0x01, 0xe8, 0x01, 0xcc,
	0x3a, 0xe1, 0x68, 0x14, 0x06, 0xf9, 0x32, 0x7d, 0x84, 0xf6, 0x5c, 0x67, 0x25, 0x58, 0xab, 0xf2,
	0x7e, 0xe4, 0x5c, 0x14, 0xa9, 0x0a, 0x18, 0x0b, 0x79, 0xe8, 0x1e, 0xcc, 0x38, 0x7e, 0x38, 0x76,
	0xc5, 0xe0, 0x21, 0x49, 0xf0, 0x75, 0x8a, 0x29, 0x96, 0x1c, 0x23, 0x54, 0x79, 0x57, 0xa0, 0x98,
	0x33, 0xa4, 0xf3, 0x22, 0x0a, 0x7d, 0xcf, 0x99, 0x88, 0x31, 0x7a, 0xa4, 0x79, 0x31, 0x60, 0x25,
	0x8a, 0xf6, 0x70, 0x0e, 0x8a, 0x4c, 0x05, 0x8c, 0x85, 0x2c, 0x74, 0x17, 0x40, 0xec, 0x30, 0x96,
	0xe7, 0xf6, 0x66, 0xd8, 0x88, 0xbc, 0x71, 0x7c, 0xb4, 0xf2, 0x69, 0xde, 0x80, 0x0c, 0xa3, 0x69,
	0x85, 0x06, 0x85, 0xe7, 0x05, 0x78, 0xc3, 0x35, 0xbf, 0x67, 0xc0, 0xc7, 0xa6, 0x56, 0x1a, 0x7d,
	0xc5, 0x80, 0x8b, 0xe4, 0x41, 0x4a, 0xe2, 0xc0, 0xf6, 0xad, 0xc4, 0xb7, 0x2d, 0x2f, 0xb0, 0xc8,
	0xde, 0x1e, 0x71, 0x52, 0x36, 0x33, 0xda, 0x6b, 0x83, 0xe3, 0xa3, 0x95, 0x4d, 0x5a, 0x0f, 0x3d,
	0x95, 0x52, 0xa7, 0x87, 0x92, 0xe1, 0xf3, 0x19, 0xc9, 0xb6, 0x6f, 0x6f, 0x04, 0x7d, 0x86, 0x37,
	0xbf, 0x6e, 0xc0, 0xdc, 0x3b, 0x24, 0x4e, 0xbc, 0x30, 0x40, 0x37, 0x61, 0x36, 0xf2, 0xc7, 0x43,
	0x2f, 0x10, 0x93, 0xb3, 0xe8, 0x58, 0x06, 0x55, 0x3b, 0xb6, 0x0a, 0xc6, 0xa2, 0x3c, 0xfa, 0x1c,
	0x34, 0xa3, 0xc4, 0x61, 0xf3, 0x73, 0x7e, 0xed, 0xca, 0xf1, 0xd1, 0xca, 0xcb, 0x8c, 0x4d, 0xa2,
	0x2e, 0x22, 0x19, 0x86, 0x69, 0x31, 0xf3, 0xf7, 0x0c, 0x38, 0x3f, 0x08, 0xdd, 0x8d, 0x60, 0x2f,
	0xec, 0x3f, 0x88, 0xc2, 0x38, 0x15, 0x7d, 0x76, 0x0b, 0xe6, 0xf6, 0xc3, 0x24, 0xb5, 0xbc, 0x48,
	0xf4, 0xd1, 0xeb, 0xc7, 0x47, 0x2b, 0xab, 0x94, 0xb3, 0x00, 0x2b, 0xdc, 0x55, 0x38, 0x9e, 0xa5,
	0xb0, 0x8d, 0x08, 0x39, 0xb0, 0x18, 0x85, 0xae, 0x15, 0xd8, 0x23, 0x92, 0x44, 0xb6, 0x43, 0x58,
	0x65, 0xdb, 0x6b, 0x9f, 0x3f, 0x3e, 0x5a, 0xf9, 0x2c, 0x9f, 0x4c, 0x25, 0xa4, 0x66, 0x4e, 0xe9,
	0xb1, 0x78, 0x21, 0x0a, 0xdd, 0xad, 0x0c, 0x61, 0xfe, 0x91, 0x01, 0x8b, 0x6f, 0x87, 0xe3, 0x20,
	0x25, 0xee, 0x36, 0x71, 0x62, 0x92, 0xd2, 0x29, 0x97, 0xb0, 0x5f, 0x56, 0x4c, 0xf6, 0x44, 0x3f,
	0xe7, 0x53, 0xae, 0xc0, 0xa8, 0xca, 0x46, 0x87, 0xc2, 0xf3, 0x1c, 0x8c, 0xc9, 0x1e, 0xf2, 0x60,
	0xfe, 0x80, 0x4c, 0x2c, 0xbe, 0x49, 0x36, 0xd8, 0x26, 0xf9, 0xac, 0xb4, 0x88, 0x6e, 0x91, 0xc9,
	0x46, 0x4a, 0x46, 0x6b, 0x9f, 0xc9, 0xb6, 0x9b, 0x9c, 0x5c, 0x11, 0xa6, 0xc3, 0xe0, 0xf6, 0x01,
	0x67, 0x90, 0x98, 0x7f, 0xc7, 0x80, 0x39, 0xc1, 0x8d, 0x8e, 0xf4, 0x01, 0x99, 0x88, 0x86, 0xe4,
	0x23, 0x7d, 0x40, 0x26, 0x3a, 0xa6, 0xd2, 0x48, 0x1f, 0x90, 0x09, 0x55, 0x86, 0x91, 0x9d, 0xee,
	0x8b, 0x89, 0x92, 0x2b, 0x43, 0x0a, 0x53, 0xbb, 0x5c, 0x06, 0x62, 0x56, 0xd2, 0xfc, 0x6f, 0x2f,
	0xc3, 0xc7, 0x1f, 0xaa, 0xf2, 0x90, 0x0f, 0xf3, 0x4e, 0x18, 0xa4, 0x36, 0xdd, 0x02, 0xc5, 0xa6,
	0x7d, 0x51, 0x56, 0x5e, 0x19, 0xb6, 0xe8, 0x9e, 0xbc, 0x80, 0x46, 0x41, 0xaa, 0x18, 0x5c, 0x08,
	0x40, 0x03, 0x68, 0xc7, 0x24, 0xf2, 0x3d, 0xc7, 0x4e, 0x58, 0xcb, 0x16, 0xd7, 0x3e, 0x7d, 0x7c,
	0xb4, 0xf2, 0x49, 0xca, 0x34, 0x83, 0x2b, 0x3c, 0x35, 0x08, 0x9c, 0x73, 0x41, 0x21, 0xcc, 0xc7,
	0x24, 0x09, 0xc7, 0xb1, 0x43, 0xb2, 0x9d, 0xf3, 0x79, 0x59, 0x43, 0x86, 0x2e, 0xce, 0x08, 0x8a,
	0x26, 0xe4, 0x65, 0x34, 0xe2, 0x54, 0x0c, 0x2e, 0x64, 0xa0, 0x6f, 0x1a, 0x30, 0x1f, 0xf9, 0xb6,
	0x43, 0x46, 0x24, 0x48, 0x7b, 0x2d, 0x36, 0x9d, 0xfe, 0xd2, 0xe3, 0xed, 0x33, 0xab, 0x83, 0xac,
	0x7c, 0x3f, 0x48, 0xe3, 0x49, 0x51, 0xab, 0x9c, 0xaf, 0x46, 0xa1, 0xa8, 0x18, 0x5c, 0xd4, 0x03,
	0xed, 0xc2, 0x9c, 0x30, 0xbd, 0x99, 0xb2, 0xae, 0xce, 0xf0, 0x2d, 0x8e, 0x2b, 0xd4, 0x82, 0x20,
	0x56, 0xe4, 0xa8, 0x70, 0x9c, 0x31, 0xa6, 0x3b, 0x91, 0x13, 0x06, 0x7b, 0xde, 0xb0, 0x37, 0xfb,
	0xe8, 0x3b, 0xd1, 0x75, 0x56, 0xa2, 0xbc, 0xb3, 0xd2, 0xff, 0xba, 0x89, 0x23, 0x83, 0xb1, 0x90,
	0x85, 0xbe, 0x0c, 0x2d, 0x3f, 0x1c, 0x26, 0xbd, 0x79, 0xd6, 0xd3, 0x6f, 0x3c, 0x66, 0x4f, 0x6f,
	0x86, 0xc3, 0x84, 0x77, 0x72, 0xbe, 0x84, 0x28, 0x37, 0xd5, 0xc6, 0x96, 0x81, 0x98, 0xc9, 0x44,
	0x7f, 0x0d, 0x16, 0xf7, 0x89, 0xed, 0xa7, 0xfb, 0x96, 0xb3, 0x4f, 0x9c, 0x83, 0xa4, 0x07, 0xac,
	0x12, 0x3d, 0xa9, 0x12, 0x37, 0x19, 0xc5, 0x75, 0x4a, 0x50, 0xe8, 0x48, 0xa9, 0x98, 0xaa, 0x7c,
	0x6b, 0xb0, 0x78, 0x61, 0xbf, 0x60, 0x96, 0xd0, 0x41, 0xf5, 0x82, 0x61, 0x4c, 0x92, 0xa4, 0xd7,
	0xd1, 0x0c, 0xea, 0x06, 0xc7, 0x15, 0x83, 0x2a, 0x88, 0x55, 0x6b, 0x5e, 0x81, 0xe3, 0x8c, 0x31,
	0x95, 0x31, 0x22, 0x69, 0xec, 0x39, 0x49, 0x6f, 0x41, 0x23, 0xe3, 0x6d, 0x8e, 0x2b, 0x64, 0x08,
	0x62, 0x45, 0x86, 0x0a, 0xc7, 0x19, 0x63, 0x2a, 0xe3, 0x90, 0x6f, 0xa4, 0xbd, 0x45, 0x8d, 0x0c,
	0xb1, 0xc9, 0x16, 0x32, 0x04, 0xb1, 0x22, 0x43, 0x85, 0xe3, 0x8c, 0x31, 0x0a, 0xa1, 0x3b, 0xf2,
	0x02, 0x6f, 0x34, 0x1e, 0x59, 0xb9, 0x86, 0x59, 0x62, 0x1a, 0x66, 0xfd, 0xf8, 0x68, 0xe5, 0x0b,
	0xac, 0xea, 0x15, 0xbc, 0xda, 0x86, 0x7a, 0x02, 0xbc, 0x2c, 0x90, 0x38, 0x53, 0x3c, 0xff, 0xda,
	0x80, 0x5e, 0x66, 0xed, 0xb8, 0xc4, 0x27, 0xa9, 0x17, 0x06, 0xd6, 0xbe, 0x1d, 0xb8, 0x3e, 0x89,
	0x7b, 0xcb, 0xac, 0x99, 0x3f, 0x56, 0xb1, 0x02, 0x19, 0xf1, 0xba, 0xa0, 0xbd, 0xc9, 0x49, 0xd7,
	0x76, 0x8e, 0x8f, 0x56, 0x06, 0x65, 0xab, 0xaa, 0xca, 0xac, 0xd6, 0xc6, 0x9a, 0x42, 0x88, 0x2f,
	0x3a, 0x5a, 0x69, 0xe8, 0x3b, 0x06, 0x3c, 0x4b, 0x77, 0xe8, 0x84, 0x38, 0xe3, 0xd8, 0x4b, 0x27,
	0x16, 0xd5, 0xcd, 0xe4, 0x41, 0xda, 0xeb, 0xb2, 0x1a, 0xaf, 0x54, 0x55, 0xe7, 0xb6, 0xa0, 0xbb,
	0xce, 0xc9, 0xd6, 0x36, 0x8f, 0x8f, 0x56, 0x6e, 0x66, 0x46, 0x40, 0x95, 0x89, 0xd6, 0x16, 0x98,
	0x42, 0x84, 0x51, 0xa4, 0x48, 0x40, 0xbf, 0x69, 0xc0, 0x32, 0x2d, 0x67, 0x07, 0x41, 0x98, 0xda,
	0xb4, 0xee, 0x49, 0xef, 0x1c, 0x5b, 0x76, 0x6b, 0x8f, 0xab, 0x65, 0x43, 0xf7, 0x5a, 0xc1, 0x84,
	0x6b, 0x81, 0xb5, 0xe3, 0xa3, 0x95, 0xcf, 0x67, 0xf5, 0x2f, 0x89, 0xd0, 0x56, 0x5d, 0x8f, 0xc7,
	0x4b, 0x91, 0xc4, 0x18, 0x7d, 0x68, 0xc0, 0xb2, 0x17, 0x78, 0xa9, 0x95, 0xef, 0x73, 0x49, 0x0f,
	0xb1, 0x1a, 0x5f, 0xaa, 0xac, 0x57, 0x2f, 0x2d, 0x76, 0xd3, 0xbc, 0x26, 0x95, 0xa2, 0x9a, 0xd5,
	0x5b, 0x87, 0xc7, 0x4b, 0x5e, 0x99, 0x65, 0x82, 0x7e, 0xd5, 0x80, 0x0b, 0xb4, 0xe2, 0x23, 0x3b,
	0xb0, 0x87, 0x6c, 0x63, 0xb0, 0xc4, 0xd9, 0xe1, 0xfc, 0x65, 0xe3, 0x95, 0xa5, 0xd7, 0x2f, 0x57,
	0x87, 0xf7, 0xed, 0x9c, 0x50, 0x9c, 0x18, 0xb6, 0x8e, 0x8f, 0x56, 0xde, 0xca, 0xfa, 0x47, 0x61,
	0xa3, 0xed, 0xa5, 0x69, 0x54, 0xf8, 0x7c, 0xa4, 0x0a, 0x41, 0x43, 0x68, 0xdb, 0x7b, 0x7b, 0xb4,
	0xee, 0x93, 0xde, 0xb3, 0x6c, 0xde, 0x5d, 0x90, 0x2a, 0x76, 0x4d, 0x20, 0x0b, 0xe3, 0x20, 0x23,
	0x57, 0x2a, 0xa0, 0x41, 0xe0, 0x9c, 0x39, 0xda, 0x83, 0xa5, 0xe4, 0xc0, 0x8b, 0x2c, 0x66, 0xec,
	0x52, 0x73, 0xb9, 0x77, 0x81, 0x99, 0xb2, 0x5f, 0x38, 0x3e, 0x5a, 0xf9, 0x1c, 0x33, 0x2b, 0x25,
	0xac, 0x6a, 0x5a, 0xd6, 0xa1, 0xf1, 0x02, 0x45, 0xdd, 0x0c, 0x93, 0x74, 0x10, 0xc6, 0x29, 0xfa,
	0xaa, 0x01, 0xcb, 0xe3, 0xc8, 0xb5, 0x53, 0x62, 0x25, 0x69, 0x6c, 0xa7, 0x64, 0x38, 0xe9, 0x5d,
	0x64, 0x0d, 0x7b, 0x41, 0x6a, 0xd8, 0x1d, 0x46, 0xb3, 0x2d, 0x48, 0x8a, 0x29, 0x50, 0x29, 0xab,
	0xd4, 0xa3, 0x1e, 0x8f, 0x97, 0xc6, 0x12, 0x4f, 0xbe, 0x7c, 0x12, 0x47, 0x5a, 0x3e, 0xcf, 0x3d,
	0xd9, 0xf2, 0x49, 0x9c, 0x29, 0xcb, 0x47, 0x16, 0xa1, 0x3b, 0xbc, 0xd4, 0x2f, 0x1f, 0x89, 0x31,
	0xeb, 0xbc, 0x84, 0xc4, 0x87, 0x9e, 0x43, 0x2c, 0xdb, 0x71, 0xe8, 0x99, 0xa0, 0xd7, 0xd3, 0x74,
	0xde, 0x36, 0xa7, 0xb9, 0xc6, 0x49, 0x8a, 0xaa, 0x54, 0xca, 0x6a, 0xce, 0x07, 0x75, 0x78, 0xbc,
	0x94, 0x48, 0x3c, 0xe9, 0x7e, 0x4f, 0x1e, 0xa4, 0xb1, 0x6d, 0x1d, 0x86, 0xfe, 0x78, 0x44, 0x92,
	0xde, 0xf3, 0x9a, 0xfd, 0xbe, 0x4f, 0x29, 0xde, 0x61, 0x04, 0xc5, 0x7e, 0x2f, 0x15, 0xd3, 0x9d,
	0x40, 0xb5, 0x58, 0xbc, 0x40, 0x0a, 0x66, 0x09, 0xfa, 0x9a, 0x50, 0x7d, 0x69, 0xe8, 0x53, 0x71,
	0x6c, 0xec, 0x5e, 0x64, 0x35, 0x78, 0xa9, 0xe4, 0xb0, 0x5a, 0x75, 0xc2, 0x98, 0x30, 0xaf, 0x59,
	0x4e, 0x26, 0xab, 0xb5, 0x52, 0x71, 0xed, 0x82, 0xd5, 0xe3, 0x99, 0x5a, 0x2b, 0x58, 0x26, 0xe8,
	0x17, 0x0c, 0x58, 0x12, 0xa6, 0x5f, 0xa6, 0x45, 0x3e, 0xc6, 0x86, 0xe5, 0x92, 0xce, 0xb4, 0x14,
	0xfa, 0x23, 0x5f, 0x59, 0x72, 0xc9, 0x3a, 0x3b, 0x53, 0xa3, 0x31, 0x16, 0x83, 0x32, 0x43, 0xf4,
	0xfb, 0x06, 0x5c, 0xb0, 0x5d, 0xd7, 0xa3, 0x75, 0xb2, 0x7d, 0x8b, 0xd6, 0xdf, 0xb7, 0x77, 0x89,
	0x9f, 0xf4, 0x5e, 0x62, 0x3d, 0x73, 0xe3, 0x31, 0x67, 0xf5, 0xb5, 0x9c, 0xd7, 0x20, 0x74, 0x37,
	0x19, 0x27, 0x3e, 0xb5, 0x73, 0xcd, 0xa7, 0x95, 0xa6, 0x2a, 0x9e, 0x87, 0x50, 0xe1, 0xf3, 0xb6,
	0x2a, 0x09, 0x1d, 0x02, 0x8a, 0xc7, 0x41, 0xea, 0x8d, 0x88, 0xe5, 0xf8, 0x76, 0x92, 0xb0, 0x93,
	0x72, 0x6f, 0x85, 0x9d, 0xf1, 0x6e, 0x1e, 0x1f, 0xad, 0xac, 0xb3, 0xb3, 0x89, 0x42, 0xa1, 0x1e,
	0x52, 0xa6, 0x91, 0xe0, 0xae, 0x40, 0x5f, 0xa7, 0x58, 0x7a, 0xe4, 0x46, 0xbf, 0x6c, 0xc0, 0x0b,
	0x24, 0xb0, 0x77, 0x7d, 0x62, 0xed, 0xc6, 0xe1, 0x01, 0x89, 0xad, 0xd8, 0x76, 0x0e, 0xac, 0x2f,
	0x87, 0x01, 0xb1, 0x3c, 0x37, 0xe9, 0x5d, 0x66, 0x6a, 0xf1, 0xdd, 0xe3, 0xa3, 0x95, 0x77, 0xd8,
	0x6c, 0xae, 0x27, 0x55, 0xe7, 0xf6, 0x23, 0xd1, 0xe2, 0xe7, 0x38, 0xdd, 0x1a, 0x23, 0xc3, 0xb6,
	0x73, 0xf0, 0x6e, 0x18, 0x90, 0x0d, 0x37, 0x41, 0xdf, 0x36, 0x00, 0x39, 0x81, 0x67, 0x55, 0xa6,
	0xda, 0xc7, 0xd9, 0x54, 0xfb, 0x71, 0xd9, 0x82, 0xda, 0xda, 0x18, 0xc4, 0xe1, 0xa1, 0xe7, 0x92,
	0x58, 0x9e, 0x75, 0x79, 0xd7, 0xa9, 0x8c, 0x54, 0xeb, 0x69, 0x1a, 0x09, 0xee, 0x3a, 0x81, 0x27,
	0xf1, 0x46, 0xbf, 0x6b, 0xc0, 0x65, 0x7b, 0x9c, 0x86, 0xd6, 0x88, 0xaa, 0x08, 0xab, 0xa2, 0x4d,
	0xac, 0x34, 0x3c, 0x20, 0x41, 0xcf, 0x64, 0xb5, 0x95, 0xf5, 0xc4, 0x5a, 0x18, 0xfa, 0xc4, 0x0e,
	0x76, 0x26, 0x11, 0x59, 0x73, 0x8f, 0x8f, 0x56, 0x7e, 0x96, 0x4d, 0xae, 0x87, 0x70, 0x52, 0xe7,
	0xd9, 0xa3, 0x17, 0xc0, 0x2f, 0x52, 0x62, 0xe6, 0x54, 0x91, 0x75, 0xe5, 0x0e, 0x25, 0xbc, 0xf4,
	0x7d, 0x03, 0x96, 0xe4, 0x83, 0xe7, 0x09, 0x5d, 0x14, 0xef, 0xc2, 0xcc, 0xa1, 0xed, 0x8f, 0x89,
	0x70, 0xb6, 0x3e, 0x5b, 0x35, 0x2e, 0x36, 0xbd, 0x24, 0x2d, 0xbc, 0x9e, 0x8c, 0x54, 0x35, 0xe9,
	0x2b, 0x50, 0xcc, 0x59, 0x7e, 0xb6, 0xf1, 0x86, 0x71, 0xe9, 0x5f, 0x18, 0x30, 0x9f, 0x9f, 0xdf,
	0x4e, 0x58, 0xd7, 0xbb, 0x72, 0x5d, 0xcf, 0x49, 0x75, 0xa5, 0x42, 0x4e, 0x52, 0xd1, 0x6f, 0x73,
	0xaf, 0x5c, 0x75, 0xb7, 0x3c, 0x61, 0x95, 0xd7, 0xcb, 0x55, 0x9e, 0x3f, 0x71, 0xfd, 0xd4, 0xdd,
	0xfc, 0xcc, 0xd4, 0xef, 0xbb, 0x06, 0xf4, 0xea, 0xf4, 0xf2, 0x59, 0xa9, 0xe4, 0x5b, 0xad, 0xf6,
	0x5c, 0xb7, 0xfd, 0x56, 0xab, 0xdd, 0xee, 0xce, 0xbf, 0xd5, 0x6a, 0x5f, 0xea, 0xbe, 0xf0, 0x56,
	0xab, 0xfd, 0x42, 0xf7, 0x45, 0x73, 0x1b, 0x3a, 0xa5, 0x95, 0x5e, 0x08, 0xe4, 0x7e, 0xd8, 0x27,
	0x13, 0x68, 0xfe, 0xcf, 0x06, 0x2c, 0xca, 0x6a, 0xe8, 0x6f, 0x18, 0x85, 0x33, 0xc0, 0x60, 0x3b,
	0xdf, 0xeb, 0x65, 0x9b, 0xa0, 0xb8, 0x77, 0x55, 0xf6, 0x64, 0xe1, 0x26, 0xc0, 0x63, 0x9f, 0x9c,
	0xcc, 0x55, 0xf0, 0x01, 0xcc, 0x12, 0x5e, 0x01, 0xee, 0x44, 0x7d, 0xed, 0x11, 0x2b, 0xd0, 0x2f,
	0xe4, 0xe7, 0x6e, 0x20, 0xa2, 0x17, 0xaf, 0x80, 0xb1, 0x10, 0x89, 0x2c, 0x58, 0xe0, 0xda, 0xda,
	0x4a, 0x27, 0x11, 0xe1, 0x97, 0x9d, 0xf3, 0x6b, 0x9f, 0x3b, 0x3e, 0x5a, 0x79, 0xa3, 0xb8, 0xe0,
	0xe0, 0xb8, 0x9a, 0x6b, 0x0e, 0x05, 0x89, 0x3b, 0x1c, 0x41, 0xc7, 0x2d, 0x31, 0xff, 0x64, 0x06,
	0x3a, 0x25, 0xd3, 0x0e, 0xdd, 0x81, 0x79, 0x6e, 0xf9, 0xdb, 0xe9, 0x7e, 0xc9, 0x1b, 0xfd, 0x7a,
	0xee, 0x54, 0xd7, 0xba, 0x62, 0x75, 0x98, 0x9e, 0x81, 0xdb, 0x14, 0x3e, 0xb0, 0xd3, 0x7d, 0x74,
	0x17, 0x80, 0x6b, 0xf3, 0x92, 0x77, 0x37, 0xf7, 0x72, 0x17, 0x18, 0xd5, 0x37, 0xa1, 0x43, 0xe1,
	0x79, 0x06, 0x66, 0x8c, 0xef, 0x01, 0xd8, 0x69, 0x6a, 0x3b, 0xfb, 0x74, 0x9b, 0x65, 0x9e, 0xd0,
	0x76, 0xc1, 0xb8, 0xc0, 0xa8, 0x1b, 0x8c, 0x0e, 0x85, 0x4b, 0xbc, 0xd0, 0xd7, 0x0d, 0x78, 0x9e,
	0xff, 0xb5, 0xd2, 0xd0, 0xaa, 0x9e, 0x74, 0x5b, 0x6c, 0x20, 0xde, 0x39, 0x3e, 0x5a, 0xc1, 0x85,
	0x24, 0x0d, 0x61, 0x8d, 0xe0, 0xe9, 0x94, 0xf8, 0x22, 0xa7, 0xda, 0x09, 0x37, 0xe4, 0x93, 0xee,
	0x2f, 0x1b, 0xd0, 0x65, 0x24, 0x96, 0xeb, 0xc5, 0xc2, 0xb2, 0x16, 0x9e, 0xcf, 0x57, 0x74, 0xb6,
	0x72, 0x9f, 0xd2, 0xae, 0x7b, 0x31, 0x1f, 0xdc, 0x6d, 0xe6, 0xcb, 0x2d, 0x3c, 0x43, 0x55, 0x4e,
	0xea, 0xbc, 0xac, 0x27, 0xc0, 0x4b, 0x44, 0xe2, 0xcd, 0xaa, 0x96, 0x4f, 0x83, 0xac, 0x6a, 0xb3,
	0xf5, 0x55, 0xbb, 0x29, 0xa6, 0x86, 0xbe, 0x6a, 0x55, 0x4e, 0xf5, 0x33, 0x4e, 0x57, 0xb5, 0x7d,
	0x89, 0xb7, 0xf9, 0x1f, 0x9a, 0xb0, 0x24, 0x9b, 0x06, 0xe8, 0x0b, 0xd0, 0x62, 0x36, 0x68, 0xe5,
	0xd2, 0x55, 0x6b, 0x75, 0x56, 0xed, 0x4c, 0x56, 0x12, 0xfd, 0xa2, 0x01, 0x9d, 0xf2, 0x69, 0x93,
	0x2b, 0x87, 0x57, 0xa7, 0x9c, 0xdd, 0x56, 0x95, 0x73, 0xe5, 0x67, 0xb3, 0x4b, 0xf4, 0x69, 0x67,
	0xca, 0x9a, 0xf3, 0x64, 0x59, 0x38, 0x55, 0xbf, 0x76, 0x14, 0xf9, 0x13, 0xb1, 0x00, 0x72, 0xf5,
	0xcb, 0x80, 0x2a, 0xc7, 0x0a, 0x14, 0xf3, 0xc2, 0x97, 0xbe, 0x65, 0x40, 0xf7, 0xac, 0xee, 0x96,
	0xe6, 0x87, 0x4d, 0x58, 0x92, 0x1d, 0x09, 0xc8, 0x2e, 0xdd, 0x9c, 0x2f, 0x55, 0x9c, 0x78, 0x32,
	0x29, 0xb3, 0x46, 0x9f, 0xe4, 0x6a, 0xfd, 0x2b, 0x06, 0x5c, 0xcc, 0xfc, 0xa2, 0x74, 0xcd, 0x06,
	0x61, 0x6a, 0x71, 0xd7, 0x83, 0xb8, 0xc8, 0xc9, 0x6f, 0x65, 0xf5, 0x54, 0xb5, 0xd7, 0x3a, 0xb5,
	0x64, 0xf8, 0x7c, 0x46, 0xb2, 0x13, 0x6e, 0x85, 0x29, 0x6f, 0x07, 0xed, 0xc7, 0xc8, 0x1e, 0x27,
	0xa4, 0x3a, 0xc0, 0x0c, 0xa8, 0xb9, 0x19, 0x93, 0xa1, 0x98, 0x17, 0x66, 0xd3, 0x64, 0x37, 0x8c,
	0x53, 0x76, 0xa7, 0x5e, 0x9e, 0x26, 0xbb, 0x3a, 0x37, 0x50, 0x15, 0x8a, 0x79, 0x61, 0xf3, 0x4f,
	0x67, 0x01, 0xa9, 0x3e, 0x52, 0x74, 0x1b, 0xda, 0x7b, 0x89, 0x35, 0x8c, 0xc3, 0x31, 0xbf, 0x8d,
	0x6d, 0x16, 0x7e, 0xac, 0x0c, 0xae, 0x88, 0xd0, 0x20, 0xf0, 0xdc, 0x5e, 0x72, 0x83, 0xc2, 0xd0,
	0x5f, 0x85, 0x85, 0x78, 0x1c, 0x58, 0x76, 0xc6, 0xb4, 0xc1, 0x98, 0xe6, 0x7b, 0x5f, 0x19, 0xa7,
	0x3b, 0x29, 0xea, 0x90, 0x18, 0xe2, 0x71, 0x70, 0x4d, 0xf0, 0xf7, 0x60, 0x59, 0x90, 0x05, 0x61,
	0x60, 0xc5, 0x61, 0x98, 0x8a, 0xde, 0xcd, 0xdd, 0x0a, 0x15, 0x74, 0x9d, 0x14, 0x0d, 0x1e, 0x2f,
	0x30, 0x41, 0x5b, 0x61, 0x80, 0xc3, 0x30, 0x45, 0xef, 0x42, 0x47, 0xd0, 0x8e, 0x13, 0x12, 0xb3,
	0xee, 0x6f, 0x16, 0xab, 0xbf, 0x84, 0xaa, 0x13, 0x51, 0xc1, 0xe1, 0x79, 0xc6, 0xfe, 0x4e, 0x42,
	0x62, 0xe1, 0x48, 0xf2, 0xbd, 0x60, 0xfc, 0xc0, 0x0a, 0x23, 0xae, 0x8c, 0x66, 0x74, 0x8e, 0xa4,
	0xfe, 0x26, 0xa5, 0xb9, 0xcd, 0x49, 0xca, 0x8e, 0x24, 0xa9, 0xac, 0xc6, 0x91, 0x54, 0x87, 0xc7,
	0x4b, 0x02, 0x27, 0x78, 0xa2, 0x0f, 0xe0, 0x7c, 0x32, 0x8e, 0x22, 0x9f, 0x9d, 0xb5, 0x6c, 0x9f,
	0x77, 0x7f, 0xd2, 0x9b, 0xbd, 0xdc, 0x7c, 0xa5, 0xb9, 0xf6, 0xd6, 0xf1, 0xd1, 0xca, 0x9b, 0x4c,
	0xa0, 0x4a, 0xa2, 0x0a, 0x9d, 0x4a, 0x83, 0x51, 0x19, 0xcf, 0x46, 0x33, 0x41, 0xef, 0xc1, 0x6c,
	0x32, 0x49, 0x52, 0x3f, 0xe9, 0xcd, 0x31, 0x55, 0x7c, 0x5e, 0x6e, 0xfd, 0x24, 0x71, 0x52, 0xbf,
	0x14, 0x32, 0xc4, 0x48, 0x55, 0xb9, 0x55, 0x30, 0x16, 0x4c, 0x45, 0x37, 0x3b, 0x4e, 0x38, 0x8a,
	0xac, 0x28, 0x0e, 0xf7, 0x3c, 0x9f, 0xf4, 0xda, 0x5a, 0x7f, 0x1d, 0xa3, 0x19, 0x70, 0x92, 0x72,
	0x37, 0x4b, 0x65, 0x75, 0xf7, 0xf9, 0x35, 0x78, 0xda, 0xcd, 0x65, 0x9e, 0xe6, 0xef, 0x19, 0x74,
	0x3f, 0x2b, 0x83, 0x4e, 0x21, 0x88, 0x28, 0x81, 0x73, 0x7e, 0xe8, 0xd8, 0x3e, 0xdf, 0x58, 0x45,
	0x03, 0xb9, 0xd6, 0x7e, 0xf3, 0xf8, 0x68, 0x65, 0x8d, 0xdf, 0x21, 0x56, 0x08, 0x34, 0x17, 0x8a,
	0xf5, 0x14, 0xb8, 0x9b, 0x63, 0xb3, 0x96, 0xfc, 0x93, 0x06, 0x2c, 0xc9, 0xf3, 0x92, 0xb6, 0x84,
	0xad, 0x91, 0x4a, 0x4b, 0xb4, 0x8b, 0xa3, 0xba, 0x2a, 0x58, 0x49, 0xca, 0x21, 0x0e, 0xf3, 0xca,
	0xe7, 0x1c, 0x28, 0x4c, 0x5d, 0x5e, 0x32, 0x10, 0xb3, 0x92, 0x79, 0x6f, 0x36, 0x9f, 0xb8, 0x37,
	0xd7, 0x61, 0xc6, 0x27, 0x87, 0xc4, 0x67, 0x4b, 0xbd, 0xb4, 0xef, 0x31, 0xa0, 0xda, 0x6b, 0x15,
	0x28, 0xe6, 0x85, 0xcd, 0x7f, 0x60, 0xc0, 0x2c, 0x9f, 0xb8, 0xa7, 0x60, 0xb0, 0x9c, 0xca, 0x56,
	0x6c, 0x4e, 0xe0, 0xa2, 0xfe, 0x46, 0x8f, 0x1e, 0x55, 0xc8, 0x03, 0xe2, 0x58, 0x4e, 0x38, 0x1a,
	0xd9, 0x81, 0xcb, 0x8e, 0x6b, 0xa5, 0xa3, 0x4a, 0x19, 0xa7, 0xf1, 0x14, 0x6b, 0x91, 0xb8, 0x43,
	0x11, 0xd7, 0x39, 0xdc, 0xbc, 0x05, 0x73, 0xc2, 0xbd, 0xc2, 0xc2, 0x44, 0x42, 0x37, 0x11, 0x32,
	0x8a, 0x30, 0x91, 0xd0, 0xd5, 0xfa, 0x7e, 0xe5, 0x3b, 0x6e, 0x0a, 0x30, 0x7f, 0x7b, 0x09, 0xe6,
	0x73, 0xc3, 0x9a, 0xf6, 0x8d, 0x37, 0xb2, 0x87, 0x59, 0xf7, 0x16, 0x61, 0xa2, 0x14, 0xa8, 0x9e,
	0x16, 0x2b, 0x50, 0xcc, 0x0b, 0xa3, 0x4d, 0x98, 0xcb, 0x1a, 0xdf, 0x60, 0x15, 0xcb, 0xcf, 0x9d,
	0x75, 0xed, 0xd6, 0x34, 0x39, 0x63, 0x41, 0xdb, 0x68, 0xc7, 0xc3, 0xec, 0xc8, 0x97, 0xb7, 0x91,
	0xc2, 0xd4, 0xad, 0x3a, 0xae, 0xdc, 0xe3, 0x53, 0x00, 0xfa, 0x0d, 0x03, 0x2e, 0xa7, 0x24, 0x1e,
	0x79, 0x01, 0x33, 0xe8, 0xac, 0x61, 0x6c, 0x3b, 0xc4, 0x8a, 0x48, 0xec, 0xf1, 0x0b, 0xca, 0x30,
	0x70, 0x13, 0x66, 0xa2, 0x37, 0x0b, 0x4f, 0xdd, 0xc3, 0xe8, 0xd5, 0xf9, 0xff, 0xe8, 0x05, 0xf0,
	0xc7, 0x4a, 0xc4, 0x37, 0x28, 0xed, 0x80, 0x91, 0x6e, 0x73, 0x4a, 0xf4, 0x35, 0x03, 0xba, 0x51,
	0x4c, 0xac, 0x24, 0x0d, 0xa3, 0xfc, 0x4e, 0x79, 0x4e, 0xa3, 0x63, 0x07, 0x31, 0xd9, 0x4e, 0xc3,
	0x28, 0xbb, 0x4b, 0xce, 0x4f, 0x0d, 0xd5, 0xc2, 0xea, 0x5c, 0xa8, 0x27, 0xc0, 0x4b, 0x91, 0xc4,
	0x15, 0xfd, 0x75, 0x58, 0x8e, 0x89, 0xed, 0x7a, 0x01, 0x49, 0x12, 0xaa, 0xcd, 0x76, 0x33, 0x7d,
	0x8f, 0x2a, 0x75, 0x09, 0x77, 0x4b, 0x6a, 0xbe, 0x52, 0x44, 0x63, 0xff, 0xd5, 0xe1, 0xf1, 0x52,
	0x8e, 0x63, 0x3c, 0xd1, 0x07, 0xb0, 0xe4, 0x7b, 0x87, 0xa4, 0x24, 0x7f, 0xbe, 0x56, 0x7e, 0x7e,
	0x01, 0x21, 0x97, 0xd0, 0x04, 0x55, 0xd7, 0xa0, 0xf1, 0x62, 0x86, 0xe2, 0xc2, 0x43, 0x98, 0x23,
	0xc1, 0xa1, 0x75, 0x68, 0xc7, 0x22, 0xfa, 0xc3, 0xd4, 0x87, 0x47, 0xad, 0xf6, 0x83, 0xc3, 0x77,
	0xec, 0x98, 0x9f, 0x67, 0xf2, 0xf9, 0x2e, 0x8a, 0x6a, 0xbc, 0xe6, 0x55, 0x38, 0x9e, 0x25, 0x8c,
	0x01, 0x3a, 0x50, 0xaf, 0xc3, 0x3a, 0x6c, 0x31, 0x3e, 0x8d, 0x1b, 0xaf, 0x9f, 0x83, 0xc5, 0x20,
	0x74, 0x89, 0x95, 0xdf, 0xc7, 0x2e, 0x68, 0x42, 0xa8, 0xb6, 0x42, 0x97, 0xe4, 0x77, 0xb2, 0xf9,
	0x95, 0x97, 0x54, 0x4e, 0x55, 0xbd, 0x35, 0x58, 0xbc, 0x10, 0x94, 0xb8, 0xa1, 0x6d, 0x68, 0xc5,
	0xb6, 0x73, 0x20, 0xe2, 0x42, 0x64, 0xb7, 0x2c, 0xb6, 0x9d, 0x83, 0xd2, 0xae, 0x65, 0x3b, 0x6a,
	0xb8, 0x52, 0x05, 0x88, 0x19, 0x33, 0xf4, 0x3d, 0x03, 0x2e, 0x46, 0xa1, 0x6b, 0x79, 0xc1, 0x5e,
	0x68, 0x11, 0x16, 0x27, 0x99, 0x5d, 0x2b, 0x2c, 0x31, 0x39, 0xca, 0x3d, 0x78, 0x35, 0xa0, 0xb2,
	0x38, 0xcd, 0xe8, 0xf9, 0x68, 0xef, 0xd5, 0xa6, 0x92, 0xb1, 0x9b, 0x70, 0x25, 0x6e, 0xf3, 0x43,
	0x03, 0x96, 0x47, 0x3c, 0x0a, 0xd2, 0xe2, 0x01, 0x8b, 0x49, 0x6f, 0x59, 0x13, 0x3a, 0x20, 0x45,
	0x4a, 0x16, 0x13, 0xa1, 0x52, 0x54, 0xef, 0x34, 0xd2, 0xe2, 0xf1, 0xd2, 0xa8, 0xcc, 0x32, 0x41,
	0x7f, 0xcf, 0x80, 0x6e, 0x4d, 0x50, 0xc8, 0x8b, 0x55, 0xb3, 0x4e, 0x8a, 0x08, 0xc9, 0x75, 0xce,
	0x43, 0xa3, 0x41, 0xa6, 0x45, 0x82, 0x2c, 0x27, 0x32, 0xdb, 0x4b, 0xff, 0xc8, 0x80, 0x4e, 0x69,
	0x45, 0x9d, 0x21, 0x37, 0x70, 0xab, 0x3b, 0x63, 0xfe, 0x5a, 0x0b, 0x96, 0xab, 0xc7, 0xbe, 0xea,
	0x29, 0xcd, 0x78, 0xfa, 0xa7, 0xb4, 0xc6, 0x47, 0x73, 0x4a, 0x6b, 0x9e, 0xe6, 0x29, 0xed, 0x1e,
	0x40, 0x14, 0x7b, 0x87, 0x9e, 0x4f, 0x86, 0xc4, 0x15, 0xe7, 0xef, 0xdc, 0x4f, 0x59, 0x60, 0x34,
	0x3b, 0x96, 0x06, 0x85, 0x4b, 0xbc, 0xd0, 0x2f, 0x19, 0x70, 0xc9, 0xf6, 0xfd, 0xf0, 0xbe, 0x95,
	0x03, 0x2d, 0x92, 0x38, 0xb6, 0xcf, 0xb6, 0x59, 0x76, 0x14, 0x6c, 0xaf, 0xdd, 0x3b, 0x3e, 0x5a,
	0xd9, 0x61, 0xe6, 0x43, 0x2d, 0xa5, 0x6a, 0x54, 0x3c, 0x0a, 0x29, 0xee, 0x31, 0xb2, 0x41, 0x46,
	0xd5, 0xcf, 0x89, 0xcc, 0x1f, 0xcc, 0xc2, 0xa2, 0xe4, 0xbf, 0x3c, 0x1d, 0x23, 0x96, 0x1b, 0x6a,
	0x8d, 0x53, 0x32, 0xd4, 0x9a, 0xa7, 0x67, 0xa8, 0xb5, 0x9e, 0xd8, 0x50, 0x4b, 0x8a, 0xcd, 0x76,
	0x86, 0xa9, 0xc1, 0x97, 0xeb, 0x23, 0xa8, 0x4e, 0x6d, 0xc3, 0x95, 0x42, 0x88, 0x67, 0x3f, 0x82,
	0x10, 0x62, 0xad, 0xae, 0x9d, 0xfb, 0xff, 0xba, 0xb6, 0xea, 0xe9, 0xfc, 0x95, 0x26, 0xb4, 0x73,
	0x4b, 0x41, 0xb1, 0x54, 0x8c, 0x8f, 0xd6, 0x52, 0xf9, 0x39, 0x58, 0x60, 0x31, 0x81, 0x99, 0x78,
	0x7e, 0x91, 0xfc, 0x31, 0xe5, 0xd2, 0x9b, 0x9e, 0x57, 0xf3, 0x2a, 0x94, 0xee, 0xa7, 0xdc, 0xfa,
	0x1a, 0xd4, 0x20, 0x71, 0x27, 0x0a, 0xdd, 0x5c, 0xfe, 0xd7, 0x0d, 0x38, 0xc7, 0x83, 0x12, 0x53,
	0xaf, 0xa8, 0x45, 0xf3, 0x51, 0x6a, 0x91, 0xbb, 0x2d, 0x94, 0xf2, 0x35, 0x61, 0x8f, 0x7a, 0x0a,
	0xbc, 0xcc, 0x02, 0x1f, 0x53, 0x2f, 0x63, 0x6c, 0xfe, 0x2f, 0x03, 0x16, 0xca, 0x5d, 0x7e, 0xc2,
	0x99, 0x73, 0x13, 0x66, 0xd9, 0xe0, 0x27, 0xe2, 0xd4, 0x98, 0xfb, 0xa8, 0x38, 0x54, 0x3f, 0x77,
	0x64, 0x1f, 0x15, 0x07, 0xa1, 0x2f, 0x42, 0x2b, 0x1e, 0x8b, 0x6b, 0xb0, 0xa5, 0xca, 0x1c, 0xc9,
	0x2a, 0xcb, 0x2e, 0x24, 0x0b, 0xf3, 0x72, 0xac, 0x73, 0x8a, 0x8c, 0xab, 0x4e, 0x91, 0xb1, 0x4f,
	0xcc, 0xff, 0x62, 0x40, 0xb7, 0xda, 0xc7, 0xb9, 0x44, 0xe3, 0x29, 0x48, 0x44, 0x43, 0x98, 0xa1,
	0x07, 0xc6, 0xec, 0x6e, 0xe5, 0xe3, 0x53, 0x87, 0x7b, 0x87, 0xc4, 0xa3, 0x62, 0xd5, 0xb1, 0x72,
	0xda, 0xb3, 0xaa, 0xfc, 0xbe, 0x93, 0x41, 0xcc, 0xff, 0xdc, 0x84, 0x67, 0x75, 0xfc, 0xce, 0xcc,
	0xc0, 0xde, 0x03, 0xc8, 0x1f, 0x17, 0x65, 0x1e, 0x81, 0xdc, 0x7a, 0x28, 0x30, 0xda, 0x4d, 0x54,
	0x41, 0xe1, 0x12, 0x2f, 0x34, 0x81, 0x85, 0x34, 0x8c, 0x42, 0x3f, 0x1c, 0x4e, 0x2c, 0xda, 0xd4,
	0x96, 0x26, 0xa4, 0x67, 0x47, 0x10, 0xdc, 0x22, 0xa5, 0xa5, 0x5d, 0x2e, 0xa5, 0x76, 0xb4, 0x1e,
	0x89, 0x3b, 0x69, 0xc1, 0x0a, 0xbd, 0x07, 0xb3, 0xf7, 0x89, 0x37, 0xdc, 0x4f, 0x85, 0xbb, 0x5a,
	0x76, 0xd8, 0xde, 0x65, 0xa8, 0xa2, 0xcf, 0x38, 0xa9, 0x22, 0x49, 0x01, 0x63, 0xc1, 0xd4, 0xbc,
	0x05, 0x9d, 0x52, 0xc5, 0x4f, 0x36, 0x94, 0x26, 0x86, 0x59, 0x5e, 0x21, 0x3a, 0xa8, 0xa2, 0xd6,
	0x94, 0xd5, 0xcc, 0x09, 0x2a, 0x38, 0x84, 0x16, 0x3d, 0xeb, 0x21, 0xab, 0x32, 0x04, 0xbc, 0x8a,
	0xa7, 0xd7, 0xd1, 0xe6, 0x9f, 0xcc, 0xc2, 0x0c, 0x3f, 0xd5, 0xff, 0xbc, 0x01, 0x17, 0xe8, 0xec,
	0xf6, 0x6c, 0xdf, 0x72, 0x89, 0x6f, 0x4f, 0x72, 0x37, 0x50, 0x83, 0x35, 0x26, 0x8f, 0x06, 0xd4,
	0x12, 0x69, 0x63, 0xb4, 0xa7, 0x51, 0xe1, 0xf3, 0x82, 0x62, 0x9d, 0x12, 0x64, 0x6e, 0x9e, 0x03,
	0x58, 0x4e, 0xbd, 0x11, 0x09, 0xc7, 0x69, 0x2e, 0xbd, 0xc9, 0xa4, 0xe7, 0x16, 0x7d, 0x05, 0xad,
	0xb6, 0xba, 0x16, 0x8f, 0x97, 0x04, 0x2e, 0x13, 0x36, 0x84, 0xa5, 0x8a, 0xc3, 0xab, 0xc5, 0x64,
	0xe5, 0x0e, 0x93, 0x87, 0xb8, 0xb7, 0xea, 0x9d, 0x59, 0x8b, 0x91, 0xe4, 0xbc, 0x4a, 0xe0, 0x5c,
	0x32, 0x76, 0x1c, 0x92, 0x24, 0x56, 0xba, 0x1f, 0x93, 0x64, 0x3f, 0xf4, 0xf9, 0x0b, 0xd2, 0x99,
	0x62, 0x23, 0x52, 0x08, 0x34, 0xf7, 0x1e, 0xf5, 0x14, 0xb8, 0x2b, 0xb0, 0x3b, 0x19, 0x92, 0x0a,
	0xdd, 0xb3, 0x3d, 0x7f, 0x1c, 0x93, 0x92, 0xd0, 0x59, 0x59, 0xa8, 0x42, 0xa0, 0xde, 0xc2, 0x4d,
	0xa1, 0xc0, 0x5d, 0x81, 0x2d, 0x84, 0xbe, 0x0b, 0x2d, 0xf2, 0x80, 0x38, 0xc2, 0x1b, 0x56, 0x8d,
	0x12, 0x26, 0x4e, 0xe6, 0x96, 0xcb, 0x55, 0x3e, 0xa5, 0xd6, 0xba, 0x7c, 0x25, 0x95, 0x4f, 0x01,
	0x94, 0xf7, 0x7e, 0x9a, 0x46, 0xc2, 0xd3, 0x55, 0x79, 0x71, 0xb4, 0xb3, 0x33, 0x50, 0x78, 0x53,
	0x6a, 0x35, 0x38, 0x40, 0x06, 0x62, 0xc6, 0x13, 0xdd, 0x81, 0x66, 0xea, 0x44, 0x3d, 0x60, 0xac,
	0x9f, 0x93, 0x35, 0xdc, 0xf5, 0x9c, 0x73, 0xae, 0x1a, 0x52, 0x47, 0x65, 0x2c, 0xc3, 0x30, 0xe5,
	0xc7, 0x23, 0xa4, 0xcc, 0x2f, 0x42, 0xa7, 0xd4, 0xf6, 0xf2, 0x09, 0xc3, 0x38, 0xf1, 0x09, 0xc3,
	0xfc, 0x67, 0x0d, 0xe8, 0x94, 0x5a, 0x8f, 0x7c, 0x98, 0x4d, 0x9c, 0x7d, 0x32, 0xca, 0xf6, 0x5d,
	0xb3, 0xae, 0x9f, 0x56, 0xef, 0xe0, 0x8d, 0x6d, 0x46, 0x59, 0xba, 0xf9, 0x62, 0xff, 0xd5, 0x99,
	0x57, 0x05, 0x63, 0x21, 0x83, 0x3b, 0xdb, 0xe3, 0x54, 0x5c, 0x78, 0x97, 0x9c, 0xed, 0xb1, 0xee,
	0xe9, 0x8b, 0x7c, 0x65, 0xcc, 0x4a, 0xe6, 0xaf, 0x3a, 0x9b, 0x4f, 0xfc, 0xaa, 0xf3, 0x32, 0xcc,
	0xe7, 0x4d, 0x41, 0x6d, 0x68, 0xd1, 0x36, 0x76, 0x9f, 0x41, 0xf3, 0x30, 0x43, 0x7f, 0x6d, 0x77,
	0x0d, 0x73, 0x0b, 0xa0, 0x18, 0xc5, 0xbc, 0xce, 0xc6, 0x93, 0xd6, 0xd9, 0xfc, 0x12, 0x2c, 0xc9,
	0x6e, 0xe6, 0xa7, 0x7f, 0xc1, 0xf1, 0x0b, 0xb3, 0x30, 0x27, 0x42, 0xc8, 0xd0, 0x3d, 0x98, 0x89,
	0xe2, 0xf0, 0x41, 0x66, 0xef, 0x2b, 0x3e, 0xdf, 0x07, 0x93, 0x52, 0x10, 0x00, 0xfd, 0xab, 0xf1,
	0x1c, 0xc8, 0x50, 0xcc, 0x19, 0xa2, 0xbb, 0x30, 0x43, 0x1b, 0x98, 0x59, 0x55, 0xe7, 0x2a, 0x56,
	0x55, 0x5c, 0x0a, 0x5e, 0x65, 0x74, 0xda, 0xfe, 0x92, 0xad, 0x28, 0x06, 0x61, 0xe7, 0x3b, 0xc7,
	0xf7, 0x48, 0x90, 0x5a, 0x24, 0x70, 0xa3, 0xd0, 0x0b, 0xd2, 0xec, 0x6d, 0xea, 0x8b, 0x95, 0x27,
	0x61, 0x1e, 0x8b, 0xc5, 0x15, 0x34, 0xc5, 0xf9, 0xae, 0x5a, 0x5a, 0xf3, 0x06, 0xac, 0x96, 0x00,
	0x2f, 0x3b, 0x32, 0x5b, 0xf4, 0x0d, 0x03, 0xce, 0xb9, 0x5e, 0xe2, 0x84, 0x87, 0x24, 0x9e, 0x64,
	0x61, 0xc4, 0xc2, 0xc0, 0x91, 0x8f, 0x0e, 0xeb, 0x19, 0x95, 0x08, 0xd8, 0x29, 0x94, 0xa7, 0x52,
	0x5e, 0xa9, 0xd2, 0x34, 0x0a, 0xdc, 0x75, 0x2b, 0x9c, 0x91, 0x0d, 0x0b, 0x99, 0x9f, 0x9a, 0x5d,
	0x31, 0xf2, 0x1c, 0x03, 0x9f, 0xcf, 0x26, 0x51, 0x19, 0x57, 0xeb, 0xe0, 0xae, 0x20, 0x7b, 0x06,
	0xee, 0x08, 0x14, 0x8b, 0xc5, 0xfc, 0xb7, 0x06, 0x7c, 0x62, 0x9c, 0x10, 0xcb, 0x25, 0x7b, 0xf6,
	0xd8, 0x4f, 0x2d, 0x7a, 0x02, 0xf7, 0x0f, 0x49, 0x6c, 0xed, 0x85, 0xb1, 0xc5, 0x5f, 0x5a, 0xb2,
	0x27, 0x98, 0x6c, 0xa3, 0x68, 0xaf, 0xf9, 0xc7, 0x47, 0x2b, 0xfb, 0xe2, 0x8a, 0xf5, 0xa1, 0x65,
	0x74, 0x57, 0xb0, 0x8f, 0x53, 0x08, 0x5f, 0x1e, 0x27, 0x64, 0x9d, 0xd3, 0x63, 0x41, 0xfe, 0x66,
	0x18, 0xdf, 0x2c, 0x88, 0xcd, 0xdf, 0x6f, 0x41, 0xb7, 0x3a, 0x20, 0xe8, 0xef, 0x56, 0xa2, 0xad,
	0x78, 0x2c, 0xe8, 0xea, 0xd4, 0x51, 0x7c, 0x8a, 0xf1, 0x56, 0x09, 0xcc, 0x8a, 0xe7, 0x18, 0x7c,
	0x11, 0xfd, 0xc4, 0xf4, 0x8a, 0x94, 0x1f, 0x5c, 0xe4, 0x7a, 0xb8, 0xe6, 0x85, 0x85, 0xfa, 0xa4,
	0x42, 0x88, 0x3a, 0xd3, 0xe1, 0x59, 0xcc, 0x99, 0x72, 0x06, 0xe3, 0x97, 0xcd, 0x1f, 0x18, 0xb0,
	0x5c, 0xd1, 0x37, 0x68, 0x00, 0xed, 0x2c, 0xf3, 0x85, 0xa8, 0x60, 0x1e, 0xa9, 0x94, 0xc1, 0x6b,
	0xb3, 0x69, 0x48, 0x2f, 0xee, 0x32, 0x20, 0xe5, 0xe8, 0x05, 0x82, 0x63, 0x43, 0xe6, 0x98, 0xc1,
	0x35, 0xc6, 0xb3, 0x86, 0x63, 0x06, 0x34, 0x7f, 0xab, 0x05, 0x73, 0xe2, 0x15, 0x32, 0x72, 0x60,
	0x91, 0xc1, 0x0f, 0x6d, 0x9f, 0x1a, 0xa2, 0x89, 0xd8, 0xd5, 0x72, 0x47, 0x8f, 0x84, 0xd4, 0xcb,
	0xd1, 0x60, 0xf1, 0x42, 0x86, 0xd9, 0x26, 0x4e, 0x82, 0x42, 0xe8, 0xc6, 0x24, 0x25, 0x01, 0xbb,
	0xc8, 0x1d, 0x85, 0x41, 0xba, 0xcf, 0x95, 0x77, 0xe9, 0x25, 0x71, 0x15, 0xaf, 0xf1, 0x00, 0xd6,
	0x12, 0xe0, 0xe5, 0x1c, 0xf9, 0x36, 0xc3, 0xe5, 0x5b, 0x74, 0xeb, 0x89, 0xcd, 0x8a, 0x9b, 0xb9,
	0x19, 0x34, 0x23, 0xa7, 0x27, 0x79, 0x6c, 0x13, 0xc7, 0x82, 0x05, 0xf1, 0x6a, 0x9b, 0x07, 0x28,
	0xcf, 0xca, 0x47, 0xb0, 0x32, 0xae, 0xee, 0x09, 0xb8, 0x12, 0xa4, 0xdc, 0x11, 0x08, 0x16, 0xa6,
	0xfc, 0x1e, 0xcc, 0x24, 0x5e, 0x70, 0x90, 0xc5, 0x26, 0x3d, 0xa7, 0x79, 0x6d, 0xbe, 0xed, 0x05,
	0x07, 0xc5, 0x4c, 0x67, 0xd4, 0x6a, 0x0b, 0x2a, 0x50, 0xcc, 0xb9, 0xbe, 0xd5, 0x6a, 0x37, 0xba,
	0x4d, 0xf3, 0x87, 0x0d, 0x80, 0x82, 0x17, 0x7a, 0x03, 0x1a, 0x9e, 0x2b, 0x26, 0xf8, 0x2b, 0xc7,
	0x47, 0x2b, 0x9f, 0x60, 0x73, 0x45, 0xb5, 0x4d, 0xe4, 0xa4, 0x35, 0x0d, 0xcf, 0x45, 0x3b, 0x30,
	0xbf, 0xeb, 0xdb, 0xce, 0x81, 0xef, 0x25, 0xa9, 0xf0, 0x5d, 0xe4, 0xfe, 0xdf, 0x1c, 0xa1, 0xf0,
	0xd1, 0x61, 0x70, 0xc1, 0x88, 0x72, 0xbd, 0xbf, 0xef, 0xa5, 0x84, 0x71, 0x6d, 0xca, 0x5c, 0x73,
	0x84, 0x7a, 0x7e, 0xd6, 0x60, 0x70, 0xc1, 0x88, 0x72, 0x75, 0x89, 0x9f, 0xda, 0x8c, 0x6b, 0x4b,
	0xe6, 0x9a, 0x23, 0xd4, 0x5d, 0x5b, 0x83, 0xc1, 0x05, 0x23, 0xf3, 0x3e, 0xb4, 0x36, 0xc3, 0xa1,
	0x7e, 0x55, 0x18, 0x4f, 0x71, 0x55, 0x98, 0xff, 0xbc, 0x01, 0xc0, 0xcc, 0xbb, 0x01, 0xb3, 0xa9,
	0xf6, 0x33, 0x63, 0xcd, 0xd0, 0x5c, 0xc2, 0x17, 0x74, 0xcc, 0x6e, 0x13, 0x1b, 0xcc, 0x93, 0x59,
	0x6f, 0x97, 0x7e, 0xdd, 0x00, 0x28, 0xb8, 0x9c, 0x50, 0x7f, 0xff, 0x15, 0xf9, 0xdd, 0xd1, 0x45,
	0x7d, 0xb5, 0x4f, 0xa2, 0xd7, 0xff, 0x61, 0x9b, 0xf9, 0x34, 0x1e, 0x4c, 0xd0, 0xfb, 0x30, 0x1b,
	0x87, 0xe3, 0x94, 0x64, 0x7d, 0xf4, 0x92, 0x2a, 0x6c, 0x15, 0x33, 0x82, 0xe2, 0xce, 0xe4, 0x55,
	0x1e, 0x10, 0x46, 0x81, 0x9a, 0x90, 0xb0, 0x0a, 0xb8, 0x67, 0x60, 0x21, 0x81, 0xf6, 0x4a, 0x92,
	0xf8, 0x22, 0x4c, 0x34, 0xef, 0x95, 0x24, 0x51, 0xb5, 0xbb, 0x0c, 0xc3, 0xb4, 0x98, 0xb4, 0x4b,
	0xf0, 0x1b, 0xc0, 0x13, 0xee, 0x12, 0xc8, 0x87, 0xf9, 0xdd, 0x30, 0x4c, 0x93, 0x34, 0xb6, 0x23,
	0xe1, 0x45, 0xbb, 0x58, 0x7d, 0x8d, 0xc7, 0xb1, 0xa5, 0x05, 0x9c, 0x81, 0xd4, 0x05, 0xac, 0xc1,
	0xe0, 0x42, 0x00, 0xba, 0x27, 0xa2, 0xae, 0x66, 0x59, 0x3f, 0x6b, 0x07, 0xd5, 0x4d, 0x9e, 0x24,
	0x1a, 0x0b, 0xfd, 0xcd, 0x8a, 0x79, 0xc7, 0xb5, 0xe4, 0x8f, 0x69, 0x46, 0xf2, 0xe9, 0xd9, 0x74,
	0x63, 0x40, 0x8e, 0xc5, 0x92, 0x8f, 0x89, 0xb7, 0xfd, 0xae, 0xe5, 0xef, 0x32, 0x27, 0x47, 0xbb,
	0xf4, 0xd2, 0x52, 0xa1, 0x50, 0xcf, 0x28, 0xd3, 0x48, 0xf0, 0xb2, 0xc3, 0xd2, 0xa2, 0xf1, 0xe4,
	0x00, 0xee, 0xe6, 0xee, 0xa5, 0xef, 0x1b, 0xd0, 0x29, 0x4d, 0xcf, 0x13, 0x2e, 0xbc, 0xf7, 0xe4,
	0x85, 0xf7, 0x5c, 0x8d, 0xbe, 0x38, 0x89, 0xa5, 0x77, 0xa6, 0x5f, 0x09, 0x7c, 0xb7, 0x01, 0xf3,
	0xf9, 0x54, 0x3c, 0x85, 0xfb, 0xe6, 0xcf, 0x41, 0xd3, 0x0d, 0x92, 0x6a, 0xde, 0x32, 0x57, 0x33,
	0xc5, 0x64, 0x18, 0xa6, 0xc5, 0xd0, 0x36, 0xcc, 0xb3, 0x6b, 0x36, 0x66, 0xe7, 0x70, 0x63, 0x2a,
	0x5f, 0x86, 0x39, 0x42, 0x7f, 0x33, 0x57, 0xb5, 0x78, 0xda, 0x14, 0x3a, 0xc8, 0x9c, 0x29, 0x27,
	0xb2, 0x9b, 0xcc, 0xff, 0xd3, 0x84, 0xf9, 0x5c, 0x31, 0x64, 0x4d, 0x34, 0x9e, 0xac, 0x89, 0x27,
	0x77, 0x0e, 0x3d, 0x95, 0x4e, 0xfa, 0x9a, 0x01, 0x5d, 0xe9, 0xad, 0x3a, 0xdd, 0x43, 0x5b, 0x9a,
	0x10, 0xa3, 0xbc, 0x1f, 0xd8, 0x86, 0x94, 0x6f, 0xea, 0xd5, 0xb2, 0xd3, 0x1f, 0xc2, 0x57, 0x76,
	0xd4, 0xe5, 0xf2, 0x1b, 0x78, 0xba, 0x8b, 0xff, 0xa2, 0x01, 0xcf, 0xe5, 0xe9, 0xf8, 0xd2, 0xd8,
	0xde, 0xdb, 0xf3, 0x9c, 0x2c, 0x34, 0x8b, 0x9b, 0xae, 0xf8, 0xf8, 0x68, 0x65, 0x4b, 0x4a, 0xee,
	0x27, 0x93, 0xd5, 0x67, 0xf7, 0xab, 0xa5, 0xc3, 0x17, 0x32, 0x9a, 0x1d, 0x4e, 0xc2, 0x83, 0xaf,
	0xcc, 0x5f, 0x69, 0xc0, 0xa2, 0xd4, 0x6a, 0x74, 0x08, 0x28, 0xdb, 0x51, 0x58, 0x63, 0xac, 0xd2,
	0xa2, 0xc9, 0x35, 0x9f, 0x4a, 0x51, 0xbb, 0x57, 0x69, 0x49, 0x70, 0x37, 0x43, 0x53, 0x99, 0xec,
	0x79, 0xfe, 0xd9, 0x9c, 0x3b, 0xe6, 0x6f, 0x1a, 0xb9, 0x0e, 0x89, 0x53, 0xe5, 0xb0, 0xb8, 0x78,
	0xea, 0x87, 0xc5, 0xc5, 0x13, 0x1f, 0x16, 0x7f, 0xb7, 0x09, 0x0b, 0xe5, 0x68, 0x0d, 0xba, 0xa6,
	0x9d, 0x68, 0x5c, 0x5d, 0xd3, 0x4e, 0x34, 0x56, 0x77, 0x2b, 0x09, 0x86, 0x69, 0x31, 0x7a, 0xae,
	0x1a, 0x91, 0x51, 0x18, 0x4f, 0x84, 0xde, 0xcb, 0xcf, 0x55, 0x1c, 0xaa, 0x39, 0x01, 0x55, 0xc0,
	0x58, 0x94, 0x47, 0xbb, 0x30, 0x97, 0xa4, 0x61, 0x6c, 0x0f, 0x89, 0x48, 0xd3, 0x2b, 0xbf, 0x96,
	0xdf, 0xe6, 0xb8, 0xc2, 0x39, 0x2e, 0x88, 0x35, 0x99, 0x5c, 0xab, 0x70, 0x9c, 0x31, 0x46, 0xfb,
	0xd0, 0x8e, 0xc9, 0x97, 0xc6, 0x24, 0x49, 0x13, 0xe1, 0xdc, 0x93, 0x2d, 0x93, 0x22, 0x86, 0xa5,
	0x94, 0x74, 0x8f, 0xd3, 0x6b, 0x4c, 0x75, 0x05, 0x81, 0x73, 0xee, 0xe8, 0x67, 0x61, 0xd6, 0xf7,
	0x46, 0x5e, 0x9a, 0x68, 0x4d, 0xad, 0x42, 0x4e, 0xe1, 0xe2, 0x61, 0xd4, 0x9a, 0x20, 0xdc, 0x0a,
	0x18, 0x0b, 0xbe, 0xe6, 0x37, 0x0d, 0x98, 0x3f, 0x73, 0xa3, 0x68, 0x7e, 0x65, 0x0e, 0xe6, 0xc4,
	0x50, 0xa1, 0x77, 0xa5, 0x37, 0x77, 0x3d, 0xdd, 0x70, 0x3e, 0xf1, 0x63, 0xbb, 0x01, 0xb4, 0x1d,
	0x3b, 0xb2, 0x9d, 0x2c, 0xce, 0xa4, 0xe4, 0x45, 0xc9, 0xe0, 0x6a, 0xcb, 0x55, 0x04, 0xce, 0xb9,
	0xe4, 0x06, 0x40, 0xf3, 0x89, 0x0d, 0x80, 0x43, 0x40, 0x62, 0xa2, 0x95, 0x53, 0x97, 0xb4, 0x64,
	0xdd, 0xa8, 0x52, 0xd4, 0xcd, 0xe0, 0xba, 0xd4, 0x25, 0x02, 0x5d, 0xa4, 0x2e, 0x89, 0xe1, 0x1c,
	0x09, 0x9c, 0x78, 0xc2, 0x5e, 0xc5, 0x58, 0x2c, 0xff, 0x66, 0x96, 0x90, 0x36, 0x77, 0x4e, 0x2b,
	0x04, 0x9a, 0xf0, 0xaf, 0x7a, 0x0a, 0xbc, 0x5c, 0x60, 0x6f, 0x91, 0xc9, 0x86, 0x8b, 0x02, 0xe8,
	0xca, 0xd5, 0xf4, 0x5c, 0xe1, 0x09, 0x29, 0x22, 0xb0, 0x2a, 0xf8, 0x87, 0xb4, 0x53, 0x16, 0xb8,
	0x54, 0x6e, 0xe5, 0x06, 0x0b, 0x9c, 0xf3, 0xc2, 0x28, 0x61, 0x97, 0x7d, 0x25, 0xfd, 0x4f, 0x61,
	0xaa, 0x02, 0x94, 0x81, 0x98, 0x95, 0x44, 0xf7, 0x00, 0xd2, 0xfd, 0x38, 0x1c, 0x0f, 0xf7, 0xa3,
	0x71, 0xca, 0x6e, 0xf6, 0x16, 0x8b, 0xb8, 0x88, 0x02, 0xa3, 0xce, 0x3f, 0x1d, 0x0a, 0x97, 0x78,
	0xb1, 0x87, 0x9f, 0xae, 0x97, 0x1c, 0x58, 0xa5, 0x2e, 0x4c, 0x48, 0x4a, 0xbb, 0x84, 0x87, 0xa5,
	0xe7, 0xa1, 0xd2, 0x7a, 0x2a, 0xdd, 0x3d, 0xc1, 0x74, 0x32, 0x7c, 0x9e, 0x92, 0xf4, 0x73, 0x8a,
	0x6d, 0x92, 0x6e, 0xb8, 0xe5, 0xfc, 0x0b, 0xe6, 0x6f, 0x35, 0xa0, 0x95, 0x99, 0x80, 0x27, 0xb4,
	0x6b, 0x4f, 0xbe, 0xf5, 0x0e, 0xa0, 0xcd, 0xb2, 0xdb, 0x3b, 0xa1, 0x2f, 0x96, 0x57, 0xbe, 0x58,
	0x33, 0xb8, 0xee, 0x4a, 0xaa, 0x8a, 0xc0, 0x39, 0x17, 0xba, 0x99, 0x17, 0x19, 0xcb, 0x5a, 0xf2,
	0x66, 0x5e, 0x9f, 0xac, 0x4c, 0x9b, 0xa7, 0x8c, 0x27, 0x1e, 0xa0, 0x9b, 0xf9, 0xf7, 0x1b, 0xb5,
	0x89, 0x97, 0x79, 0x8e, 0x4e, 0xf6, 0x6e, 0x70, 0xdf, 0x8e, 0x89, 0x2b, 0xfc, 0x07, 0xe7, 0xab,
	0x0f, 0x1d, 0xa4, 0x44, 0x9e, 0x9c, 0x54, 0x9d, 0xf6, 0x55, 0x30, 0x16, 0x4c, 0xd1, 0x0e, 0x34,
	0xa3, 0xd0, 0x15, 0xf7, 0x04, 0x17, 0xab, 0x21, 0x4c, 0x82, 0x7d, 0x91, 0x11, 0x39, 0x74, 0x75,
	0x47, 0x66, 0x39, 0x23, 0x72, 0xe8, 0xd2, 0xa3, 0xb8, 0x17, 0x78, 0xa9, 0xd8, 0x55, 0xeb, 0xd8,
	0x16, 0x4b, 0x2a, 0xf0, 0x52, 0x6d, 0xf4, 0x86, 0xbc, 0xa4, 0x02, 0x2f, 0x35, 0x7f, 0x95, 0x5a,
	0x3f, 0x19, 0x87, 0x13, 0xf8, 0x10, 0xdf, 0xcb, 0xd3, 0xa6, 0x36, 0x1e, 0xa1, 0x5b, 0x1f, 0x37,
	0x3f, 0x2a, 0x7b, 0x1a, 0x27, 0xea, 0x78, 0x56, 0x9e, 0xc6, 0xfd, 0x8f, 0x05, 0xe8, 0x94, 0xb2,
	0xa2, 0xe6, 0xf5, 0x6a, 0x3c, 0x71, 0xbd, 0xa4, 0x2c, 0xc5, 0xcd, 0xa7, 0x9d, 0xa5, 0x58, 0x0a,
	0x08, 0x6e, 0x7d, 0x04, 0x01, 0xc1, 0x13, 0x58, 0xe4, 0xa3, 0x39, 0x8e, 0xb3, 0x58, 0xf5, 0xda,
	0x99, 0x92, 0x5f, 0x76, 0x48, 0x25, 0x6a, 0x26, 0x8c, 0x8a, 0xc5, 0xb2, 0x24, 0x94, 0x14, 0xf9,
	0x5f, 0xb9, 0x37, 0xeb, 0xc7, 0xeb, 0x92, 0xdb, 0x66, 0xb9, 0x60, 0x2b, 0x01, 0xd7, 0x4f, 0x98,
	0x10, 0x36, 0xcb, 0x56, 0x3c, 0xf7, 0xb4, 0xb2, 0x15, 0x7f, 0xc7, 0x80, 0x67, 0xb3, 0x4c, 0xa9,
	0xfc, 0x63, 0x07, 0xd2, 0xdb, 0xb5, 0x15, 0x5d, 0x6e, 0x56, 0xfe, 0x39, 0x05, 0xfe, 0x90, 0x2c,
	0xcf, 0x74, 0xaa, 0x63, 0x52, 0x9b, 0x93, 0xb5, 0x86, 0x08, 0x23, 0x47, 0x91, 0x20, 0xa5, 0xc1,
	0x9c, 0xff, 0x68, 0xd3, 0x60, 0xc2, 0x53, 0x49, 0x83, 0x59, 0xca, 0xf3, 0xdb, 0x79, 0x5a, 0x79,
	0x7e, 0x7f, 0x50, 0x9b, 0x0f, 0x70, 0x41, 0x24, 0x25, 0xaa, 0x9b, 0xbe, 0x7f, 0xa6, 0x99, 0xff,
	0x2e, 0xfd, 0xba, 0x01, 0x0b, 0xe5, 0x05, 0xf4, 0x34, 0x73, 0xaf, 0x65, 0x49, 0x9b, 0xff, 0xdf,
	0x4f, 0xc9, 0x65, 0x74, 0x1b, 0xe6, 0x7f, 0x35, 0xe0, 0x5c, 0x69, 0x9c, 0xf9, 0x0a, 0x3b, 0x85,
	0xbd, 0x90, 0x1a, 0xbe, 0x7e, 0x78, 0x9f, 0xb0, 0x69, 0xef, 0x5a, 0x51, 0xe2, 0x58, 0xd9, 0xec,
	0x6e, 0xc8, 0x86, 0xaf, 0x9e, 0x4a, 0x93, 0x12, 0xe0, 0x21, 0x64, 0xf8, 0x3c, 0x27, 0x19, 0x84,
	0xee, 0x20, 0x71, 0xc4, 0x72, 0x31, 0xff, 0xa8, 0x01, 0x48, 0xd5, 0x4f, 0xa5, 0x3b, 0x5f, 0xe3,
	0x84, 0x77, 0xbe, 0x67, 0x20, 0xac, 0x0d, 0x85, 0xd0, 0x2d, 0x5f, 0xcf, 0xe7, 0xf1, 0xa9, 0xa5,
	0xeb, 0xc5, 0x2a, 0x7e, 0xea, 0xfd, 0x7e, 0x35, 0x46, 0x75, 0xb9, 0x74, 0xc5, 0x4f, 0x71, 0x66,
	0x00, 0x73, 0x22, 0x31, 0x1a, 0x72, 0x60, 0xd1, 0x0f, 0x6d, 0xd7, 0xda, 0xb5, 0x7d, 0x3b, 0x70,
	0x88, 0x2b, 0x52, 0xb7, 0xe5, 0x1b, 0xad, 0x84, 0xd4, 0x8c, 0xaa, 0x1e, 0x8b, 0x17, 0x28, 0x66,
	0x4d, 0x20, 0xcc, 0xaf, 0xb6, 0x60, 0x86, 0x5d, 0x78, 0x9c, 0xc2, 0xcc, 0xfc, 0x22, 0x74, 0xdc,
	0xd0, 0x61, 0xe9, 0x36, 0x49, 0x14, 0x8a, 0xd9, 0x98, 0x5f, 0xff, 0x94, 0x50, 0xea, 0xd9, 0x4b,
	0x8b, 0xc3, 0xc0, 0xe1, 0x98, 0x44, 0x21, 0xda, 0x82, 0xa6, 0x7d, 0x3f, 0x0b, 0x57, 0xeb, 0xca,
	0x1b, 0xd2, 0xfd, 0xa4, 0x58, 0xee, 0xf6, 0x7d, 0x8d, 0x6a, 0xbc, 0x2f, 0xfb, 0xc5, 0xed, 0xfb,
	0x09, 0xe5, 0x37, 0x74, 0x22, 0x61, 0x46, 0xc9, 0xfc, 0x6e, 0x38, 0x51, 0xc1, 0x6f, 0xa8, 0x89,
	0x32, 0x1d, 0x56, 0xa2, 0x4c, 0x87, 0x4e, 0x84, 0xee, 0xc1, 0x0c, 0xcb, 0x9e, 0x21, 0x5c, 0x4f,
	0xa8, 0x92, 0xc9, 0xd1, 0xb1, 0xfd, 0x52, 0x92, 0x09, 0xfa, 0x57, 0x9f, 0x9a, 0x43, 0x4e, 0x32,
	0x41, 0x21, 0x74, 0x9b, 0x3c, 0x78, 0x23, 0xb1, 0x4a, 0xdf, 0xbd, 0xe1, 0x67, 0xfe, 0x7c, 0x9b,
	0x94, 0xb1, 0xaa, 0xb2, 0xab, 0x43, 0xe3, 0x85, 0x83, 0x37, 0x92, 0xeb, 0xf9, 0x27, 0x70, 0xe6,
	0x60, 0x86, 0xd5, 0xd3, 0xfc, 0x51, 0x0b, 0x9a, 0xd7, 0xee, 0x33, 0xf7, 0xd6, 0x61, 0xe4, 0x54,
	0xf5, 0xe9, 0x61, 0xa4, 0xc6, 0x0a, 0xcb, 0x30, 0x4c, 0x8b, 0x51, 0x7d, 0xfa, 0xe5, 0x30, 0xc8,
	0xdf, 0x56, 0xe4, 0x8d, 0x67, 0x40, 0x85, 0x43, 0x15, 0x8a, 0x79, 0x61, 0xaa, 0xed, 0x16, 0x59,
	0x58, 0xa4, 0x95, 0x86, 0x2c, 0x81, 0xab, 0x38, 0x51, 0x7d, 0xbc, 0x3a, 0x03, 0xf8, 0xe5, 0xd9,
	0x4e, 0xf8, 0x6e, 0x18, 0x10, 0xbe, 0x7f, 0x16, 0x1f, 0x86, 0x29, 0x97, 0xd7, 0x87, 0x61, 0x6a,
	0xb0, 0xb8, 0x13, 0x15, 0x1c, 0xa9, 0x0d, 0xc1, 0xae, 0x98, 0xff, 0xc2, 0xa7, 0xc4, 0x94, 0x91,
	0xb7, 0x36, 0xcc, 0x71, 0x85, 0x0d, 0x21, 0x88, 0xf5, 0x97, 0xd7, 0x12, 0x1c, 0x67, 0x8c, 0xe9,
	0x94, 0x24, 0xfe, 0xae, 0x98, 0x40, 0xf2, 0x94, 0xec, 0xfb, 0xbb, 0xc5, 0x08, 0x10, 0xcd, 0xa5,
	0xa6, 0x0c, 0xc3, 0x94, 0x11, 0xbb, 0x08, 0xac, 0xf6, 0xca, 0x99, 0xb9, 0x08, 0xfc, 0x1d, 0x03,
	0xe6, 0x44, 0xaf, 0x51, 0xc5, 0x41, 0xcd, 0x38, 0xe2, 0xf2, 0x11, 0x36, 0x64, 0xc5, 0x51, 0x42,
	0x69, 0x9d, 0x0b, 0x2a, 0x0e, 0x03, 0x87, 0xb3, 0x91, 0xbb, 0x0d, 0xed, 0x34, 0x15, 0x71, 0x59,
	0x15, 0x6f, 0x7e, 0x06, 0x57, 0xdd, 0x4f, 0x2a, 0x02, 0xcf, 0xa5, 0x29, 0x0b, 0xc4, 0x32, 0xff,
	0x60, 0x0e, 0x9a, 0x7d, 0x7f, 0x17, 0x7d, 0xd3, 0x80, 0x73, 0x36, 0x7f, 0x0d, 0xe0, 0x87, 0x43,
	0x4b, 0x1c, 0xa6, 0x0d, 0x8d, 0x19, 0xdf, 0xdf, 0x5c, 0xbb, 0xc6, 0x08, 0x37, 0xc3, 0xa1, 0x38,
	0x2e, 0xe5, 0x3e, 0x42, 0x85, 0x83, 0xaa, 0xbd, 0xa6, 0x50, 0xe0, 0x65, 0x5b, 0x66, 0x8c, 0x26,
	0xd0, 0x29, 0x87, 0x90, 0x36, 0x34, 0xd9, 0x39, 0xfa, 0x9b, 0x6b, 0xa5, 0x78, 0xce, 0x52, 0x47,
	0x4f, 0x09, 0x23, 0xad, 0x89, 0x16, 0x2d, 0xcb, 0x42, 0x31, 0x9c, 0xf3, 0x5c, 0x9f, 0x58, 0xa5,
	0xd7, 0x1f, 0x59, 0x88, 0x5a, 0xde, 0x5c, 0x85, 0x40, 0xe3, 0xa9, 0xa8, 0xa7, 0xc0, 0xcb, 0x14,
	0xbb, 0x93, 0xbf, 0x20, 0x49, 0xd0, 0x3f, 0x36, 0xe0, 0x9c, 0x17, 0x24, 0x29, 0xdd, 0xcd, 0xac,
	0x84, 0xf8, 0xc4, 0x49, 0xc3, 0x58, 0x5c, 0x24, 0xbe, 0x5c, 0x5d, 0x42, 0xab, 0x1b, 0x82, 0x72,
	0x5b, 0x10, 0x72, 0x45, 0x51, 0x54, 0xae, 0xca, 0x48, 0xb3, 0x97, 0xd7, 0x53, 0xe0, 0xae, 0x57,
	0x61, 0xcf, 0xf2, 0x28, 0xe4, 0x4f, 0x5e, 0x45, 0xb2, 0xad, 0x19, 0x4d, 0xb2, 0xf2, 0xec, 0x41,
	0x2d, 0x7b, 0x51, 0x2f, 0xa5, 0xa4, 0x2a, 0x17, 0xad, 0x7f, 0x4d, 0xab, 0x26, 0xe0, 0x5a, 0x4a,
	0xca, 0x2c, 0x59, 0x86, 0xef, 0x24, 0xf1, 0x2d, 0x87, 0xc4, 0xa9, 0xb7, 0xe7, 0x39, 0x76, 0x4a,
	0x8a, 0x8d, 0xa4, 0x70, 0x93, 0x2b, 0x14, 0xba, 0xb0, 0x99, 0x7a, 0x12, 0xdc, 0x4d, 0x12, 0xff,
	0x7a, 0x81, 0xdd, 0x70, 0x2f, 0x7d, 0xc7, 0x80, 0x0b, 0xda, 0x5e, 0x3f, 0x33, 0x8a, 0xe8, 0x3f,
	0x35, 0x60, 0x51, 0xea, 0x7f, 0x64, 0xc1, 0x82, 0xc8, 0x2d, 0x5b, 0xbe, 0x68, 0xcd, 0x83, 0x0d,
	0xcb, 0xb8, 0xba, 0x44, 0xb5, 0xca, 0x05, 0x42, 0x47, 0x20, 0xd8, 0xdd, 0xc1, 0x97, 0xe1, 0x7c,
	0x46, 0xe7, 0x8c, 0x93, 0x34, 0x1c, 0x59, 0x8e, 0xe7, 0xc6, 0x62, 0xa3, 0xcc, 0xd3, 0xb0, 0x69,
	0x48, 0x6a, 0xc5, 0xe9, 0x69, 0xf0, 0x39, 0x81, 0xbf, 0xce, 0xd0, 0xd7, 0x3d, 0x37, 0xa6, 0xba,
	0x96, 0x94, 0xda, 0xd6, 0x94, 0x75, 0x2d, 0x99, 0xd2, 0x34, 0x3d, 0x0e, 0x03, 0xc9, 0x1b, 0x66,
	0xfe, 0x76, 0x13, 0x90, 0xaa, 0xec, 0xe8, 0xe4, 0x23, 0x23, 0x2f, 0xb5, 0x72, 0x4b, 0x78, 0xe4,
	0x05, 0x59, 0x98, 0x5e, 0x3e, 0xf9, 0x54, 0x0a, 0x4d, 0xba, 0xd3, 0x29, 0x24, 0xb8, 0x4b, 0xd1,
	0x1b, 0x02, 0xfb, 0xb6, 0x17, 0x24, 0x68, 0x13, 0xe6, 0x78, 0x7a, 0x77, 0x57, 0xa4, 0xa4, 0x28,
	0x3d, 0xc7, 0x67, 0xe0, 0x9a, 0xac, 0xf1, 0xf2, 0x23, 0x1f, 0x01, 0x63, 0xee, 0x8a, 0x4f, 0x59,
	0xbb, 0x63, 0xe7, 0x80, 0xa4, 0xe5, 0xce, 0x2b, 0xdc, 0x15, 0x12, 0x56, 0x5d, 0x3a, 0x75, 0x68,
	0xbc, 0x90, 0x7c, 0x6a, 0x8d, 0x61, 0xd8, 0xec, 0x08, 0xa0, 0x5b, 0x90, 0x46, 0x31, 0xd9, 0xf3,
	0x1e, 0x88, 0xfb, 0xac, 0xe2, 0x96, 0xa7, 0x82, 0x9f, 0x22, 0x4b, 0x21, 0xc0, 0x4b, 0x99, 0xb4,
	0x01, 0x43, 0x99, 0xdf, 0x68, 0xc1, 0x92, 0xbc, 0x25, 0xa0, 0x04, 0xce, 0x71, 0xc5, 0x3e, 0x29,
	0x3d, 0x5b, 0x33, 0x64, 0x4d, 0xae, 0x10, 0xd4, 0xec, 0x19, 0x93, 0x9a, 0x67, 0x6b, 0x02, 0x5b,
	0x3c, 0x5b, 0x53, 0xa2, 0xa8, 0x1b, 0x4f, 0x21, 0x8a, 0xfa, 0x26, 0xcc, 0xa6, 0x76, 0x3c, 0x24,
	0xa9, 0x18, 0xbc, 0xfc, 0x78, 0xca, 0xa1, 0xaa, 0x25, 0x50, 0x05, 0x63, 0x51, 0x9e, 0xbd, 0x0a,
	0x2d, 0x6f, 0x74, 0xfc, 0x58, 0x58, 0xbc, 0x0a, 0x9d, 0xb6, 0xc7, 0xd5, 0x6d, 0x6f, 0x9d, 0xb4,
	0xb4, 0xb5, 0x7d, 0x00, 0xe7, 0xc7, 0x81, 0x3a, 0x0c, 0x33, 0x4c, 0x4e, 0xae, 0x25, 0x34, 0x24,
	0xea, 0x1b, 0x90, 0xa9, 0x34, 0x18, 0xe5, 0xf8, 0x7c, 0x30, 0xcc, 0x19, 0x68, 0xde, 0x70, 0x22,
	0xf3, 0x5b, 0x9d, 0xda, 0xdb, 0x19, 0xe1, 0xd0, 0x58, 0x87, 0x99, 0x68, 0xdf, 0x4e, 0x94, 0xcc,
	0x6c, 0x0c, 0xa8, 0x1a, 0xdb, 0x15, 0x28, 0xe6, 0x85, 0xd1, 0x04, 0x16, 0xb8, 0x1d, 0x2e, 0x7d,
	0x6b, 0xb6, 0xa7, 0x46, 0xc7, 0x89, 0x2f, 0xcb, 0x16, 0x09, 0x0c, 0x4a, 0xa5, 0x6a, 0x4c, 0x7b,
	0xf5, 0x2b, 0xb3, 0xdc, 0xb2, 0x17, 0x0d, 0x28, 0x79, 0x07, 0x67, 0x9f, 0x96, 0x77, 0xf0, 0x43,
	0x03, 0x80, 0x9e, 0xef, 0xbd, 0x72, 0xf4, 0xe4, 0x4f, 0x3e, 0xe2, 0x77, 0xea, 0x78, 0xa9, 0xd2,
	0x67, 0x4e, 0x73, 0x46, 0x3a, 0xef, 0xba, 0x8a, 0xc2, 0x25, 0xd1, 0xe8, 0x97, 0x0c, 0x58, 0xf6,
	0x6d, 0x9e, 0xfe, 0x71, 0x97, 0xdb, 0x59, 0xc2, 0xf3, 0x7c, 0xe5, 0x11, 0xbf, 0x89, 0xec, 0x8d,
	0x4a, 0xd9, 0xd4, 0x2a, 0xac, 0x34, 0x8f, 0x65, 0xea, 0xf0, 0x78, 0x91, 0xe2, 0x98, 0xcf, 0x88,
	0xb2, 0x44, 0xff, 0xca, 0x80, 0x67, 0x19, 0x75, 0x1a, 0xdb, 0x41, 0xc2, 0x6a, 0xcb, 0x6b, 0x37,
	0xff, 0xd8, 0xb5, 0xcb, 0x5d, 0xe4, 0x3a, 0x7e, 0xfa, 0x2a, 0xd6, 0x13, 0x61, 0x44, 0x09, 0x76,
	0x72, 0x3c, 0xab, 0xec, 0x26, 0xcc, 0x25, 0xe3, 0xd1, 0xc8, 0x8e, 0x27, 0xcc, 0x65, 0x5d, 0x7a,
	0x3d, 0x2a, 0xc0, 0x9a, 0x77, 0xc3, 0x55, 0x38, 0xce, 0x58, 0x4c, 0xf3, 0xe8, 0x75, 0x3e, 0x42,
	0x8f, 0x1e, 0xab, 0x07, 0xfb, 0x10, 0x0f, 0x19, 0x45, 0x3e, 0xfb, 0xb0, 0x53, 0x44, 0x1c, 0xcb,
	0xf5, 0xf6, 0xf6, 0x58, 0xfa, 0xb5, 0x79, 0x39, 0xfb, 0x98, 0x4a, 0xa5, 0xff, 0xaa, 0xcf, 0x34,
	0x32, 0x96, 0x7d, 0x6c, 0x47, 0x50, 0x6c, 0x47, 0xc4, 0x59, 0xf7, 0xf6, 0xf6, 0xd0, 0xb7, 0x0c,
	0x38, 0x5f, 0xfe, 0x14, 0x61, 0xa6, 0x14, 0x16, 0x35, 0xe1, 0xe3, 0x8a, 0x87, 0xb5, 0xd0, 0x8c,
	0x1a, 0x16, 0x53, 0xbf, 0x78, 0xa8, 0x51, 0x14, 0xe7, 0xf6, 0xab, 0xec, 0xcd, 0xfb, 0xb0, 0x94,
	0x29, 0x40, 0x31, 0x7c, 0x5d, 0x58, 0x18, 0xe0, 0xdb, 0xef, 0x6c, 0x6c, 0x6f, 0xdc, 0xde, 0xda,
	0xd8, 0xba, 0xd1, 0x7d, 0x06, 0x2d, 0x40, 0x7b, 0xbd, 0xbf, 0xd9, 0xdf, 0xa1, 0xff, 0x0c, 0xd4,
	0x81, 0x39, 0xf6, 0xaf, 0xbf, 0xde, 0x6d, 0xd0, 0x3f, 0x77, 0xb6, 0x6e, 0x6d, 0xdd, 0xbe, 0xbb,
	0xd5, 0x6d, 0xa2, 0x59, 0x68, 0xdc, 0x19, 0x74, 0x5b, 0xa8, 0x0d, 0xad, 0x75, 0x0a, 0x99, 0xe1,
	0x25, 0x6f, 0xe0, 0x6b, 0xeb, 0xfd, 0xf5, 0xee, 0x2c, 0x25, 0x5e, 0xdb, 0xbc, 0x7d, 0xfd, 0x56,
	0x7f, 0xbd, 0x3b, 0xc7, 0x9f, 0x90, 0xf0, 0x3c, 0x5f, 0x6f, 0xb5, 0xda, 0x33, 0xdd, 0x59, 0xf3,
	0x77, 0x66, 0xe1, 0xf2, 0xc3, 0xd4, 0xc6, 0x29, 0x24, 0x9e, 0xbd, 0x99, 0x7f, 0x01, 0xbc, 0x12,
	0xa7, 0xf4, 0xd8, 0x5f, 0xf5, 0xd6, 0x29, 0x9f, 0xe6, 0x99, 0x56, 0x3e, 0xad, 0xb3, 0xa9, 0x7c,
	0x46, 0x24, 0x49, 0xec, 0x61, 0xf6, 0xac, 0xaa, 0x74, 0xe7, 0xc9, 0xc0, 0x9a, 0x3b, 0xcf, 0x2a,
	0x1c, 0x67, 0x2c, 0xe8, 0xe8, 0xc6, 0xc4, 0x4e, 0xc4, 0xee, 0x57, 0x1a, 0x5d, 0x0e, 0xd5, 0xe5,
	0xc7, 0x4c, 0x2a, 0xdf, 0x1a, 0xe7, 0x20, 0xf4, 0x2f, 0x0d, 0x28, 0x05, 0xd6, 0xb2, 0xb4, 0x83,
	0xe2, 0x1a, 0xf5, 0xa7, 0x1f, 0x6b, 0xa7, 0x2b, 0xee, 0x77, 0x36, 0x82, 0xbd, 0xb0, 0x18, 0xee,
	0x0a, 0xef, 0x69, 0x17, 0x60, 0x15, 0x3c, 0x5e, 0xb2, 0x25, 0x9e, 0xe6, 0xaf, 0x35, 0xe1, 0x31,
	0xab, 0x81, 0x7e, 0xc3, 0x80, 0xc5, 0x38, 0xf4, 0x7d, 0x3a, 0xa1, 0xb2, 0xcf, 0x9d, 0xd0, 0xb6,
	0xdd, 0x3c, 0x41, 0xdb, 0x56, 0x71, 0xe8, 0xfb, 0x03, 0xc1, 0xaf, 0x30, 0x74, 0x25, 0x31, 0xba,
	0x8c, 0xc8, 0x5a, 0x2c, 0x5e, 0x88, 0x4b, 0xdc, 0x2e, 0xfd, 0xd0, 0x80, 0x85, 0x32, 0x7b, 0xfe,
	0xa5, 0x12, 0x37, 0x11, 0x09, 0xed, 0x5d, 0x91, 0x1d, 0xa5, 0x9c, 0x09, 0x2a, 0xc7, 0x69, 0x1f,
	0x85, 0x68, 0x90, 0x2c, 0x13, 0x54, 0xc2, 0x33, 0xe0, 0xbb, 0xe8, 0x2e, 0x40, 0x1a, 0xa6, 0xfc,
	0xfa, 0x31, 0xcb, 0x57, 0x52, 0xc4, 0x7a, 0xe5, 0x18, 0x4d, 0x8a, 0x14, 0x0d, 0x0a, 0xcf, 0x33,
	0xf0, 0x20, 0x74, 0x13, 0xf3, 0x3f, 0x36, 0xe0, 0x6a, 0x4d, 0xc7, 0x96, 0xd4, 0xbf, 0x6c, 0x96,
	0x7e, 0x68, 0x14, 0x5b, 0x34, 0x0f, 0x85, 0xfc, 0xa9, 0x47, 0x19, 0x28, 0x5e, 0x7a, 0x55, 0xd6,
	0xf0, 0x27, 0xdb, 0xdd, 0x2b, 0xb6, 0x5f, 0xe3, 0xcf, 0xcc, 0xf6, 0x33, 0xbf, 0xd6, 0x80, 0x4e,
	0xc9, 0x88, 0x3e, 0x25, 0xd3, 0xbd, 0x50, 0x20, 0x8d, 0x13, 0x2a, 0x10, 0x1f, 0x5a, 0x4f, 0xb8,
	0x25, 0x14, 0xdb, 0x9a, 0x4e, 0xc9, 0x56, 0x95, 0x2a, 0x93, 0x62, 0xfe, 0xd3, 0x06, 0x2c, 0x0d,
	0xc2, 0x24, 0xa5, 0x8b, 0x44, 0xf8, 0x29, 0x4a, 0xfe, 0x02, 0xe3, 0xe4, 0xfe, 0x82, 0xbf, 0x65,
	0x40, 0xe7, 0xd0, 0xf6, 0x3d, 0xb7, 0xf4, 0x01, 0x92, 0xa5, 0x8a, 0x53, 0x52, 0xae, 0xc0, 0xea,
	0x3b, 0x39, 0x79, 0xe1, 0x92, 0x29, 0xb1, 0xd0, 0xf9, 0xb5, 0x34, 0x38, 0x5c, 0x16, 0x6b, 0xfe,
	0x14, 0x40, 0xc1, 0x96, 0x1a, 0x2b, 0x6b, 0xf8, 0xf6, 0xad, 0x3e, 0xb6, 0xb6, 0x77, 0xae, 0xed,
	0xf4, 0xbb, 0xcf, 0xa0, 0xe7, 0xe1, 0xc2, 0x56, 0x7f, 0xe7, 0xee, 0x6d, 0x7c, 0xcb, 0xba, 0xd9,
	0xbf, 0xb6, 0xb9, 0x73, 0x93, 0x61, 0xee, 0x6c, 0x77, 0x0d, 0xf3, 0x7f, 0x37, 0xa0, 0x57, 0xf7,
	0x71, 0x3b, 0x96, 0xbd, 0x21, 0xcb, 0xf3, 0x50, 0x78, 0x5e, 0x0d, 0x4d, 0xf6, 0x86, 0xec, 0x61,
	0x77, 0xe6, 0xff, 0x2b, 0x07, 0xc8, 0x56, 0xca, 0x6b, 0x3a, 0xb8, 0x9e, 0x02, 0x77, 0x49, 0x85,
	0x33, 0xda, 0x2b, 0xbe, 0x46, 0xd5, 0xd0, 0x7c, 0x23, 0xf3, 0xd4, 0xbe, 0x39, 0x65, 0xe7, 0xdf,
	0x9c, 0x6a, 0x6a, 0xde, 0x0b, 0x9f, 0xc6, 0x97, 0xa5, 0xcc, 0x7f, 0xdf, 0x80, 0x6e, 0xb5, 0xe7,
	0xd0, 0xdf, 0x37, 0x60, 0x61, 0x64, 0xa7, 0xce, 0x7e, 0x16, 0x5d, 0xa2, 0xcb, 0xb3, 0x50, 0x2d,
	0xb5, 0xfa, 0x36, 0x2d, 0x51, 0x0e, 0x2d, 0x29, 0x1e, 0x4e, 0x97, 0x78, 0xa9, 0x66, 0x83, 0x1e,
	0x89, 0x3b, 0xa3, 0x82, 0x1f, 0xbb, 0x64, 0xaa, 0xf2, 0x3f, 0x33, 0xbe, 0xdd, 0x3f, 0x35, 0xa0,
	0x53, 0x1a, 0x73, 0xf4, 0xb7, 0x0d, 0x58, 0xda, 0x8b, 0xc3, 0x51, 0x29, 0xff, 0x09, 0xef, 0xc0,
	0x87, 0x4c, 0xd8, 0xdc, 0xc5, 0x27, 0x17, 0x56, 0x13, 0x35, 0xd5, 0xa1, 0xf1, 0x22, 0x45, 0x15,
	0x19, 0x0e, 0xf6, 0xa0, 0x9d, 0x86, 0x56, 0x39, 0xcd, 0xcb, 0x05, 0x25, 0xcd, 0x0b, 0x9b, 0x3f,
	0xc5, 0x5d, 0x55, 0x58, 0xf3, 0xd0, 0x49, 0x83, 0xc0, 0x73, 0x69, 0xc8, 0x1e, 0x36, 0x99, 0x7f,
	0x6c, 0x00, 0x14, 0xb3, 0x11, 0xbd, 0xcf, 0xc4, 0xee, 0x7d, 0xc9, 0xcd, 0x33, 0x74, 0xc8, 0x01,
	0x84, 0x6f, 0xfe, 0xcc, 0xfa, 0x56, 0xde, 0xe8, 0xb2, 0x68, 0x56, 0x44, 0x27, 0xba, 0x8a, 0xa0,
	0xa2, 0xdf, 0xa4, 0xb0, 0x8f, 0xac, 0x89, 0x7f, 0x60, 0xc0, 0x42, 0xb9, 0xde, 0xec, 0x53, 0x66,
	0x6c, 0xe6, 0x96, 0x9c, 0xf7, 0xc5, 0xa7, 0xcc, 0x72, 0x4c, 0xcd, 0x74, 0xaf, 0xfa, 0x66, 0xe7,
	0x19, 0x98, 0x39, 0x66, 0x1d, 0x58, 0xe4, 0x34, 0x91, 0x9d, 0xa6, 0x24, 0xce, 0x36, 0xbc, 0xdc,
	0x6e, 0x93, 0x90, 0x35, 0xec, 0x55, 0x2c, 0xe6, 0x0b, 0x7a, 0xc0, 0x11, 0xe6, 0x01, 0xb4, 0xb3,
	0x9e, 0x41, 0x96, 0xfc, 0xb8, 0xfc, 0x79, 0xa5, 0xff, 0x06, 0x22, 0x34, 0xfb, 0x09, 0xdf, 0x94,
	0x9b, 0xdf, 0x35, 0x60, 0xa1, 0xcc, 0x47, 0x4a, 0xcb, 0x34, 0x7f, 0xe2, 0xb0, 0xf3, 0xc6, 0x69,
	0x84, 0x9d, 0x5f, 0xf9, 0x8b, 0x80, 0xd4, 0x8f, 0x45, 0x21, 0x04, 0x4b, 0xf8, 0xf6, 0xe6, 0xe6,
	0xc6, 0xd6, 0x0d, 0xeb, 0xce, 0x60, 0x9d, 0x6f, 0x65, 0x8b, 0x30, 0x7f, 0x7b, 0xcb, 0xe2, 0x87,
	0xed, 0xae, 0x71, 0xe5, 0x33, 0xec, 0xf3, 0x97, 0xca, 0x67, 0xbe, 0x17, 0xa0, 0x3d, 0xb8, 0x86,
	0xaf, 0x6d, 0x6e, 0xf6, 0x37, 0xbb, 0xcf, 0xa0, 0x73, 0xb0, 0x78, 0x1b, 0xaf, 0xf7, 0x71, 0x7f,
	0xdd, 0xc2, 0xfd, 0x6b, 0xeb, 0x7f, 0xb9, 0x6b, 0x5c, 0xf9, 0xf3, 0xb0, 0x50, 0x4e, 0x8d, 0x49,
	0xd9, 0x0e, 0x70, 0xff, 0xcd, 0x3e, 0xc6, 0xfd, 0x75, 0x7e, 0xba, 0xc7, 0xfd, 0x9f, 0xb9, 0xb3,
	0x41, 0xff, 0x19, 0x57, 0x3e, 0x80, 0x4e, 0xe9, 0x59, 0x0d, 0xba, 0x00, 0xe7, 0xb6, 0x77, 0xae,
	0x6d, 0xad, 0x5f, 0xc3, 0xeb, 0xd6, 0xdb, 0xd7, 0x6e, 0x6c, 0xf5, 0x77, 0x36, 0xae, 0x77, 0x9f,
	0xa1, 0xdb, 0x6e, 0x0e, 0xde, 0xde, 0x5e, 0xef, 0x1a, 0x54, 0xee, 0xf6, 0xe6, 0xed, 0xbb, 0x05,
	0x51, 0x83, 0x3b, 0x0a, 0xde, 0xbc, 0x76, 0x67, 0x73, 0xa7, 0xdb, 0xa4, 0x25, 0xb6, 0xfa, 0xf7,
	0x76, 0xac, 0x1b, 0xfd, 0x2d, 0x56, 0xa2, 0x45, 0x4b, 0xdc, 0xdc, 0xb8, 0x71, 0xd3, 0xda, 0xb8,
	0x3d, 0xd8, 0x66, 0xa0, 0x99, 0x2b, 0x2f, 0x0b, 0x83, 0x8e, 0x5f, 0xb8, 0x50, 0x06, 0x03, 0xbc,
	0xf1, 0x0e, 0xef, 0x0c, 0x80, 0xd9, 0xc1, 0x9d, 0xb5, 0xcd, 0x8d, 0xeb, 0x5d, 0x63, 0xed, 0xab,
	0xc6, 0x0f, 0x7f, 0xf4, 0x92, 0xf1, 0x87, 0x3f, 0x7a, 0xc9, 0xf8, 0xe3, 0x1f, 0xbd, 0x64, 0xc0,
	0x9f, 0xf3, 0xc2, 0x55, 0x27, 0x0c, 0xf6, 0xfc, 0x31, 0x09, 0xd2, 0x55, 0xf6, 0x1a, 0x7a, 0x95,
	0x75, 0xf7, 0xee, 0x78, 0xaf, 0x3c, 0xc7, 0xd6, 0x5e, 0xac, 0xb1, 0x4c, 0xd9, 0x7c, 0x19, 0x18,
	0xef, 0xbe, 0x36, 0xf4, 0xd2, 0xfd, 0xf1, 0xee, 0xaa, 0x13, 0x8e, 0xae, 0xe6, 0x0c, 0xbd, 0xc0,
	0xb9, 0xea, 0x38, 0x3f, 0x99, 0xa4, 0xf1, 0xd8, 0x49, 0x93, 0xab, 0x19, 0xbf, 0xab, 0x87, 0xaf,
	0xfd, 0xf4, 0xe1, 0x6b, 0xbb, 0xb3, 0x4c, 0xd0, 0xa7, 0xfe, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x54, 0xc1, 0x29, 0x77, 0x46, 0x90, 0x00, 0x00,
}

func (m *PhysicalStatefulClusterList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.TypeMeta.Size()))
		n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ListMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.ListMeta.Size()))
		n2, err := m.ListMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.TypeMeta.Size()))
		n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ObjectMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.ObjectMeta.Size()))
		n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Status.Size()))
		n5, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Spec != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Spec.Size()))
		n6, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Common != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Common.Size()))
		n7, err := m.Common.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Cloud != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Cloud.Size()))
		n8, err := m.Cloud.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Policy != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Policy.Size()))
		n9, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.ClusterId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.ClusterId)))
		i += copy(dAtA[i:], m.ClusterId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulClusterPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExternalSlaInEffect {
		dAtA[i] = 0x8
		i++
		if m.ExternalSlaInEffect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Plugin) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Plugin)))
		i += copy(dAtA[i:], m.Plugin)
	}
	if len(m.Psc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Psc)))
		i += copy(dAtA[i:], m.Psc)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodInfoExportPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodInfoExportPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HostIp {
		dAtA[i] = 0x8
		i++
		if m.HostIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PodNamespace {
		dAtA[i] = 0x10
		i++
		if m.PodNamespace {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MountedSecret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountedSecret) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SecretRef) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.SecretRef)))
		i += copy(dAtA[i:], m.SecretRef)
	}
	if len(m.KeyItems) > 0 {
		for _, msg := range m.KeyItems {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulClusterCommonSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterCommonSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Container != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Container.Size()))
		n10, err := m.Container.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Replicas != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Replicas))
	}
	if m.Resources != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Resources.Size()))
		n11, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Placement) > 0 {
		for k, _ := range m.Placement {
			dAtA[i] = 0x22
			i++
			v := m.Placement[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPhysicalstatefulcluster(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + msgSize
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	if m.Network != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Network.Size()))
		n13, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Config != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Config.Size()))
		n14, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Logs) > 0 {
		for k, _ := range m.Logs {
			dAtA[i] = 0x4a
			i++
			v := m.Logs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPhysicalstatefulcluster(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + msgSize
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(v.Size()))
				n15, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n15
			}
		}
	}
	if len(m.HealthChecks) > 0 {
		for _, msg := range m.HealthChecks {
			dAtA[i] = 0x52
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ingress != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Ingress.Size()))
		n16, err := m.Ingress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Metrics != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Metrics.Size()))
		n17, err := m.Metrics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Version != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Version.Size()))
		n18, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.MinimumReplicas != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.MinimumReplicas))
	}
	if m.ClusterDeletionHandler != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.ClusterDeletionHandler.Size()))
		n19, err := m.ClusterDeletionHandler.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.PodSecurityContext != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.PodSecurityContext.Size()))
		n20, err := m.PodSecurityContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.PodAnnotations) > 0 {
		for k, _ := range m.PodAnnotations {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.PodAnnotations[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.InitContainers) > 0 {
		for _, msg := range m.InitContainers {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PodManagementPolicy != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.PodManagementPolicy))
	}
	if m.Affinity != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Affinity.Size()))
		n21, err := m.Affinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.SkipHostPort {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.SkipHostPort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpdateStrategy != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.UpdateStrategy.Size()))
		n22, err := m.UpdateStrategy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.PscAnnotations) > 0 {
		for k, _ := range m.PscAnnotations {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			v := m.PscAnnotations[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.ServiceAccount != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.ServiceAccount.Size()))
		n23, err := m.ServiceAccount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.ExtraVolumes) > 0 {
		for _, msg := range m.ExtraVolumes {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PodTolerations) > 0 {
		for _, msg := range m.PodTolerations {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NetworkPolicy != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.NetworkPolicy.Size()))
		n24, err := m.NetworkPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.AdditionalPodLabels) > 0 {
		for k, _ := range m.AdditionalPodLabels {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x1
			i++
			v := m.AdditionalPodLabels[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.RuntimeClassName) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.RuntimeClassName)))
		i += copy(dAtA[i:], m.RuntimeClassName)
	}
	if m.EnableBrokerRackZoneIds {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		if m.EnableBrokerRackZoneIds {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CniNetworkPolicy != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.CniNetworkPolicy.Size()))
		n25, err := m.CniNetworkPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.AutoMountServiceAccountToken != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.AutoMountServiceAccountToken.Size()))
		n26, err := m.AutoMountServiceAccountToken.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BooleanType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BooleanType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value {
		dAtA[i] = 0x8
		i++
		if m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NetworkPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, msg := range m.Ingress {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Egress) > 0 {
		for _, msg := range m.Egress {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PolicyTypes) > 0 {
		for _, s := range m.PolicyTypes {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtraVolume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtraVolume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.HostPath)))
		i += copy(dAtA[i:], m.HostPath)
	}
	if len(m.MountPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.MountPath)))
		i += copy(dAtA[i:], m.MountPath)
	}
	if m.Attachable {
		dAtA[i] = 0x18
		i++
		if m.Attachable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AttachToInitContainers) > 0 {
		for _, s := range m.AttachToInitContainers {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.EmptyDirVolume != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.EmptyDirVolume.Size()))
		n27, err := m.EmptyDirVolume.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.HostPathVolume != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.HostPathVolume.Size()))
		n28, err := m.HostPathVolume.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServiceAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Annotations) > 0 {
		for k, _ := range m.Annotations {
			dAtA[i] = 0x12
			i++
			v := m.Annotations[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Apply {
		dAtA[i] = 0x18
		i++
		if m.Apply {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStrategy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Type))
	}
	if m.ReplicasToNotUpdate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.ReplicasToNotUpdate))
	}
	if m.Pause {
		dAtA[i] = 0x18
		i++
		if m.Pause {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Abort {
		dAtA[i] = 0x20
		i++
		if m.Abort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodSecurityContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodSecurityContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FsGroup != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.FsGroup))
	}
	if m.RunAsGroup != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.RunAsGroup))
	}
	if m.RunAsNonRoot {
		dAtA[i] = 0x18
		i++
		if m.RunAsNonRoot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RunAsUser != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.RunAsUser))
	}
	if m.SelinuxOptions != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.SelinuxOptions.Size()))
		n29, err := m.SelinuxOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.SupplementalGroups) > 0 {
		dAtA31 := make([]byte, len(m.SupplementalGroups)*10)
		var j30 int
		for _, num1 := range m.SupplementalGroups {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(j30))
		i += copy(dAtA[i:], dAtA31[:j30])
	}
	if len(m.Systls) > 0 {
		for _, msg := range m.Systls {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SeccompProfile != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.SeccompProfile.Size()))
		n32, err := m.SeccompProfile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SeccompProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeccompProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.LocalhostProfile) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.LocalhostProfile)))
		i += copy(dAtA[i:], m.LocalhostProfile)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SELinuxOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SELinuxOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Level) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Level)))
		i += copy(dAtA[i:], m.Level)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Sysctl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sysctl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClusterDeletionHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterDeletionHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExecCommand) > 0 {
		for _, s := range m.ExecCommand {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pods) > 0 {
		for _, s := range m.Pods {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Image) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TerminationGracePeriodSeconds != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.TerminationGracePeriodSeconds))
	}
	if m.PreStopHandler != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.PreStopHandler.Size()))
		n33, err := m.PreStopHandler.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.ReadinessProbe != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.ReadinessProbe.Size()))
		n34, err := m.ReadinessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.LivenessProbe != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.LivenessProbe.Size()))
		n35, err := m.LivenessProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if len(m.EnvVar) > 0 {
		for k, _ := range m.EnvVar {
			dAtA[i] = 0x52
			i++
			v := m.EnvVar[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ServiceAccount) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.ServiceAccount)))
		i += copy(dAtA[i:], m.ServiceAccount)
	}
	if m.NodeAffinity != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.NodeAffinity.Size()))
		n36, err := m.NodeAffinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Rack != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Rack.Size()))
		n37, err := m.Rack.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.PodInfoExportPolicy != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.PodInfoExportPolicy.Size()))
		n38, err := m.PodInfoExportPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if len(m.MountedSecrets) > 0 {
		for _, msg := range m.MountedSecrets {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SecurityContext != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.SecurityContext.Size()))
		n39, err := m.SecurityContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecurityContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RunAsGroup != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.RunAsGroup))
	}
	if m.RunAsNonRoot {
		dAtA[i] = 0x10
		i++
		if m.RunAsNonRoot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RunAsUser != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.RunAsUser))
	}
	if m.Privileged {
		dAtA[i] = 0x20
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AllowPrivilegeEscalation {
		dAtA[i] = 0x28
		i++
		if m.AllowPrivilegeEscalation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InitContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitContainer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EnvVar) > 0 {
		for k, _ := range m.EnvVar {
			dAtA[i] = 0x2a
			i++
			v := m.EnvVar[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Resources != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Resources.Size()))
		n40, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.SecurityContext != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.SecurityContext.Size()))
		n41, err := m.SecurityContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Affinity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Affinity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeAffinity != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.NodeAffinity.Size()))
		n42, err := m.NodeAffinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.PodAffinity != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.PodAffinity.Size()))
		n43, err := m.PodAffinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.PodAntiAffinity != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.PodAntiAffinity.Size()))
		n44, err := m.PodAntiAffinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeAffinity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAffinity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Rule != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Rule))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodLevelAffinity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodLevelAffinity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rule != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Rule))
	}
	if len(m.Terms) > 0 {
		for _, msg := range m.Terms {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodLevelAffinityTerm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodLevelAffinityTerm) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Namespaces) > 0 {
		for _, s := range m.Namespaces {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TopologyKey != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.TopologyKey.Size()))
		n45, err := m.TopologyKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Weight != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Weight.Size()))
		n46, err := m.Weight.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopologyKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopologyKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Weight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Weight) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Weight != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Weight))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Rack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rack) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TopologyKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.TopologyKey)))
		i += copy(dAtA[i:], m.TopologyKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Probe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Probe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InitialDelaySeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.InitialDelaySeconds))
	}
	if m.TimeoutSeconds != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.TimeoutSeconds))
	}
	if m.PeriodSeconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.PeriodSeconds))
	}
	if m.SuccessThreshold != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.SuccessThreshold))
	}
	if m.FailureThreshold != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.FailureThreshold))
	}
	if m.Exec != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Exec.Size()))
		n47, err := m.Exec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.Http != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Http.Size()))
		n48, err := m.Http.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.Tcp != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Tcp.Size()))
		n49, err := m.Tcp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HTTPHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Scheme != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Scheme))
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Port))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TCPHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PreStopHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreStopHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExecCommand) > 0 {
		for _, s := range m.ExecCommand {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Proxy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Proxy.Size()))
		n50, err := m.Proxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ClientEndpoints != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.ClientEndpoints.Size()))
		n51, err := m.ClientEndpoints.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.DiscoveryService != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.DiscoveryService.Size()))
		n52, err := m.DiscoveryService.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if len(m.ServiceType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.ServiceType)))
		i += copy(dAtA[i:], m.ServiceType)
	}
	if m.UseDefaultResolverForHealthcheck {
		dAtA[i] = 0x30
		i++
		if m.UseDefaultResolverForHealthcheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DiscoveryService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveryService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for k, _ := range m.Annotations {
			dAtA[i] = 0xa
			i++
			v := m.Annotations[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x12
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientEndpoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientEndpoints) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.External) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.External)))
		i += copy(dAtA[i:], m.External)
	}
	if len(m.Internal) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Internal)))
		i += copy(dAtA[i:], m.Internal)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IntervalSecs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.IntervalSecs))
	}
	if m.RetentionMonths != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.RetentionMonths))
	}
	if m.Port != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Port))
	}
	if len(m.Scheme) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if len(m.MetricsPath) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.MetricsPath)))
		i += copy(dAtA[i:], m.MetricsPath)
	}
	if len(m.Sinks) > 0 {
		for _, msg := range m.Sinks {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MetricSink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricSink) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Blacklist) > 0 {
		for _, s := range m.Blacklist {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Whitelist) > 0 {
		for _, s := range m.Whitelist {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Deltalist) > 0 {
		for _, s := range m.Deltalist {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Logs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Logs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RetentionMonths != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.RetentionMonths))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyPorts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyPorts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for k, _ := range m.Ports {
			dAtA[i] = 0xa
			i++
			v := m.Ports[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPhysicalstatefulcluster(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + msgSize
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(v.Size()))
				n53, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n53
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Proxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proxy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for k, _ := range m.Routes {
			dAtA[i] = 0xa
			i++
			v := m.Routes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPhysicalstatefulcluster(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + msgSize
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(v.Size()))
				n54, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n54
			}
		}
	}
	if m.Ssl {
		dAtA[i] = 0x18
		i++
		if m.Ssl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Internal {
		dAtA[i] = 0x20
		i++
		if m.Internal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Bootstrap != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Bootstrap.Size()))
		n55, err := m.Bootstrap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if len(m.Pods) > 0 {
		for _, msg := range m.Pods {
			dAtA[i] = 0x32
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Annotations) > 0 {
		for k, _ := range m.Annotations {
			dAtA[i] = 0x3a
			i++
			v := m.Annotations[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.CCloudManagedLb {
		dAtA[i] = 0x40
		i++
		if m.CCloudManagedLb {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyPods) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyPods) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Dns) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Dns)))
		i += copy(dAtA[i:], m.Dns)
	}
	if m.NodePort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.NodePort))
	}
	if m.Port != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Bootstrap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bootstrap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dns) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Dns)))
		i += copy(dAtA[i:], m.Dns)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Port))
	}
	if m.NodePort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.NodePort))
	}
	if len(m.AdditionalPorts) > 0 {
		for _, msg := range m.AdditionalPorts {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ExternalTrafficPolicy) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.ExternalTrafficPolicy)))
		i += copy(dAtA[i:], m.ExternalTrafficPolicy)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BootstrapPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BootstrapPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InternalPortName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.InternalPortName)))
		i += copy(dAtA[i:], m.InternalPortName)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Port))
	}
	if m.NodePort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.NodePort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.External != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.External))
	}
	if m.Internal != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Internal))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodResources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodResources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cpu) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Cpu)))
		i += copy(dAtA[i:], m.Cpu)
	}
	if len(m.Memory) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Memory)))
		i += copy(dAtA[i:], m.Memory)
	}
	if len(m.Storage) > 0 {
		for _, msg := range m.Storage {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Requests != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Requests.Size()))
		n56, err := m.Requests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.Limits != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Limits.Size()))
		n57, err := m.Limits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cpu) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Cpu)))
		i += copy(dAtA[i:], m.Cpu)
	}
	if len(m.Memory) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Memory)))
		i += copy(dAtA[i:], m.Memory)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Storage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Storage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Type))
	}
	if len(m.Capacity) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Capacity)))
		i += copy(dAtA[i:], m.Capacity)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.StorageClassName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.StorageClassName)))
		i += copy(dAtA[i:], m.StorageClassName)
	}
	if len(m.EncryptionKeyId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.EncryptionKeyId)))
		i += copy(dAtA[i:], m.EncryptionKeyId)
	}
	if len(m.StorageClassId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.StorageClassId)))
		i += copy(dAtA[i:], m.StorageClassId)
	}
	if m.Iops != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Iops))
	}
	if m.Throughput != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Throughput))
	}
	if len(m.DiskEncryptionSetId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.DiskEncryptionSetId)))
		i += copy(dAtA[i:], m.DiskEncryptionSetId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Port))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.HostPort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.HostPort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shared) > 0 {
		for _, msg := range m.Shared {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Pod) > 0 {
		for _, msg := range m.Pod {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Init) > 0 {
		for _, msg := range m.Init {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PodConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Config) > 0 {
		for _, msg := range m.Config {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Container != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Container.Size()))
		n58, err := m.Container.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.Resources != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Resources.Size()))
		n59, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.Configuration) > 0 {
		for _, msg := range m.Configuration {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metrics) > 0 {
		for k, _ := range m.Metrics {
			dAtA[i] = 0x32
			i++
			v := m.Metrics[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPhysicalstatefulcluster(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + msgSize
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(v.Size()))
				n60, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n60
			}
		}
	}
	if m.Network != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Network.Size()))
		n61, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.ClusterStatusProbe != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.ClusterStatusProbe.Size()))
		n62, err := m.ClusterStatusProbe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.Affinity != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Affinity.Size()))
		n63, err := m.Affinity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.SkipHostPort {
		dAtA[i] = 0x50
		i++
		if m.SkipHostPort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Version != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Version.Size()))
		n64, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if len(m.AdditionalPodLabels) > 0 {
		for k, _ := range m.AdditionalPodLabels {
			dAtA[i] = 0x62
			i++
			v := m.AdditionalPodLabels[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HealthCheckStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.LowestPodPscVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.LowestPodPscVersion)))
		i += copy(dAtA[i:], m.LowestPodPscVersion)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClusterStatusProbe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatusProbe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Scheme) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Port))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.IntervalSeconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.IntervalSeconds))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ingress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ingress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LoadBalanced {
		dAtA[i] = 0x8
		i++
		if m.LoadBalanced {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cloud) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cloud) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DockerRepo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.DockerRepo)))
		i += copy(dAtA[i:], m.DockerRepo)
	}
	if m.Aws != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Aws.Size()))
		n65, err := m.Aws.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.Gcp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Gcp.Size()))
		n66, err := m.Gcp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.Local != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Local.Size()))
		n67, err := m.Local.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if len(m.K8SClusterId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.K8SClusterId)))
		i += copy(dAtA[i:], m.K8SClusterId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Local) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Local) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Aws) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aws) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vpc) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Vpc)))
		i += copy(dAtA[i:], m.Vpc)
	}
	if len(m.Zones) > 0 {
		for _, s := range m.Zones {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ProxyToZone) > 0 {
		for k, _ := range m.ProxyToZone {
			dAtA[i] = 0x1a
			i++
			v := m.ProxyToZone[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Route53 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Route53.Size()))
		n68, err := m.Route53.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.Elb != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Elb.Size()))
		n69, err := m.Elb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Route53) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route53) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostedZone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.HostedZone)))
		i += copy(dAtA[i:], m.HostedZone)
	}
	if m.TtlSecs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.TtlSecs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Elb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Elb) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccessLogConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.AccessLogConfig.Size()))
		n70, err := m.AccessLogConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.Healthcheck != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Healthcheck.Size()))
		n71, err := m.Healthcheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.IdleTimeoutSecs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.IdleTimeoutSecs))
	}
	if len(m.InstanceSelector) > 0 {
		for k, _ := range m.InstanceSelector {
			dAtA[i] = 0x22
			i++
			v := m.InstanceSelector[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.SecurityGroups != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.SecurityGroups.Size()))
		n72, err := m.SecurityGroups.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if len(m.SslCertificateId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.SslCertificateId)))
		i += copy(dAtA[i:], m.SslCertificateId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SecurityGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IngressName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.IngressName)))
		i += copy(dAtA[i:], m.IngressName)
	}
	if len(m.IngressCustomCidr) > 0 {
		for _, s := range m.IngressCustomCidr {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EgressName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.EgressName)))
		i += copy(dAtA[i:], m.EgressName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ELBAccessLogConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ELBAccessLogConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EmitIntervalMins != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.EmitIntervalMins))
	}
	if m.Enabled {
		dAtA[i] = 0x10
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.S3BucketName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.S3BucketName)))
		i += copy(dAtA[i:], m.S3BucketName)
	}
	if len(m.S3BucketPrefix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.S3BucketPrefix)))
		i += copy(dAtA[i:], m.S3BucketPrefix)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ELBHealthcheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ELBHealthcheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HealthyThreshold != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.HealthyThreshold))
	}
	if m.IntervalSecs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.IntervalSecs))
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.TimeoutSecs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.TimeoutSecs))
	}
	if m.UnhealthyThreshold != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.UnhealthyThreshold))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Gcp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gcp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if m.ProxyStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.ProxyStatus.Size()))
		n73, err := m.ProxyStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if m.Version != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Version.Size()))
		n74, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LastProbeTime != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.LastProbeTime.Size()))
		n75, err := m.LastProbeTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.LastTransitionTime != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.LastTransitionTime.Size()))
		n76, err := m.LastTransitionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	if len(m.LowestPodPscVersion) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.LowestPodPscVersion)))
		i += copy(dAtA[i:], m.LowestPodPscVersion)
	}
	if len(m.PodTemplateSpecDiff) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.PodTemplateSpecDiff)))
		i += copy(dAtA[i:], m.PodTemplateSpecDiff)
	}
	if len(m.HealthCheckStatus) > 0 {
		for _, msg := range m.HealthCheckStatus {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulClusterCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.LastProbeTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.LastProbeTime.Size()))
		n77, err := m.LastProbeTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if m.LastTransitionTime != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.LastTransitionTime.Size()))
		n78, err := m.LastTransitionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.AdditionalInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.AdditionalInfo.Size()))
		n79, err := m.AdditionalInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulClusterConditionAdditionalInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterConditionAdditionalInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RollProgress != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.RollProgress.Size()))
		n80, err := m.RollProgress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PodsUpdated != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.PodsUpdated))
	}
	if m.TotalPods != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.TotalPods))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PhysicalStatefulClusterHealthCheckClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalStatefulClusterHealthCheckClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Summary != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Summary))
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProxyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Phase)))
		i += copy(dAtA[i:], m.Phase)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.Time != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.Time.Size()))
		n81, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PostRollConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostRollConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Validations) > 0 {
		dAtA83 := make([]byte, len(m.Validations)*10)
		var j82 int
		for _, num := range m.Validations {
			for num >= 1<<7 {
				dAtA83[j82] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j82++
			}
			dAtA83[j82] = uint8(num)
			j82++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(j82))
		i += copy(dAtA[i:], dAtA83[:j82])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CNIProviderNetworkPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNIProviderNetworkPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EndpointSelector != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(m.EndpointSelector.Size()))
		n84, err := m.EndpointSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if len(m.Ingress) > 0 {
		for _, msg := range m.Ingress {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Egress) > 0 {
		for _, msg := range m.Egress {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EndpointSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchLabels) > 0 {
		for k, _ := range m.MatchLabels {
			dAtA[i] = 0xa
			i++
			v := m.MatchLabels[k]
			mapSize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngressRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FromEndpoints) > 0 {
		for _, msg := range m.FromEndpoints {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ToPorts) > 0 {
		for _, msg := range m.ToPorts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EgressRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ToFqdns) > 0 {
		for _, msg := range m.ToFqdns {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ToPorts) > 0 {
		for _, msg := range m.ToPorts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FQDNSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FQDNSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.MatchName)))
		i += copy(dAtA[i:], m.MatchName)
	}
	if len(m.MatchPattern) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.MatchPattern)))
		i += copy(dAtA[i:], m.MatchPattern)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PortRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PortProtocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortProtocol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Port) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPhysicalstatefulcluster(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPhysicalstatefulcluster(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PhysicalStatefulClusterList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.ListMeta != nil {
		l = m.ListMeta.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulClusterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Common != nil {
		l = m.Common.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Cloud != nil {
		l = m.Cloud.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulClusterPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalSlaInEffect {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Plugin)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Psc)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodInfoExportPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostIp {
		n += 2
	}
	if m.PodNamespace {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MountedSecret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SecretRef)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.KeyItems) > 0 {
		for _, e := range m.KeyItems {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulClusterCommonSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Replicas != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Replicas))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Placement) > 0 {
		for k, v := range m.Placement {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPhysicalstatefulcluster(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Logs) > 0 {
		for k, v := range m.Logs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPhysicalstatefulcluster(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if len(m.HealthChecks) > 0 {
		for _, e := range m.HealthChecks {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.Ingress != nil {
		l = m.Ingress.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.MinimumReplicas != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.MinimumReplicas))
	}
	if m.ClusterDeletionHandler != nil {
		l = m.ClusterDeletionHandler.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.PodSecurityContext != nil {
		l = m.PodSecurityContext.Size()
		n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.PodAnnotations) > 0 {
		for k, v := range m.PodAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 2 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if len(m.InitContainers) > 0 {
		for _, e := range m.InitContainers {
			l = e.Size()
			n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.PodManagementPolicy != 0 {
		n += 2 + sovPhysicalstatefulcluster(uint64(m.PodManagementPolicy))
	}
	if m.Affinity != nil {
		l = m.Affinity.Size()
		n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.SkipHostPort {
		n += 3
	}
	if m.UpdateStrategy != nil {
		l = m.UpdateStrategy.Size()
		n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.PscAnnotations) > 0 {
		for k, v := range m.PscAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 2 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.ServiceAccount != nil {
		l = m.ServiceAccount.Size()
		n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.ExtraVolumes) > 0 {
		for _, e := range m.ExtraVolumes {
			l = e.Size()
			n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.PodTolerations) > 0 {
		for _, e := range m.PodTolerations {
			l = e.Size()
			n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.NetworkPolicy != nil {
		l = m.NetworkPolicy.Size()
		n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.AdditionalPodLabels) > 0 {
		for k, v := range m.AdditionalPodLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 2 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	l = len(m.RuntimeClassName)
	if l > 0 {
		n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.EnableBrokerRackZoneIds {
		n += 3
	}
	if m.CniNetworkPolicy != nil {
		l = m.CniNetworkPolicy.Size()
		n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.AutoMountServiceAccountToken != nil {
		l = m.AutoMountServiceAccountToken.Size()
		n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BooleanType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.PolicyTypes) > 0 {
		for _, s := range m.PolicyTypes {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtraVolume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostPath)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Attachable {
		n += 2
	}
	if len(m.AttachToInitContainers) > 0 {
		for _, s := range m.AttachToInitContainers {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.EmptyDirVolume != nil {
		l = m.EmptyDirVolume.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.HostPathVolume != nil {
		l = m.HostPathVolume.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.Apply {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Type))
	}
	if m.ReplicasToNotUpdate != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.ReplicasToNotUpdate))
	}
	if m.Pause {
		n += 2
	}
	if m.Abort {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodSecurityContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FsGroup != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.FsGroup))
	}
	if m.RunAsGroup != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.RunAsGroup))
	}
	if m.RunAsNonRoot {
		n += 2
	}
	if m.RunAsUser != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.RunAsUser))
	}
	if m.SelinuxOptions != nil {
		l = m.SelinuxOptions.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.SupplementalGroups) > 0 {
		l = 0
		for _, e := range m.SupplementalGroups {
			l += sovPhysicalstatefulcluster(uint64(e))
		}
		n += 1 + sovPhysicalstatefulcluster(uint64(l)) + l
	}
	if len(m.Systls) > 0 {
		for _, e := range m.Systls {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.SeccompProfile != nil {
		l = m.SeccompProfile.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SeccompProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.LocalhostProfile)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SELinuxOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sysctl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterDeletionHandler) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExecCommand) > 0 {
		for _, s := range m.ExecCommand {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pods) > 0 {
		for _, s := range m.Pods {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Container) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.TerminationGracePeriodSeconds != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.TerminationGracePeriodSeconds))
	}
	if m.PreStopHandler != nil {
		l = m.PreStopHandler.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.ReadinessProbe != nil {
		l = m.ReadinessProbe.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.LivenessProbe != nil {
		l = m.LivenessProbe.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.EnvVar) > 0 {
		for k, v := range m.EnvVar {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	l = len(m.ServiceAccount)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.NodeAffinity != nil {
		l = m.NodeAffinity.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Rack != nil {
		l = m.Rack.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.PodInfoExportPolicy != nil {
		l = m.PodInfoExportPolicy.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.MountedSecrets) > 0 {
		for _, e := range m.MountedSecrets {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.SecurityContext != nil {
		l = m.SecurityContext.Size()
		n += 2 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunAsGroup != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.RunAsGroup))
	}
	if m.RunAsNonRoot {
		n += 2
	}
	if m.RunAsUser != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.RunAsUser))
	}
	if m.Privileged {
		n += 2
	}
	if m.AllowPrivilegeEscalation {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InitContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.EnvVar) > 0 {
		for k, v := range m.EnvVar {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.SecurityContext != nil {
		l = m.SecurityContext.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Affinity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeAffinity != nil {
		l = m.NodeAffinity.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.PodAffinity != nil {
		l = m.PodAffinity.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.PodAntiAffinity != nil {
		l = m.PodAntiAffinity.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeAffinity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.Rule != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Rule))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodLevelAffinity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rule != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Rule))
	}
	if len(m.Terms) > 0 {
		for _, e := range m.Terms {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodLevelAffinityTerm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Namespaces) > 0 {
		for _, s := range m.Namespaces {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.TopologyKey != nil {
		l = m.TopologyKey.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Weight != nil {
		l = m.Weight.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopologyKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Weight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Weight != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Weight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TopologyKey)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Probe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitialDelaySeconds != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.InitialDelaySeconds))
	}
	if m.TimeoutSeconds != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.TimeoutSeconds))
	}
	if m.PeriodSeconds != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.PeriodSeconds))
	}
	if m.SuccessThreshold != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.SuccessThreshold))
	}
	if m.FailureThreshold != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.FailureThreshold))
	}
	if m.Exec != nil {
		l = m.Exec.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecHandler) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPHandler) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scheme != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Scheme))
	}
	if m.Port != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Port))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TCPHandler) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreStopHandler) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExecCommand) > 0 {
		for _, s := range m.ExecCommand {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Network) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.ClientEndpoints != nil {
		l = m.ClientEndpoints.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.DiscoveryService != nil {
		l = m.DiscoveryService.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.UseDefaultResolverForHealthcheck {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiscoveryService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientEndpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.External)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Internal)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IntervalSecs != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.IntervalSecs))
	}
	if m.RetentionMonths != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.RetentionMonths))
	}
	if m.Port != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Port))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.MetricsPath)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Sinks) > 0 {
		for _, e := range m.Sinks {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricSink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Blacklist) > 0 {
		for _, s := range m.Blacklist {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Whitelist) > 0 {
		for _, s := range m.Whitelist {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Deltalist) > 0 {
		for _, s := range m.Deltalist {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Logs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetentionMonths != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.RetentionMonths))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyPorts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for k, v := range m.Ports {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPhysicalstatefulcluster(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Proxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for k, v := range m.Routes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPhysicalstatefulcluster(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.Ssl {
		n += 2
	}
	if m.Internal {
		n += 2
	}
	if m.Bootstrap != nil {
		l = m.Bootstrap.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Pods) > 0 {
		for _, e := range m.Pods {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.CCloudManagedLb {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyPods) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Dns)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.NodePort != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.NodePort))
	}
	if m.Port != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Bootstrap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Dns)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Port))
	}
	if m.NodePort != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.NodePort))
	}
	if len(m.AdditionalPorts) > 0 {
		for _, e := range m.AdditionalPorts {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	l = len(m.ExternalTrafficPolicy)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BootstrapPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InternalPortName)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Port))
	}
	if m.NodePort != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.NodePort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.External != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.External))
	}
	if m.Internal != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Internal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodResources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.Requests != nil {
		l = m.Requests.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Limits != nil {
		l = m.Limits.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Resources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Storage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Type))
	}
	l = len(m.Capacity)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.StorageClassName)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.EncryptionKeyId)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.StorageClassId)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Iops != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Iops))
	}
	if m.Throughput != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Throughput))
	}
	l = len(m.DiskEncryptionSetId)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Port))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.HostPort != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.HostPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shared) > 0 {
		for _, e := range m.Shared {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Pod) > 0 {
		for _, e := range m.Pod {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Init) > 0 {
		for _, e := range m.Init {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PodConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Config) > 0 {
		for _, e := range m.Config {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Configuration) > 0 {
		for _, e := range m.Configuration {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for k, v := range m.Metrics {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPhysicalstatefulcluster(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.ClusterStatusProbe != nil {
		l = m.ClusterStatusProbe.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Affinity != nil {
		l = m.Affinity.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.SkipHostPort {
		n += 2
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.AdditionalPodLabels) > 0 {
		for k, v := range m.AdditionalPodLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HealthCheckStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.LowestPodPscVersion)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterStatusProbe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Port))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.IntervalSeconds != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.IntervalSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ingress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoadBalanced {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cloud) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.DockerRepo)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Aws != nil {
		l = m.Aws.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Gcp != nil {
		l = m.Gcp.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.K8SClusterId)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Local) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Aws) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vpc)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Zones) > 0 {
		for _, s := range m.Zones {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.ProxyToZone) > 0 {
		for k, v := range m.ProxyToZone {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.Route53 != nil {
		l = m.Route53.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Elb != nil {
		l = m.Elb.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Route53) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostedZone)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.TtlSecs != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.TtlSecs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Elb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessLogConfig != nil {
		l = m.AccessLogConfig.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Healthcheck != nil {
		l = m.Healthcheck.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.IdleTimeoutSecs != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.IdleTimeoutSecs))
	}
	if len(m.InstanceSelector) > 0 {
		for k, v := range m.InstanceSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.SecurityGroups != nil {
		l = m.SecurityGroups.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.SslCertificateId)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecurityGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IngressName)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.IngressCustomCidr) > 0 {
		for _, s := range m.IngressCustomCidr {
			l = len(s)
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	l = len(m.EgressName)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ELBAccessLogConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EmitIntervalMins != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.EmitIntervalMins))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.S3BucketName)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.S3BucketPrefix)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ELBHealthcheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthyThreshold != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.HealthyThreshold))
	}
	if m.IntervalSecs != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.IntervalSecs))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.TimeoutSecs != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.TimeoutSecs))
	}
	if m.UnhealthyThreshold != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.UnhealthyThreshold))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Gcp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulClusterStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.ProxyStatus != nil {
		l = m.ProxyStatus.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.LastProbeTime != nil {
		l = m.LastProbeTime.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.LowestPodPscVersion)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.PodTemplateSpecDiff)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.HealthCheckStatus) > 0 {
		for _, e := range m.HealthCheckStatus {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulClusterCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.LastProbeTime != nil {
		l = m.LastProbeTime.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.LastTransitionTime != nil {
		l = m.LastTransitionTime.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.AdditionalInfo != nil {
		l = m.AdditionalInfo.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulClusterConditionAdditionalInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RollProgress != nil {
		l = m.RollProgress.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodsUpdated != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.PodsUpdated))
	}
	if m.TotalPods != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.TotalPods))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PhysicalStatefulClusterHealthCheckClusterStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Summary != 0 {
		n += 1 + sovPhysicalstatefulcluster(uint64(m.Summary))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PostRollConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if len(m.Validations) > 0 {
		l = 0
		for _, e := range m.Validations {
			l += sovPhysicalstatefulcluster(uint64(e))
		}
		n += 1 + sovPhysicalstatefulcluster(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNIProviderNetworkPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndpointSelector != nil {
		l = m.EndpointSelector.Size()
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EndpointSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MatchLabels) > 0 {
		for k, v := range m.MatchLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPhysicalstatefulcluster(uint64(len(k))) + 1 + len(v) + sovPhysicalstatefulcluster(uint64(len(v)))
			n += mapEntrySize + 1 + sovPhysicalstatefulcluster(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngressRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FromEndpoints) > 0 {
		for _, e := range m.FromEndpoints {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.ToPorts) > 0 {
		for _, e := range m.ToPorts {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ToFqdns) > 0 {
		for _, e := range m.ToFqdns {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if len(m.ToPorts) > 0 {
		for _, e := range m.ToPorts {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FQDNSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MatchName)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.MatchPattern)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PortRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PortProtocol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovPhysicalstatefulcluster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPhysicalstatefulcluster(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPhysicalstatefulcluster(x uint64) (n int) {
	return sovPhysicalstatefulcluster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PhysicalStatefulClusterList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulClusterList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulClusterList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &v1.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ListMeta == nil {
				m.ListMeta = &v1.ListMeta{}
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &PhysicalStatefulCluster{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &v1.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &v1.ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PhysicalStatefulClusterStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PhysicalStatefulClusterSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Common", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Common == nil {
				m.Common = &PhysicalStatefulClusterCommonSpec{}
			}
			if err := m.Common.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloud", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cloud == nil {
				m.Cloud = &Cloud{}
			}
			if err := m.Cloud.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &PhysicalStatefulClusterPolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulClusterPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulClusterPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulClusterPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalSlaInEffect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExternalSlaInEffect = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plugin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plugin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Psc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Psc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodInfoExportPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodInfoExportPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodInfoExportPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostIp = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNamespace", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PodNamespace = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountedSecret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountedSecret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountedSecret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyItems = append(m.KeyItems, &KeyItem{})
			if err := m.KeyItems[len(m.KeyItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulClusterCommonSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulClusterCommonSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulClusterCommonSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			m.Replicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &PodResources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Placement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Placement == nil {
				m.Placement = make(map[string]*PodList)
			}
			var mapkey string
			var mapvalue *PodList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PodList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Placement[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &PhysicalStatefulClusterConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Logs == nil {
				m.Logs = make(map[string]*Logs)
			}
			var mapkey string
			var mapvalue *Logs
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Logs{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Logs[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthChecks = append(m.HealthChecks, &HealthCheck{})
			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ingress == nil {
				m.Ingress = &Ingress{}
			}
			if err := m.Ingress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &Metrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumReplicas", wireType)
			}
			m.MinimumReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDeletionHandler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterDeletionHandler == nil {
				m.ClusterDeletionHandler = &ClusterDeletionHandler{}
			}
			if err := m.ClusterDeletionHandler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSecurityContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodSecurityContext == nil {
				m.PodSecurityContext = &PodSecurityContext{}
			}
			if err := m.PodSecurityContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAnnotations == nil {
				m.PodAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PodAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitContainers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitContainers = append(m.InitContainers, &InitContainer{})
			if err := m.InitContainers[len(m.InitContainers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodManagementPolicy", wireType)
			}
			m.PodManagementPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodManagementPolicy |= PodManagementPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Affinity == nil {
				m.Affinity = &Affinity{}
			}
			if err := m.Affinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipHostPort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipHostPort = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateStrategy == nil {
				m.UpdateStrategy = &UpdateStrategy{}
			}
			if err := m.UpdateStrategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PscAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PscAnnotations == nil {
				m.PscAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PscAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceAccount == nil {
				m.ServiceAccount = &ServiceAccount{}
			}
			if err := m.ServiceAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraVolumes = append(m.ExtraVolumes, &ExtraVolume{})
			if err := m.ExtraVolumes[len(m.ExtraVolumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodTolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodTolerations = append(m.PodTolerations, &v11.Toleration{})
			if err := m.PodTolerations[len(m.PodTolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkPolicy == nil {
				m.NetworkPolicy = &NetworkPolicy{}
			}
			if err := m.NetworkPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalPodLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalPodLabels == nil {
				m.AdditionalPodLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdditionalPodLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableBrokerRackZoneIds", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableBrokerRackZoneIds = bool(v != 0)
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CniNetworkPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CniNetworkPolicy == nil {
				m.CniNetworkPolicy = &CNIProviderNetworkPolicy{}
			}
			if err := m.CniNetworkPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoMountServiceAccountToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoMountServiceAccountToken == nil {
				m.AutoMountServiceAccountToken = &BooleanType{}
			}
			if err := m.AutoMountServiceAccountToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BooleanType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BooleanType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BooleanType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &v12.NetworkPolicyIngressRule{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &v12.NetworkPolicyEgressRule{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyTypes = append(m.PolicyTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtraVolume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Attachable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachToInitContainers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachToInitContainers = append(m.AttachToInitContainers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmptyDirVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmptyDirVolume == nil {
				m.EmptyDirVolume = &v11.EmptyDirVolumeSource{}
			}
			if err := m.EmptyDirVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPathVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostPathVolume == nil {
				m.HostPathVolume = &v11.HostPathVolumeSource{}
			}
			if err := m.HostPathVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apply", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Apply = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= UpdateStrategyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasToNotUpdate", wireType)
			}
			m.ReplicasToNotUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicasToNotUpdate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pause", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pause = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Abort = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodSecurityContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodSecurityContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodSecurityContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsGroup", wireType)
			}
			m.FsGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FsGroup |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsGroup", wireType)
			}
			m.RunAsGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunAsGroup |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsNonRoot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RunAsNonRoot = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsUser", wireType)
			}
			m.RunAsUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunAsUser |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelinuxOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelinuxOptions == nil {
				m.SelinuxOptions = &SELinuxOptions{}
			}
			if err := m.SelinuxOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupplementalGroups = append(m.SupplementalGroups, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPhysicalstatefulcluster
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPhysicalstatefulcluster
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SupplementalGroups) == 0 {
					m.SupplementalGroups = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupplementalGroups = append(m.SupplementalGroups, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplementalGroups", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Systls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Systls = append(m.Systls, &Sysctl{})
			if err := m.Systls[len(m.Systls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeccompProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SeccompProfile == nil {
				m.SeccompProfile = &SeccompProfile{}
			}
			if err := m.SeccompProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeccompProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeccompProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeccompProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalhostProfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalhostProfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SELinuxOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SELinuxOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SELinuxOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sysctl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sysctl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sysctl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterDeletionHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterDeletionHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterDeletionHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecCommand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecCommand = append(m.ExecCommand, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pods = append(m.Pods, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminationGracePeriodSeconds", wireType)
			}
			m.TerminationGracePeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TerminationGracePeriodSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreStopHandler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreStopHandler == nil {
				m.PreStopHandler = &PreStopHandler{}
			}
			if err := m.PreStopHandler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessProbe == nil {
				m.ReadinessProbe = &Probe{}
			}
			if err := m.ReadinessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LivenessProbe == nil {
				m.LivenessProbe = &Probe{}
			}
			if err := m.LivenessProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVar == nil {
				m.EnvVar = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVar[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAffinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAffinity == nil {
				m.NodeAffinity = &NodeAffinity{}
			}
			if err := m.NodeAffinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rack == nil {
				m.Rack = &Rack{}
			}
			if err := m.Rack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodInfoExportPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodInfoExportPolicy == nil {
				m.PodInfoExportPolicy = &PodInfoExportPolicy{}
			}
			if err := m.PodInfoExportPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountedSecrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountedSecrets = append(m.MountedSecrets, &MountedSecret{})
			if err := m.MountedSecrets[len(m.MountedSecrets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityContext == nil {
				m.SecurityContext = &SecurityContext{}
			}
			if err := m.SecurityContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsGroup", wireType)
			}
			m.RunAsGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunAsGroup |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsNonRoot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RunAsNonRoot = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsUser", wireType)
			}
			m.RunAsUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunAsUser |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPrivilegeEscalation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPrivilegeEscalation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVar == nil {
				m.EnvVar = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVar[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &PodResources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityContext == nil {
				m.SecurityContext = &SecurityContext{}
			}
			if err := m.SecurityContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Affinity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Affinity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Affinity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAffinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeAffinity == nil {
				m.NodeAffinity = &NodeAffinity{}
			}
			if err := m.NodeAffinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAffinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAffinity == nil {
				m.PodAffinity = &PodLevelAffinity{}
			}
			if err := m.PodAffinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAntiAffinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodAntiAffinity == nil {
				m.PodAntiAffinity = &PodLevelAffinity{}
			}
			if err := m.PodAntiAffinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeAffinity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAffinity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAffinity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			m.Rule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rule |= AffinityRule(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodLevelAffinity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodLevelAffinity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodLevelAffinity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			m.Rule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rule |= AffinityRule(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Terms = append(m.Terms, &PodLevelAffinityTerm{})
			if err := m.Terms[len(m.Terms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodLevelAffinityTerm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodLevelAffinityTerm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodLevelAffinityTerm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopologyKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopologyKey == nil {
				m.TopologyKey = &TopologyKey{}
			}
			if err := m.TopologyKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weight == nil {
				m.Weight = &Weight{}
			}
			if err := m.Weight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopologyKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopologyKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopologyKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Weight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Weight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Weight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopologyKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopologyKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Probe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Probe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Probe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialDelaySeconds", wireType)
			}
			m.InitialDelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialDelaySeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			m.TimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodSeconds", wireType)
			}
			m.PeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessThreshold", wireType)
			}
			m.SuccessThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureThreshold", wireType)
			}
			m.FailureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exec == nil {
				m.Exec = &ExecHandler{}
			}
			if err := m.Exec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http == nil {
				m.Http = &HTTPHandler{}
			}
			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tcp == nil {
				m.Tcp = &TCPHandler{}
			}
			if err := m.Tcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			m.Scheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scheme |= HTTPHandler_URIScheme(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreStopHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreStopHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreStopHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecCommand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecCommand = append(m.ExecCommand, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &Proxy{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &Port{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientEndpoints == nil {
				m.ClientEndpoints = &ClientEndpoints{}
			}
			if err := m.ClientEndpoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiscoveryService == nil {
				m.DiscoveryService = &DiscoveryService{}
			}
			if err := m.DiscoveryService.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefaultResolverForHealthcheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseDefaultResolverForHealthcheck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveryService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveryService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveryService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientEndpoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientEndpoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientEndpoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field External", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.External = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Internal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSecs", wireType)
			}
			m.IntervalSecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSecs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionMonths", wireType)
			}
			m.RetentionMonths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetentionMonths |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sinks = append(m.Sinks, &MetricSink{})
			if err := m.Sinks[len(m.Sinks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricSink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricSink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricSink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blacklist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blacklist = append(m.Blacklist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Whitelist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Whitelist = append(m.Whitelist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deltalist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deltalist = append(m.Deltalist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Logs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Logs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Logs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionMonths", wireType)
			}
			m.RetentionMonths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetentionMonths |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyPorts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyPorts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyPorts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = make(map[string]*ProxyPort)
			}
			var mapkey string
			var mapvalue *ProxyPort
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ProxyPort{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ports[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routes == nil {
				m.Routes = make(map[string]*ProxyPorts)
			}
			var mapkey string
			var mapvalue *ProxyPorts
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ProxyPorts{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Routes[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ssl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ssl = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootstrap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bootstrap == nil {
				m.Bootstrap = &Bootstrap{}
			}
			if err := m.Bootstrap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pods = append(m.Pods, &ProxyPods{})
			if err := m.Pods[len(m.Pods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CCloudManagedLb", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CCloudManagedLb = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyPods) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyPods: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyPods: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dns = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			m.NodePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bootstrap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bootstrap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bootstrap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dns = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			m.NodePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalPorts = append(m.AdditionalPorts, &BootstrapPort{})
			if err := m.AdditionalPorts[len(m.AdditionalPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTrafficPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalTrafficPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BootstrapPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BootstrapPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BootstrapPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalPortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			m.NodePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field External", wireType)
			}
			m.External = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.External |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			m.Internal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Internal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodResources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodResources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodResources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &Storage{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requests == nil {
				m.Requests = &Resources{}
			}
			if err := m.Requests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = &Resources{}
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Storage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Storage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Storage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StorageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capacity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iops", wireType)
			}
			m.Iops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iops |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Throughput", wireType)
			}
			m.Throughput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Throughput |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskEncryptionSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskEncryptionSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shared = append(m.Shared, &Config{})
			if err := m.Shared[len(m.Shared)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pod = append(m.Pod, &PodConfig{})
			if err := m.Pod[len(m.Pod)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Init", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Init = append(m.Init, &PodConfig{})
			if err := m.Init[len(m.Init)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config, &Config{})
			if err := m.Config[len(m.Config)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &PodResources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configuration = append(m.Configuration, &Config{})
			if err := m.Configuration[len(m.Configuration)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = make(map[string]*Metrics)
			}
			var mapkey string
			var mapvalue *Metrics
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Metrics{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metrics[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterStatusProbe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterStatusProbe == nil {
				m.ClusterStatusProbe = &ClusterStatusProbe{}
			}
			if err := m.ClusterStatusProbe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Affinity == nil {
				m.Affinity = &Affinity{}
			}
			if err := m.Affinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipHostPort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipHostPort = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalPodLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalPodLabels == nil {
				m.AdditionalPodLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdditionalPodLabels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowestPodPscVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowestPodPscVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatusProbe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatusProbe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatusProbe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			m.IntervalSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ingress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ingress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ingress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalanced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadBalanced = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cloud) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cloud: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cloud: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerRepo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerRepo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aws == nil {
				m.Aws = &Aws{}
			}
			if err := m.Aws.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gcp == nil {
				m.Gcp = &Gcp{}
			}
			if err := m.Gcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Local == nil {
				m.Local = &Local{}
			}
			if err := m.Local.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Local) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Local: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Local: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aws) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aws: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aws: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vpc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zones", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zones = append(m.Zones, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyToZone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyToZone == nil {
				m.ProxyToZone = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProxyToZone[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route53", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route53 == nil {
				m.Route53 = &Route53{}
			}
			if err := m.Route53.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Elb == nil {
				m.Elb = &Elb{}
			}
			if err := m.Elb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route53) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route53: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route53: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostedZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostedZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlSecs", wireType)
			}
			m.TtlSecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TtlSecs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Elb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Elb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Elb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLogConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessLogConfig == nil {
				m.AccessLogConfig = &ELBAccessLogConfig{}
			}
			if err := m.AccessLogConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Healthcheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Healthcheck == nil {
				m.Healthcheck = &ELBHealthcheck{}
			}
			if err := m.Healthcheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeoutSecs", wireType)
			}
			m.IdleTimeoutSecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeoutSecs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InstanceSelector == nil {
				m.InstanceSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InstanceSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityGroups == nil {
				m.SecurityGroups = &SecurityGroup{}
			}
			if err := m.SecurityGroups.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SslCertificateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SslCertificateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressCustomCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressCustomCidr = append(m.IngressCustomCidr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ELBAccessLogConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ELBAccessLogConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ELBAccessLogConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitIntervalMins", wireType)
			}
			m.EmitIntervalMins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmitIntervalMins |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3BucketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3BucketName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3BucketPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3BucketPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ELBHealthcheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ELBHealthcheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ELBHealthcheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthyThreshold", wireType)
			}
			m.HealthyThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthyThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSecs", wireType)
			}
			m.IntervalSecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSecs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSecs", wireType)
			}
			m.TimeoutSecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSecs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyThreshold", wireType)
			}
			m.UnhealthyThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnhealthyThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gcp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gcp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gcp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyStatus == nil {
				m.ProxyStatus = &ProxyStatus{}
			}
			if err := m.ProxyStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &PhysicalStatefulClusterCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProbeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastProbeTime == nil {
				m.LastProbeTime = &v1.Time{}
			}
			if err := m.LastProbeTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowestPodPscVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowestPodPscVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodTemplateSpecDiff", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodTemplateSpecDiff = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthCheckStatus = append(m.HealthCheckStatus, &HealthCheckStatus{})
			if err := m.HealthCheckStatus[len(m.HealthCheckStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulClusterCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulClusterCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulClusterCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProbeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastProbeTime == nil {
				m.LastProbeTime = &v1.Time{}
			}
			if err := m.LastProbeTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTime == nil {
				m.LastTransitionTime = &v1.Time{}
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalInfo == nil {
				m.AdditionalInfo = &PhysicalStatefulClusterConditionAdditionalInfo{}
			}
			if err := m.AdditionalInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulClusterConditionAdditionalInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulClusterConditionAdditionalInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollProgress == nil {
				m.RollProgress = &PhysicalStatefulClusterConditionAdditionalInfo_RollProgress{}
			}
			if err := m.RollProgress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulClusterConditionAdditionalInfo_RollProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodsUpdated", wireType)
			}
			m.PodsUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodsUpdated |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPods", wireType)
			}
			m.TotalPods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPods |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalStatefulClusterHealthCheckClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalStatefulClusterHealthCheckClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalStatefulClusterHealthCheckClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			m.Summary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Summary |= PhysicalStatefulClusterStatus_ClusterSummary(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &PhysicalStatefulClusterCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &v1.Time{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostRollConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostRollConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostRollConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v PostRollConfig_Validation
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PostRollConfig_Validation(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Validations = append(m.Validations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPhysicalstatefulcluster
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPhysicalstatefulcluster
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Validations) == 0 {
					m.Validations = make([]PostRollConfig_Validation, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PostRollConfig_Validation
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PostRollConfig_Validation(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Validations = append(m.Validations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Validations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNIProviderNetworkPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNIProviderNetworkPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNIProviderNetworkPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointSelector == nil {
				m.EndpointSelector = &EndpointSelector{}
			}
			if err := m.EndpointSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &IngressRule{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &EgressRule{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchLabels == nil {
				m.MatchLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalstatefulcluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPhysicalstatefulcluster
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MatchLabels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromEndpoints = append(m.FromEndpoints, &EndpointSelector{})
			if err := m.FromEndpoints[len(m.FromEndpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToPorts = append(m.ToPorts, &PortRule{})
			if err := m.ToPorts[len(m.ToPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToFqdns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToFqdns = append(m.ToFqdns, &FQDNSelector{})
			if err := m.ToFqdns[len(m.ToFqdns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToPorts = append(m.ToPorts, &PortRule{})
			if err := m.ToPorts[len(m.ToPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FQDNSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FQDNSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FQDNSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchPattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchPattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortProtocol{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortProtocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortProtocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortProtocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalstatefulcluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalstatefulcluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPhysicalstatefulcluster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPhysicalstatefulcluster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPhysicalstatefulcluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPhysicalstatefulcluster
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPhysicalstatefulcluster
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPhysicalstatefulcluster
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPhysicalstatefulcluster(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPhysicalstatefulcluster
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPhysicalstatefulcluster = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPhysicalstatefulcluster   = fmt.Errorf("proto: integer overflow")
)
