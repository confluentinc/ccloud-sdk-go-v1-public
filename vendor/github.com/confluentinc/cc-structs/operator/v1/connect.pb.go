// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: operator/v1/connect.proto

package v1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ConnectPlugin int32

const (
	ConnectPlugin_S3_SINK  ConnectPlugin = 0
	ConnectPlugin_GCS_SINK ConnectPlugin = 1
	ConnectPlugin_ES_SINK  ConnectPlugin = 2
	ConnectPlugin_BQ_SINK  ConnectPlugin = 3
)

var ConnectPlugin_name = map[int32]string{
	0: "S3_SINK",
	1: "GCS_SINK",
	2: "ES_SINK",
	3: "BQ_SINK",
}

var ConnectPlugin_value = map[string]int32{
	"S3_SINK":  0,
	"GCS_SINK": 1,
	"ES_SINK":  2,
	"BQ_SINK":  3,
}

func (x ConnectPlugin) String() string {
	return proto.EnumName(ConnectPlugin_name, int32(x))
}

func (ConnectPlugin) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{0}
}

// Status matches the values of ConnectorStatus in scheduler.proto
type ConnectorStatus_Status int32

const (
	ConnectorStatus_NONE         ConnectorStatus_Status = 0
	ConnectorStatus_PROVISIONING ConnectorStatus_Status = 1
	ConnectorStatus_RUNNING      ConnectorStatus_Status = 2
	ConnectorStatus_DEGRADED     ConnectorStatus_Status = 3
	ConnectorStatus_FAILED       ConnectorStatus_Status = 4
	ConnectorStatus_PAUSED       ConnectorStatus_Status = 5
	ConnectorStatus_DELETED      ConnectorStatus_Status = 6
)

var ConnectorStatus_Status_name = map[int32]string{
	0: "NONE",
	1: "PROVISIONING",
	2: "RUNNING",
	3: "DEGRADED",
	4: "FAILED",
	5: "PAUSED",
	6: "DELETED",
}

var ConnectorStatus_Status_value = map[string]int32{
	"NONE":         0,
	"PROVISIONING": 1,
	"RUNNING":      2,
	"DEGRADED":     3,
	"FAILED":       4,
	"PAUSED":       5,
	"DELETED":      6,
}

func (x ConnectorStatus_Status) String() string {
	return proto.EnumName(ConnectorStatus_Status_name, int32(x))
}

func (ConnectorStatus_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{2, 0}
}

type ActualState_Values int32

const (
	ActualState_NONE                  ActualState_Values = 0
	ActualState_RUNNING               ActualState_Values = 1
	ActualState_STOPPED               ActualState_Values = 2
	ActualState_DELETED               ActualState_Values = 3
	ActualState_UNASSIGNED            ActualState_Values = 4
	ActualState_ERROR                 ActualState_Values = 100
	ActualState_PENDING               ActualState_Values = 101
	ActualState_SYSTEM_ERROR          ActualState_Values = 102
	ActualState_USER_ACTIONABLE_ERROR ActualState_Values = 103
)

var ActualState_Values_name = map[int32]string{
	0:   "NONE",
	1:   "RUNNING",
	2:   "STOPPED",
	3:   "DELETED",
	4:   "UNASSIGNED",
	100: "ERROR",
	101: "PENDING",
	102: "SYSTEM_ERROR",
	103: "USER_ACTIONABLE_ERROR",
}

var ActualState_Values_value = map[string]int32{
	"NONE":                  0,
	"RUNNING":               1,
	"STOPPED":               2,
	"DELETED":               3,
	"UNASSIGNED":            4,
	"ERROR":                 100,
	"PENDING":               101,
	"SYSTEM_ERROR":          102,
	"USER_ACTIONABLE_ERROR": 103,
}

func (x ActualState_Values) String() string {
	return proto.EnumName(ActualState_Values_name, int32(x))
}

func (ActualState_Values) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{4, 0}
}

type ConnectorSpec_DesiredState int32

const (
	ConnectorSpec_NONE    ConnectorSpec_DesiredState = 0
	ConnectorSpec_RUNNING ConnectorSpec_DesiredState = 1
	ConnectorSpec_STOPPED ConnectorSpec_DesiredState = 2
	ConnectorSpec_DELETED ConnectorSpec_DesiredState = 3
)

var ConnectorSpec_DesiredState_name = map[int32]string{
	0: "NONE",
	1: "RUNNING",
	2: "STOPPED",
	3: "DELETED",
}

var ConnectorSpec_DesiredState_value = map[string]int32{
	"NONE":    0,
	"RUNNING": 1,
	"STOPPED": 2,
	"DELETED": 3,
}

func (x ConnectorSpec_DesiredState) String() string {
	return proto.EnumName(ConnectorSpec_DesiredState_name, int32(x))
}

func (ConnectorSpec_DesiredState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{5, 0}
}

type ConfigType_Values int32

const (
	ConfigType_NONE     ConfigType_Values = 0
	ConfigType_BOOLEAN  ConfigType_Values = 1
	ConfigType_INT      ConfigType_Values = 2
	ConfigType_SHORT    ConfigType_Values = 3
	ConfigType_LONG     ConfigType_Values = 4
	ConfigType_DOUBLE   ConfigType_Values = 5
	ConfigType_STRING   ConfigType_Values = 6
	ConfigType_LIST     ConfigType_Values = 7
	ConfigType_ENUM     ConfigType_Values = 8
	ConfigType_PASSWORD ConfigType_Values = 9
	ConfigType_CLASS    ConfigType_Values = 10
)

var ConfigType_Values_name = map[int32]string{
	0:  "NONE",
	1:  "BOOLEAN",
	2:  "INT",
	3:  "SHORT",
	4:  "LONG",
	5:  "DOUBLE",
	6:  "STRING",
	7:  "LIST",
	8:  "ENUM",
	9:  "PASSWORD",
	10: "CLASS",
}

var ConfigType_Values_value = map[string]int32{
	"NONE":     0,
	"BOOLEAN":  1,
	"INT":      2,
	"SHORT":    3,
	"LONG":     4,
	"DOUBLE":   5,
	"STRING":   6,
	"LIST":     7,
	"ENUM":     8,
	"PASSWORD": 9,
	"CLASS":    10,
}

func (x ConfigType_Values) String() string {
	return proto.EnumName(ConfigType_Values_name, int32(x))
}

func (ConfigType_Values) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{13, 0}
}

type ConfigWidth_Values int32

const (
	ConfigWidth_NONE   ConfigWidth_Values = 0
	ConfigWidth_SHORT  ConfigWidth_Values = 1
	ConfigWidth_MEDIUM ConfigWidth_Values = 2
	ConfigWidth_LONG   ConfigWidth_Values = 3
)

var ConfigWidth_Values_name = map[int32]string{
	0: "NONE",
	1: "SHORT",
	2: "MEDIUM",
	3: "LONG",
}

var ConfigWidth_Values_value = map[string]int32{
	"NONE":   0,
	"SHORT":  1,
	"MEDIUM": 2,
	"LONG":   3,
}

func (x ConfigWidth_Values) String() string {
	return proto.EnumName(ConfigWidth_Values_name, int32(x))
}

func (ConfigWidth_Values) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{14, 0}
}

type ConfigImportance_Values int32

const (
	ConfigImportance_NONE   ConfigImportance_Values = 0
	ConfigImportance_HIGH   ConfigImportance_Values = 1
	ConfigImportance_MEDIUM ConfigImportance_Values = 2
	ConfigImportance_LOW    ConfigImportance_Values = 3
)

var ConfigImportance_Values_name = map[int32]string{
	0: "NONE",
	1: "HIGH",
	2: "MEDIUM",
	3: "LOW",
}

var ConfigImportance_Values_value = map[string]int32{
	"NONE":   0,
	"HIGH":   1,
	"MEDIUM": 2,
	"LOW":    3,
}

func (x ConfigImportance_Values) String() string {
	return proto.EnumName(ConfigImportance_Values_name, int32(x))
}

func (ConfigImportance_Values) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{15, 0}
}

type ProductMaturityPhase_Values int32

const (
	ProductMaturityPhase_NONE     ProductMaturityPhase_Values = 0
	ProductMaturityPhase_INTERNAL ProductMaturityPhase_Values = 1
	ProductMaturityPhase_PREVIEW  ProductMaturityPhase_Values = 2
	ProductMaturityPhase_PA       ProductMaturityPhase_Values = 3
	ProductMaturityPhase_GA       ProductMaturityPhase_Values = 4
	ProductMaturityPhase_LANDED   ProductMaturityPhase_Values = 5
)

var ProductMaturityPhase_Values_name = map[int32]string{
	0: "NONE",
	1: "INTERNAL",
	2: "PREVIEW",
	3: "PA",
	4: "GA",
	5: "LANDED",
}

var ProductMaturityPhase_Values_value = map[string]int32{
	"NONE":     0,
	"INTERNAL": 1,
	"PREVIEW":  2,
	"PA":       3,
	"GA":       4,
	"LANDED":   5,
}

func (x ProductMaturityPhase_Values) String() string {
	return proto.EnumName(ProductMaturityPhase_Values_name, int32(x))
}

func (ProductMaturityPhase_Values) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{19, 0}
}

type ConnectorIdType_Values int32

const (
	ConnectorIdType_NONE ConnectorIdType_Values = 0
	ConnectorIdType_ID   ConnectorIdType_Values = 1
	ConnectorIdType_NAME ConnectorIdType_Values = 2
)

var ConnectorIdType_Values_name = map[int32]string{
	0: "NONE",
	1: "ID",
	2: "NAME",
}

var ConnectorIdType_Values_value = map[string]int32{
	"NONE": 0,
	"ID":   1,
	"NAME": 2,
}

func (x ConnectorIdType_Values) String() string {
	return proto.EnumName(ConnectorIdType_Values_name, int32(x))
}

func (ConnectorIdType_Values) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{20, 0}
}

// a message to represent a collection of connectors
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ConnectorList struct {
	*v1.TypeMeta         `protobuf:"bytes,1,opt,name=type_meta,json=typeMeta,proto3,embedded=type_meta" json:",inline" db:"type_meta,omitempty" url:"type_meta,omitempty"`
	*v1.ListMeta         `protobuf:"bytes,2,opt,name=list_meta,json=listMeta,proto3,embedded=list_meta" json:"metadata,omitempty" db:"list_meta,omitempty" url:"list_meta,omitempty"`
	Items                []*Connector `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty" db:"items,omitempty" url:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ConnectorList) Reset()         { *m = ConnectorList{} }
func (m *ConnectorList) String() string { return proto.CompactTextString(m) }
func (*ConnectorList) ProtoMessage()    {}
func (*ConnectorList) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{0}
}
func (m *ConnectorList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorList.Merge(m, src)
}
func (m *ConnectorList) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorList) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorList.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorList proto.InternalMessageInfo

func (m *ConnectorList) GetItems() []*Connector {
	if m != nil {
		return m.Items
	}
	return nil
}

// a single connector running in some physical connect cluster.
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Connector struct {
	*v1.TypeMeta         `protobuf:"bytes,1,opt,name=type_meta,json=typeMeta,proto3,embedded=type_meta" json:",inline" db:"type_meta,omitempty" url:"type_meta,omitempty"`
	*v1.ObjectMeta       `protobuf:"bytes,2,opt,name=object_meta,json=objectMeta,proto3,embedded=object_meta" json:"metadata,omitempty" db:"object_meta,omitempty" url:"object_meta,omitempty"`
	Status               *ConnectorStatus    `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty" db:"status,omitempty" url:"status,omitempty"`
	Spec                 *ConnectorSpec      `protobuf:"bytes,4,opt,name=spec,proto3" json:"spec,omitempty" db:"spec,omitempty" url:"spec,omitempty"`
	ErrorMapping         *ConnectOverrideMap `protobuf:"bytes,5,opt,name=error_mapping,json=errorMapping,proto3" json:"error_mapping,omitempty" db:"error_mapping,omitempty" url:"error_mapping,omitempty"`
	OrgId                int32               `protobuf:"varint,6,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty" db:"org_id,omitempty" url:"org_id,omitempty"`
	AccountId            string              `protobuf:"bytes,7,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty" db:"account_id,omitempty" url:"account_id,omitempty"`
	RequestId            string              `protobuf:"bytes,8,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty" db:"request_id,omitempty" url:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Connector) Reset()      { *m = Connector{} }
func (*Connector) ProtoMessage() {}
func (*Connector) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{1}
}
func (m *Connector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connector.Merge(m, src)
}
func (m *Connector) XXX_Size() int {
	return m.Size()
}
func (m *Connector) XXX_DiscardUnknown() {
	xxx_messageInfo_Connector.DiscardUnknown(m)
}

var xxx_messageInfo_Connector proto.InternalMessageInfo

func (m *Connector) GetStatus() *ConnectorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Connector) GetSpec() *ConnectorSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Connector) GetErrorMapping() *ConnectOverrideMap {
	if m != nil {
		return m.ErrorMapping
	}
	return nil
}

func (m *Connector) GetOrgId() int32 {
	if m != nil {
		return m.OrgId
	}
	return 0
}

func (m *Connector) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *Connector) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

// status information which will be stored in the mothership database, primarily to be shown on the UI.
type ConnectorStatus struct {
	Time *v1.Time `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty" db:"time,omitempty" url:"time,omitempty"`
	// validated configs from the connectors service
	ConnectorConfig *ValidatedConnectorConfig `protobuf:"bytes,2,opt,name=connector_config,json=connectorConfig,proto3" json:"connector_config,omitempty" db:"connector_config,omitempty" url:"connector_config,omitempty"`
	// per task status, along with any associated error messages
	TaskStatuses          map[string]*TaskStatus `protobuf:"bytes,3,rep,name=task_statuses,json=taskStatuses,proto3" json:"task_statuses,omitempty" db:"task_statuses,omitempty" url:"task_statuses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	OverrideStatus        string                 `protobuf:"bytes,4,opt,name=override_status,json=overrideStatus,proto3" json:"override_status,omitempty" db:"override_status,omitempty" url:"override_status,omitempty"`
	Status                ConnectorStatus_Status `protobuf:"varint,5,opt,name=status,proto3,enum=operator.v1.ConnectorStatus_Status" json:"status,omitempty" db:"status,omitempty" url:"status,omitempty"`
	StatusLastUpdatedTime *v1.Time               `protobuf:"bytes,6,opt,name=status_last_updated_time,json=statusLastUpdatedTime,proto3" json:"status_last_updated_time,omitempty" db:"status_last_updated_time,omitempty" url:"status_last_updated_time,omitempty"`
	ConnectorRawErrorMsg  string                 `protobuf:"bytes,7,opt,name=connector_raw_error_msg,json=connectorRawErrorMsg,proto3" json:"connector_raw_error_msg,omitempty" db:"connector_raw_error_msg,omitempty" url:"connector_raw_error_msg,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}               `json:"-"`
	XXX_unrecognized      []byte                 `json:"-"`
	XXX_sizecache         int32                  `json:"-"`
}

func (m *ConnectorStatus) Reset()         { *m = ConnectorStatus{} }
func (m *ConnectorStatus) String() string { return proto.CompactTextString(m) }
func (*ConnectorStatus) ProtoMessage()    {}
func (*ConnectorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{2}
}
func (m *ConnectorStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorStatus.Merge(m, src)
}
func (m *ConnectorStatus) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorStatus proto.InternalMessageInfo

func (m *ConnectorStatus) GetTime() *v1.Time {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *ConnectorStatus) GetConnectorConfig() *ValidatedConnectorConfig {
	if m != nil {
		return m.ConnectorConfig
	}
	return nil
}

func (m *ConnectorStatus) GetTaskStatuses() map[string]*TaskStatus {
	if m != nil {
		return m.TaskStatuses
	}
	return nil
}

func (m *ConnectorStatus) GetOverrideStatus() string {
	if m != nil {
		return m.OverrideStatus
	}
	return ""
}

func (m *ConnectorStatus) GetStatus() ConnectorStatus_Status {
	if m != nil {
		return m.Status
	}
	return ConnectorStatus_NONE
}

func (m *ConnectorStatus) GetStatusLastUpdatedTime() *v1.Time {
	if m != nil {
		return m.StatusLastUpdatedTime
	}
	return nil
}

func (m *ConnectorStatus) GetConnectorRawErrorMsg() string {
	if m != nil {
		return m.ConnectorRawErrorMsg
	}
	return ""
}

type TaskStatus struct {
	// actual task state
	State ActualState_Values `protobuf:"varint,1,opt,name=state,proto3,enum=operator.v1.ActualState_Values" json:"state,omitempty" db:"state,omitempty" url:"state,omitempty"`
	// the epoch timestamp when this task status was last updated
	LastUpdated uint64 `protobuf:"varint,2,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty" db:"last_updated,omitempty" url:"last_updated,omitempty"`
	// any task specific error message or stack trace
	ErrorMessage         string   `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty" db:"error_message,omitempty" url:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaskStatus) Reset()         { *m = TaskStatus{} }
func (m *TaskStatus) String() string { return proto.CompactTextString(m) }
func (*TaskStatus) ProtoMessage()    {}
func (*TaskStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{3}
}
func (m *TaskStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskStatus.Merge(m, src)
}
func (m *TaskStatus) XXX_Size() int {
	return m.Size()
}
func (m *TaskStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TaskStatus proto.InternalMessageInfo

func (m *TaskStatus) GetState() ActualState_Values {
	if m != nil {
		return m.State
	}
	return ActualState_NONE
}

func (m *TaskStatus) GetLastUpdated() uint64 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

func (m *TaskStatus) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// the actual state of a task.
// A different enum from DesiredState to accommodate different error or partial states
type ActualState struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActualState) Reset()         { *m = ActualState{} }
func (m *ActualState) String() string { return proto.CompactTextString(m) }
func (*ActualState) ProtoMessage()    {}
func (*ActualState) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{4}
}
func (m *ActualState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActualState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActualState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActualState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActualState.Merge(m, src)
}
func (m *ActualState) XXX_Size() int {
	return m.Size()
}
func (m *ActualState) XXX_DiscardUnknown() {
	xxx_messageInfo_ActualState.DiscardUnknown(m)
}

var xxx_messageInfo_ActualState proto.InternalMessageInfo

type ConnectorSpec struct {
	// name of the connector (logical cluster id)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	// name of physical connect cluster that hosts this connector
	PhysicalClusterId string `protobuf:"bytes,2,opt,name=physical_cluster_id,json=physicalClusterId,proto3" json:"physical_cluster_id,omitempty" db:"physical_cluster_id,omitempty" url:"physical_cluster_id,omitempty"`
	// type of plugin
	DeprecatedPlugin ConnectPlugin `protobuf:"varint,3,opt,name=deprecated_plugin,json=deprecatedPlugin,proto3,enum=operator.v1.ConnectPlugin" json:"deprecated_plugin,omitempty" db:"deprecated_plugin,omitempty" url:"deprecated_plugin,omitempty"`
	// kafka cluster used for internal worker use (status, offsets and config topics).
	InternalCluster *KafkaDependency `protobuf:"bytes,4,opt,name=internal_cluster,json=internalCluster,proto3" json:"internal_cluster,omitempty" db:"internal_cluster,omitempty" url:"internal_cluster,omitempty"`
	// original configs that were sent to the connectors service from the UI, desired configs. note that override_configs can override
	// these configs.
	Configs *ConnectorConfigs `protobuf:"bytes,5,opt,name=configs,proto3" json:"configs,omitempty" db:"configs,omitempty" url:"configs,omitempty"`
	// REST endpoint of the worker hosting the connector (visible within the k8s cluster/satellite)
	WorkerRestEndpoint string `protobuf:"bytes,6,opt,name=worker_rest_endpoint,json=workerRestEndpoint,proto3" json:"worker_rest_endpoint,omitempty" db:"worker_rest_endpoint,omitempty" url:"worker_rest_endpoint,omitempty"`
	// the operation that we want to perform on this connector. to be set by the scheduler, and consumed and executed by downstream services.
	DesiredState   ConnectorSpec_DesiredState `protobuf:"varint,7,opt,name=desired_state,json=desiredState,proto3,enum=operator.v1.ConnectorSpec_DesiredState" json:"desired_state,omitempty" db:"desired_state,omitempty" url:"desired_state,omitempty"`
	PluginType     string                     `protobuf:"bytes,8,opt,name=plugin_type,json=pluginType,proto3" json:"plugin_type,omitempty" db:"plugin_type,omitempty" url:"plugin_type,omitempty"`
	PluginMetadata *PluginMetadata            `protobuf:"bytes,9,opt,name=plugin_metadata,json=pluginMetadata,proto3" json:"plugin_metadata,omitempty" db:"plugin_metadata,omitempty" url:"plugin_metadata,omitempty"`
	// configs that were applied to Worker, actual configs
	ActualConfigs *ConnectorConfigs    `protobuf:"bytes,10,opt,name=actual_configs,json=actualConfigs,proto3" json:"actual_configs,omitempty" db:"actual_configs,omitempty" url:"actual_configs,omitempty"`
	FeatureFlags  *ConnectFeatureFlags `protobuf:"bytes,11,opt,name=feature_flags,json=featureFlags,proto3" json:"feature_flags,omitempty" db:"feature_flags,omitempty" url:"feature_flags,omitempty"`
	// epoch beyond which connector should be deleted (if non zero)
	// introduced to delete data previews after running for some time
	ScheduledDeleteTimestamp int64 `protobuf:"varint,12,opt,name=scheduled_delete_timestamp,json=scheduledDeleteTimestamp,proto3" json:"scheduled_delete_timestamp,omitempty" db:"scheduled_delete_timestamp,omitempty" url:"scheduled_delete_timestamp,omitempty"`
	// config overrides that are applied to the connector's low level configs. these are merged
	// with the low-level configs that the `configs` (desired configs) above translate to by the deletegating rest extension.
	OverrideConfigs *ConnectorConfigs `protobuf:"bytes,13,opt,name=override_configs,json=overrideConfigs,proto3" json:"override_configs,omitempty" db:"override_configs,omitempty" url:"override_configs,omitempty"`
	// connector creation_timestamp
	CreationTimestamp    int64    `protobuf:"varint,14,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty" db:"creation_timestamp,omitempty" url:"creation_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorSpec) Reset()         { *m = ConnectorSpec{} }
func (m *ConnectorSpec) String() string { return proto.CompactTextString(m) }
func (*ConnectorSpec) ProtoMessage()    {}
func (*ConnectorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{5}
}
func (m *ConnectorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorSpec.Merge(m, src)
}
func (m *ConnectorSpec) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorSpec proto.InternalMessageInfo

func (m *ConnectorSpec) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ConnectorSpec) GetPhysicalClusterId() string {
	if m != nil {
		return m.PhysicalClusterId
	}
	return ""
}

func (m *ConnectorSpec) GetDeprecatedPlugin() ConnectPlugin {
	if m != nil {
		return m.DeprecatedPlugin
	}
	return ConnectPlugin_S3_SINK
}

func (m *ConnectorSpec) GetInternalCluster() *KafkaDependency {
	if m != nil {
		return m.InternalCluster
	}
	return nil
}

func (m *ConnectorSpec) GetConfigs() *ConnectorConfigs {
	if m != nil {
		return m.Configs
	}
	return nil
}

func (m *ConnectorSpec) GetWorkerRestEndpoint() string {
	if m != nil {
		return m.WorkerRestEndpoint
	}
	return ""
}

func (m *ConnectorSpec) GetDesiredState() ConnectorSpec_DesiredState {
	if m != nil {
		return m.DesiredState
	}
	return ConnectorSpec_NONE
}

func (m *ConnectorSpec) GetPluginType() string {
	if m != nil {
		return m.PluginType
	}
	return ""
}

func (m *ConnectorSpec) GetPluginMetadata() *PluginMetadata {
	if m != nil {
		return m.PluginMetadata
	}
	return nil
}

func (m *ConnectorSpec) GetActualConfigs() *ConnectorConfigs {
	if m != nil {
		return m.ActualConfigs
	}
	return nil
}

func (m *ConnectorSpec) GetFeatureFlags() *ConnectFeatureFlags {
	if m != nil {
		return m.FeatureFlags
	}
	return nil
}

func (m *ConnectorSpec) GetScheduledDeleteTimestamp() int64 {
	if m != nil {
		return m.ScheduledDeleteTimestamp
	}
	return 0
}

func (m *ConnectorSpec) GetOverrideConfigs() *ConnectorConfigs {
	if m != nil {
		return m.OverrideConfigs
	}
	return nil
}

func (m *ConnectorSpec) GetCreationTimestamp() int64 {
	if m != nil {
		return m.CreationTimestamp
	}
	return 0
}

type ConnectFeatureFlags struct {
	DelegatingServiceEnabled      bool     `protobuf:"varint,1,opt,name=delegating_service_enabled,json=delegatingServiceEnabled,proto3" json:"delegating_service_enabled,omitempty" db:"delegating_service_enabled,omitempty" url:"delegating_service_enabled,omitempty"`
	OperatorPollStatusDarkEnabled bool     `protobuf:"varint,2,opt,name=operator_poll_status_dark_enabled,json=operatorPollStatusDarkEnabled,proto3" json:"operator_poll_status_dark_enabled,omitempty" db:"operator_poll_status_dark_enabled,omitempty" url:"operator_poll_status_dark_enabled,omitempty"`
	OperatorPollStatusProdEnabled bool     `protobuf:"varint,3,opt,name=operator_poll_status_prod_enabled,json=operatorPollStatusProdEnabled,proto3" json:"operator_poll_status_prod_enabled,omitempty" db:"operator_poll_status_prod_enabled,omitempty" url:"operator_poll_status_prod_enabled,omitempty"`
	XXX_NoUnkeyedLiteral          struct{} `json:"-"`
	XXX_unrecognized              []byte   `json:"-"`
	XXX_sizecache                 int32    `json:"-"`
}

func (m *ConnectFeatureFlags) Reset()         { *m = ConnectFeatureFlags{} }
func (m *ConnectFeatureFlags) String() string { return proto.CompactTextString(m) }
func (*ConnectFeatureFlags) ProtoMessage()    {}
func (*ConnectFeatureFlags) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{6}
}
func (m *ConnectFeatureFlags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectFeatureFlags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectFeatureFlags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectFeatureFlags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectFeatureFlags.Merge(m, src)
}
func (m *ConnectFeatureFlags) XXX_Size() int {
	return m.Size()
}
func (m *ConnectFeatureFlags) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectFeatureFlags.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectFeatureFlags proto.InternalMessageInfo

func (m *ConnectFeatureFlags) GetDelegatingServiceEnabled() bool {
	if m != nil {
		return m.DelegatingServiceEnabled
	}
	return false
}

func (m *ConnectFeatureFlags) GetOperatorPollStatusDarkEnabled() bool {
	if m != nil {
		return m.OperatorPollStatusDarkEnabled
	}
	return false
}

func (m *ConnectFeatureFlags) GetOperatorPollStatusProdEnabled() bool {
	if m != nil {
		return m.OperatorPollStatusProdEnabled
	}
	return false
}

type PluginMetadata struct {
	ProductMaturityPhase ProductMaturityPhase_Values `protobuf:"varint,1,opt,name=product_maturity_phase,json=productMaturityPhase,proto3,enum=operator.v1.ProductMaturityPhase_Values" json:"product_maturity_phase,omitempty" db:"product_maturity_phase,omitempty" url:"product_maturity_phase,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PluginMetadata) Reset()         { *m = PluginMetadata{} }
func (m *PluginMetadata) String() string { return proto.CompactTextString(m) }
func (*PluginMetadata) ProtoMessage()    {}
func (*PluginMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{7}
}
func (m *PluginMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginMetadata.Merge(m, src)
}
func (m *PluginMetadata) XXX_Size() int {
	return m.Size()
}
func (m *PluginMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_PluginMetadata proto.InternalMessageInfo

func (m *PluginMetadata) GetProductMaturityPhase() ProductMaturityPhase_Values {
	if m != nil {
		return m.ProductMaturityPhase
	}
	return ProductMaturityPhase_NONE
}

type ConnectorConfigs struct {
	// template used for materializing configs
	TemplateId string `protobuf:"bytes,1,opt,name=template_id,json=templateId,proto3" json:"template_id,omitempty" db:"template_id,omitempty" url:"template_id,omitempty"`
	// the raw configs from the UI
	UserConfigs map[string]string `protobuf:"bytes,2,rep,name=user_configs,json=userConfigs,proto3" json:"user_configs,omitempty" db:"user_configs,omitempty" url:"user_configs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// ts when ANY updated was requested by user. Originall just for configs, but now used for state transition, too
	RequestedTime        *v1.Time `protobuf:"bytes,4,opt,name=requested_time,json=requestedTime,proto3" json:"requested_time,omitempty" db:"requested_time,omitempty" url:"requested_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorConfigs) Reset()         { *m = ConnectorConfigs{} }
func (m *ConnectorConfigs) String() string { return proto.CompactTextString(m) }
func (*ConnectorConfigs) ProtoMessage()    {}
func (*ConnectorConfigs) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{8}
}
func (m *ConnectorConfigs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorConfigs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorConfigs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorConfigs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorConfigs.Merge(m, src)
}
func (m *ConnectorConfigs) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorConfigs) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorConfigs.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorConfigs proto.InternalMessageInfo

func (m *ConnectorConfigs) GetTemplateId() string {
	if m != nil {
		return m.TemplateId
	}
	return ""
}

func (m *ConnectorConfigs) GetUserConfigs() map[string]string {
	if m != nil {
		return m.UserConfigs
	}
	return nil
}

func (m *ConnectorConfigs) GetRequestedTime() *v1.Time {
	if m != nil {
		return m.RequestedTime
	}
	return nil
}

type ConfigDefinition struct {
	Name                 string                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Type                 ConfigType_Values       `protobuf:"varint,2,opt,name=type,proto3,enum=operator.v1.ConfigType_Values" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	Required             bool                    `protobuf:"varint,3,opt,name=required,proto3" json:"required,omitempty" db:"required,omitempty" url:"required,omitempty"`
	DefaultValue         string                  `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty" db:"default_value,omitempty" url:"default_value,omitempty"`
	Importance           ConfigImportance_Values `protobuf:"varint,5,opt,name=importance,proto3,enum=operator.v1.ConfigImportance_Values" json:"importance,omitempty" db:"importance,omitempty" url:"importance,omitempty"`
	Documentation        string                  `protobuf:"bytes,6,opt,name=documentation,proto3" json:"documentation,omitempty" db:"documentation,omitempty" url:"documentation,omitempty"`
	Group                string                  `protobuf:"bytes,7,opt,name=group,proto3" json:"group,omitempty" db:"group,omitempty" url:"group,omitempty"`
	Width                ConfigWidth_Values      `protobuf:"varint,8,opt,name=width,proto3,enum=operator.v1.ConfigWidth_Values" json:"width,omitempty" db:"width,omitempty" url:"width,omitempty"`
	DisplayName          string                  `protobuf:"bytes,9,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty" db:"display_name,omitempty" url:"display_name,omitempty"`
	Dependents           []string                `protobuf:"bytes,10,rep,name=dependents,proto3" json:"dependents,omitempty" db:"dependents,omitempty" url:"dependents,omitempty"`
	Order                int32                   `protobuf:"varint,11,opt,name=order,proto3" json:"order,omitempty" db:"order,omitempty" url:"order,omitempty"`
	Alias                string                  `protobuf:"bytes,12,opt,name=alias,proto3" json:"alias,omitempty" db:"alias,omitempty" url:"alias,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ConfigDefinition) Reset()         { *m = ConfigDefinition{} }
func (m *ConfigDefinition) String() string { return proto.CompactTextString(m) }
func (*ConfigDefinition) ProtoMessage()    {}
func (*ConfigDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{9}
}
func (m *ConfigDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigDefinition.Merge(m, src)
}
func (m *ConfigDefinition) XXX_Size() int {
	return m.Size()
}
func (m *ConfigDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigDefinition proto.InternalMessageInfo

func (m *ConfigDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigDefinition) GetType() ConfigType_Values {
	if m != nil {
		return m.Type
	}
	return ConfigType_NONE
}

func (m *ConfigDefinition) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *ConfigDefinition) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

func (m *ConfigDefinition) GetImportance() ConfigImportance_Values {
	if m != nil {
		return m.Importance
	}
	return ConfigImportance_NONE
}

func (m *ConfigDefinition) GetDocumentation() string {
	if m != nil {
		return m.Documentation
	}
	return ""
}

func (m *ConfigDefinition) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *ConfigDefinition) GetWidth() ConfigWidth_Values {
	if m != nil {
		return m.Width
	}
	return ConfigWidth_NONE
}

func (m *ConfigDefinition) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *ConfigDefinition) GetDependents() []string {
	if m != nil {
		return m.Dependents
	}
	return nil
}

func (m *ConfigDefinition) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *ConfigDefinition) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type ConfigValue struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" db:"value,omitempty" url:"value,omitempty"`
	RecommendedValues    []string `protobuf:"bytes,3,rep,name=recommended_values,json=recommendedValues,proto3" json:"recommended_values,omitempty" db:"recommended_values,omitempty" url:"recommended_values,omitempty"`
	Errors               []string `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty" db:"errors,omitempty" url:"errors,omitempty"`
	Visible              bool     `protobuf:"varint,5,opt,name=visible,proto3" json:"visible,omitempty" db:"visible,omitempty" url:"visible,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigValue) Reset()         { *m = ConfigValue{} }
func (m *ConfigValue) String() string { return proto.CompactTextString(m) }
func (*ConfigValue) ProtoMessage()    {}
func (*ConfigValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{10}
}
func (m *ConfigValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigValue.Merge(m, src)
}
func (m *ConfigValue) XXX_Size() int {
	return m.Size()
}
func (m *ConfigValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigValue.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigValue proto.InternalMessageInfo

func (m *ConfigValue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *ConfigValue) GetRecommendedValues() []string {
	if m != nil {
		return m.RecommendedValues
	}
	return nil
}

func (m *ConfigValue) GetErrors() []string {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *ConfigValue) GetVisible() bool {
	if m != nil {
		return m.Visible
	}
	return false
}

type Configs struct {
	Definition           *ConfigDefinition `protobuf:"bytes,1,opt,name=definition,proto3" json:"definition,omitempty" db:"definition,omitempty" url:"definition,omitempty"`
	Value                *ConfigValue      `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" db:"value,omitempty" url:"value,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" db:"metadata,omitempty" url:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Configs) Reset()         { *m = Configs{} }
func (m *Configs) String() string { return proto.CompactTextString(m) }
func (*Configs) ProtoMessage()    {}
func (*Configs) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{11}
}
func (m *Configs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Configs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Configs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Configs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Configs.Merge(m, src)
}
func (m *Configs) XXX_Size() int {
	return m.Size()
}
func (m *Configs) XXX_DiscardUnknown() {
	xxx_messageInfo_Configs.DiscardUnknown(m)
}

var xxx_messageInfo_Configs proto.InternalMessageInfo

func (m *Configs) GetDefinition() *ConfigDefinition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *Configs) GetValue() *ConfigValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Configs) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type ValidatedConnectorConfig struct {
	Name       string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	ErrorCount int32    `protobuf:"varint,2,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty" db:"error_count,omitempty" url:"error_count,omitempty"`
	Groups     []string `protobuf:"bytes,3,rep,name=groups,proto3" json:"groups,omitempty" db:"groups,omitempty" url:"groups,omitempty"`
	// a collection of config definitions and their values. all secrets will be masked.
	Configs              []*Configs        `protobuf:"bytes,4,rep,name=configs,proto3" json:"configs,omitempty" db:"configs,omitempty" url:"configs,omitempty"`
	MaterializedConfigs  map[string]string `protobuf:"bytes,5,rep,name=materialized_configs,json=materializedConfigs,proto3" json:"materialized_configs,omitempty" db:"materialized_configs,omitempty" url:"materialized_configs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"` // Deprecated: Do not use.
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ValidatedConnectorConfig) Reset()         { *m = ValidatedConnectorConfig{} }
func (m *ValidatedConnectorConfig) String() string { return proto.CompactTextString(m) }
func (*ValidatedConnectorConfig) ProtoMessage()    {}
func (*ValidatedConnectorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{12}
}
func (m *ValidatedConnectorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatedConnectorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatedConnectorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatedConnectorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatedConnectorConfig.Merge(m, src)
}
func (m *ValidatedConnectorConfig) XXX_Size() int {
	return m.Size()
}
func (m *ValidatedConnectorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatedConnectorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatedConnectorConfig proto.InternalMessageInfo

func (m *ValidatedConnectorConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ValidatedConnectorConfig) GetErrorCount() int32 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

func (m *ValidatedConnectorConfig) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ValidatedConnectorConfig) GetConfigs() []*Configs {
	if m != nil {
		return m.Configs
	}
	return nil
}

// Deprecated: Do not use.
func (m *ValidatedConnectorConfig) GetMaterializedConfigs() map[string]string {
	if m != nil {
		return m.MaterializedConfigs
	}
	return nil
}

type ConfigType struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigType) Reset()         { *m = ConfigType{} }
func (m *ConfigType) String() string { return proto.CompactTextString(m) }
func (*ConfigType) ProtoMessage()    {}
func (*ConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{13}
}
func (m *ConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigType.Merge(m, src)
}
func (m *ConfigType) XXX_Size() int {
	return m.Size()
}
func (m *ConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigType proto.InternalMessageInfo

type ConfigWidth struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigWidth) Reset()         { *m = ConfigWidth{} }
func (m *ConfigWidth) String() string { return proto.CompactTextString(m) }
func (*ConfigWidth) ProtoMessage()    {}
func (*ConfigWidth) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{14}
}
func (m *ConfigWidth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigWidth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigWidth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigWidth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigWidth.Merge(m, src)
}
func (m *ConfigWidth) XXX_Size() int {
	return m.Size()
}
func (m *ConfigWidth) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigWidth.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigWidth proto.InternalMessageInfo

type ConfigImportance struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigImportance) Reset()         { *m = ConfigImportance{} }
func (m *ConfigImportance) String() string { return proto.CompactTextString(m) }
func (*ConfigImportance) ProtoMessage()    {}
func (*ConfigImportance) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{15}
}
func (m *ConfigImportance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigImportance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigImportance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigImportance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigImportance.Merge(m, src)
}
func (m *ConfigImportance) XXX_Size() int {
	return m.Size()
}
func (m *ConfigImportance) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigImportance.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigImportance proto.InternalMessageInfo

type ConnectorState struct {
	State                string   `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty" db:"state,omitempty" url:"state,omitempty"`
	WorkerId             string   `protobuf:"bytes,2,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty" db:"worker_id,omitempty" url:"worker_id,omitempty"`
	Trace                string   `protobuf:"bytes,3,opt,name=trace,proto3" json:"trace,omitempty" db:"trace,omitempty" url:"trace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorState) Reset()         { *m = ConnectorState{} }
func (m *ConnectorState) String() string { return proto.CompactTextString(m) }
func (*ConnectorState) ProtoMessage()    {}
func (*ConnectorState) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{16}
}
func (m *ConnectorState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorState.Merge(m, src)
}
func (m *ConnectorState) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorState.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorState proto.InternalMessageInfo

func (m *ConnectorState) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *ConnectorState) GetWorkerId() string {
	if m != nil {
		return m.WorkerId
	}
	return ""
}

func (m *ConnectorState) GetTrace() string {
	if m != nil {
		return m.Trace
	}
	return ""
}

type TaskState struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	State                string   `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty" db:"state,omitempty" url:"state,omitempty"`
	WorkerId             string   `protobuf:"bytes,3,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty" db:"worker_id,omitempty" url:"worker_id,omitempty"`
	Msg                  string   `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg,omitempty" db:"msg,omitempty" url:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaskState) Reset()         { *m = TaskState{} }
func (m *TaskState) String() string { return proto.CompactTextString(m) }
func (*TaskState) ProtoMessage()    {}
func (*TaskState) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{17}
}
func (m *TaskState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskState.Merge(m, src)
}
func (m *TaskState) XXX_Size() int {
	return m.Size()
}
func (m *TaskState) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskState.DiscardUnknown(m)
}

var xxx_messageInfo_TaskState proto.InternalMessageInfo

func (m *TaskState) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TaskState) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *TaskState) GetWorkerId() string {
	if m != nil {
		return m.WorkerId
	}
	return ""
}

func (m *TaskState) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type ConnectorStateInfo struct {
	Name      string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Connector *ConnectorState `protobuf:"bytes,2,opt,name=connector,proto3" json:"connector,omitempty" db:"connector,omitempty" url:"connector,omitempty"`
	Tasks     []*TaskState    `protobuf:"bytes,3,rep,name=tasks,proto3" json:"tasks,omitempty" db:"tasks,omitempty" url:"tasks,omitempty"`
	//lowercase of kafka.scheduler.v1.ConnectorType
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorStateInfo) Reset()         { *m = ConnectorStateInfo{} }
func (m *ConnectorStateInfo) String() string { return proto.CompactTextString(m) }
func (*ConnectorStateInfo) ProtoMessage()    {}
func (*ConnectorStateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{18}
}
func (m *ConnectorStateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorStateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorStateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorStateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorStateInfo.Merge(m, src)
}
func (m *ConnectorStateInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorStateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorStateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorStateInfo proto.InternalMessageInfo

func (m *ConnectorStateInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConnectorStateInfo) GetConnector() *ConnectorState {
	if m != nil {
		return m.Connector
	}
	return nil
}

func (m *ConnectorStateInfo) GetTasks() []*TaskState {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *ConnectorStateInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type ProductMaturityPhase struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProductMaturityPhase) Reset()         { *m = ProductMaturityPhase{} }
func (m *ProductMaturityPhase) String() string { return proto.CompactTextString(m) }
func (*ProductMaturityPhase) ProtoMessage()    {}
func (*ProductMaturityPhase) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{19}
}
func (m *ProductMaturityPhase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductMaturityPhase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductMaturityPhase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductMaturityPhase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductMaturityPhase.Merge(m, src)
}
func (m *ProductMaturityPhase) XXX_Size() int {
	return m.Size()
}
func (m *ProductMaturityPhase) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductMaturityPhase.DiscardUnknown(m)
}

var xxx_messageInfo_ProductMaturityPhase proto.InternalMessageInfo

type ConnectorIdType struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorIdType) Reset()         { *m = ConnectorIdType{} }
func (m *ConnectorIdType) String() string { return proto.CompactTextString(m) }
func (*ConnectorIdType) ProtoMessage()    {}
func (*ConnectorIdType) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{20}
}
func (m *ConnectorIdType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorIdType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorIdType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorIdType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorIdType.Merge(m, src)
}
func (m *ConnectorIdType) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorIdType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorIdType.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorIdType proto.InternalMessageInfo

type ConnectorId struct {
	Id                   string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	IdType               ConnectorIdType_Values `protobuf:"varint,2,opt,name=id_type,json=idType,proto3,enum=operator.v1.ConnectorIdType_Values" json:"id_type,omitempty" db:"id_type,omitempty" url:"id_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ConnectorId) Reset()         { *m = ConnectorId{} }
func (m *ConnectorId) String() string { return proto.CompactTextString(m) }
func (*ConnectorId) ProtoMessage()    {}
func (*ConnectorId) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{21}
}
func (m *ConnectorId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorId.Merge(m, src)
}
func (m *ConnectorId) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorId) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorId.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorId proto.InternalMessageInfo

func (m *ConnectorId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ConnectorId) GetIdType() ConnectorIdType_Values {
	if m != nil {
		return m.IdType
	}
	return ConnectorIdType_NONE
}

type ConnectorPluginInfo struct {
	Class string `protobuf:"bytes,1,opt,name=class,proto3" json:"class,omitempty" db:"class,omitempty" url:"class,omitempty"`
	//lowercase of kafka.scheduler.v1.ConnectorType
	Type                 string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	Version              string   `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty" db:"version,omitempty" url:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorPluginInfo) Reset()         { *m = ConnectorPluginInfo{} }
func (m *ConnectorPluginInfo) String() string { return proto.CompactTextString(m) }
func (*ConnectorPluginInfo) ProtoMessage()    {}
func (*ConnectorPluginInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{22}
}
func (m *ConnectorPluginInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorPluginInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorPluginInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorPluginInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorPluginInfo.Merge(m, src)
}
func (m *ConnectorPluginInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorPluginInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorPluginInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorPluginInfo proto.InternalMessageInfo

func (m *ConnectorPluginInfo) GetClass() string {
	if m != nil {
		return m.Class
	}
	return ""
}

func (m *ConnectorPluginInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ConnectorPluginInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type ConnectorPluginDisplayInfo struct {
	ImageUrl             string                      `protobuf:"bytes,1,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty" db:"image_url,omitempty" url:"image_url,omitempty"`
	ProductMaturityPhase ProductMaturityPhase_Values `protobuf:"varint,2,opt,name=product_maturity_phase,json=productMaturityPhase,proto3,enum=operator.v1.ProductMaturityPhase_Values" json:"product_maturity_phase,omitempty" db:"product_maturity_phase,omitempty" url:"product_maturity_phase,omitempty"`
	DisplayName          string                      `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty" db:"display_name,omitempty" url:"display_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ConnectorPluginDisplayInfo) Reset()         { *m = ConnectorPluginDisplayInfo{} }
func (m *ConnectorPluginDisplayInfo) String() string { return proto.CompactTextString(m) }
func (*ConnectorPluginDisplayInfo) ProtoMessage()    {}
func (*ConnectorPluginDisplayInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{23}
}
func (m *ConnectorPluginDisplayInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorPluginDisplayInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorPluginDisplayInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorPluginDisplayInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorPluginDisplayInfo.Merge(m, src)
}
func (m *ConnectorPluginDisplayInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorPluginDisplayInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorPluginDisplayInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorPluginDisplayInfo proto.InternalMessageInfo

func (m *ConnectorPluginDisplayInfo) GetImageUrl() string {
	if m != nil {
		return m.ImageUrl
	}
	return ""
}

func (m *ConnectorPluginDisplayInfo) GetProductMaturityPhase() ProductMaturityPhase_Values {
	if m != nil {
		return m.ProductMaturityPhase
	}
	return ProductMaturityPhase_NONE
}

func (m *ConnectorPluginDisplayInfo) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

type ConnectorPluginValidationParameters struct {
	ValidateTemplatedVpc bool     `protobuf:"varint,1,opt,name=validate_templated_vpc,json=validateTemplatedVpc,proto3" json:"validate_templated_vpc,omitempty" db:"validate_templated_vpc,omitempty" url:"validate_templated_vpc,omitempty"`
	ValidateDelegatedVpc bool     `protobuf:"varint,2,opt,name=validate_delegated_vpc,json=validateDelegatedVpc,proto3" json:"validate_delegated_vpc,omitempty" db:"validate_delegated_vpc,omitempty" url:"validate_delegated_vpc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorPluginValidationParameters) Reset()         { *m = ConnectorPluginValidationParameters{} }
func (m *ConnectorPluginValidationParameters) String() string { return proto.CompactTextString(m) }
func (*ConnectorPluginValidationParameters) ProtoMessage()    {}
func (*ConnectorPluginValidationParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{24}
}
func (m *ConnectorPluginValidationParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorPluginValidationParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorPluginValidationParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorPluginValidationParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorPluginValidationParameters.Merge(m, src)
}
func (m *ConnectorPluginValidationParameters) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorPluginValidationParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorPluginValidationParameters.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorPluginValidationParameters proto.InternalMessageInfo

func (m *ConnectorPluginValidationParameters) GetValidateTemplatedVpc() bool {
	if m != nil {
		return m.ValidateTemplatedVpc
	}
	return false
}

func (m *ConnectorPluginValidationParameters) GetValidateDelegatedVpc() bool {
	if m != nil {
		return m.ValidateDelegatedVpc
	}
	return false
}

type ConnectorExpansion struct {
	Status               *ConnectorStateInfo `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty" db:"status,omitempty" url:"status,omitempty"`
	Info                 *ConnectorInfo      `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty" db:"info,omitempty" url:"info,omitempty"`
	Id                   *ConnectorId        `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	Extensions           map[string]string   `protobuf:"bytes,4,rep,name=extensions,proto3" json:"extensions,omitempty" db:"extensions,omitempty" url:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ConnectorExpansion) Reset()         { *m = ConnectorExpansion{} }
func (m *ConnectorExpansion) String() string { return proto.CompactTextString(m) }
func (*ConnectorExpansion) ProtoMessage()    {}
func (*ConnectorExpansion) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{25}
}
func (m *ConnectorExpansion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorExpansion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorExpansion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorExpansion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorExpansion.Merge(m, src)
}
func (m *ConnectorExpansion) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorExpansion) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorExpansion.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorExpansion proto.InternalMessageInfo

func (m *ConnectorExpansion) GetStatus() *ConnectorStateInfo {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ConnectorExpansion) GetInfo() *ConnectorInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ConnectorExpansion) GetId() *ConnectorId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ConnectorExpansion) GetExtensions() map[string]string {
	if m != nil {
		return m.Extensions
	}
	return nil
}

type ConnectorPluginExpansion struct {
	Display              *ConnectorPluginDisplayInfo `protobuf:"bytes,1,opt,name=display,proto3" json:"display,omitempty" db:"display,omitempty" url:"display,omitempty"`
	Info                 *ConnectorPluginInfo        `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty" db:"info,omitempty" url:"info,omitempty"`
	Extensions           map[string]string           `protobuf:"bytes,3,rep,name=extensions,proto3" json:"extensions,omitempty" db:"extensions,omitempty" url:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ConnectorPluginExpansion) Reset()         { *m = ConnectorPluginExpansion{} }
func (m *ConnectorPluginExpansion) String() string { return proto.CompactTextString(m) }
func (*ConnectorPluginExpansion) ProtoMessage()    {}
func (*ConnectorPluginExpansion) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{26}
}
func (m *ConnectorPluginExpansion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorPluginExpansion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorPluginExpansion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorPluginExpansion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorPluginExpansion.Merge(m, src)
}
func (m *ConnectorPluginExpansion) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorPluginExpansion) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorPluginExpansion.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorPluginExpansion proto.InternalMessageInfo

func (m *ConnectorPluginExpansion) GetDisplay() *ConnectorPluginDisplayInfo {
	if m != nil {
		return m.Display
	}
	return nil
}

func (m *ConnectorPluginExpansion) GetInfo() *ConnectorPluginInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ConnectorPluginExpansion) GetExtensions() map[string]string {
	if m != nil {
		return m.Extensions
	}
	return nil
}

type ConnectorInfo struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	//lowercase of kafka.scheduler.v1.ConnectorType
	Type                 string             `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	Config               map[string]string  `protobuf:"bytes,3,rep,name=config,proto3" json:"config,omitempty" db:"config,omitempty" url:"config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Tasks                []*ConnectorTaskId `protobuf:"bytes,4,rep,name=tasks,proto3" json:"tasks,omitempty" db:"tasks,omitempty" url:"tasks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ConnectorInfo) Reset()         { *m = ConnectorInfo{} }
func (m *ConnectorInfo) String() string { return proto.CompactTextString(m) }
func (*ConnectorInfo) ProtoMessage()    {}
func (*ConnectorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{27}
}
func (m *ConnectorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorInfo.Merge(m, src)
}
func (m *ConnectorInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorInfo proto.InternalMessageInfo

func (m *ConnectorInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConnectorInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ConnectorInfo) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ConnectorInfo) GetTasks() []*ConnectorTaskId {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type ConnectorTaskId struct {
	Connector            string   `protobuf:"bytes,1,opt,name=connector,proto3" json:"connector,omitempty" db:"connector,omitempty" url:"connector,omitempty"`
	Task                 int32    `protobuf:"varint,2,opt,name=task,proto3" json:"task,omitempty" db:"task,omitempty" url:"task,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorTaskId) Reset()         { *m = ConnectorTaskId{} }
func (m *ConnectorTaskId) String() string { return proto.CompactTextString(m) }
func (*ConnectorTaskId) ProtoMessage()    {}
func (*ConnectorTaskId) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{28}
}
func (m *ConnectorTaskId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorTaskId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorTaskId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorTaskId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorTaskId.Merge(m, src)
}
func (m *ConnectorTaskId) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorTaskId) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorTaskId.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorTaskId proto.InternalMessageInfo

func (m *ConnectorTaskId) GetConnector() string {
	if m != nil {
		return m.Connector
	}
	return ""
}

func (m *ConnectorTaskId) GetTask() int32 {
	if m != nil {
		return m.Task
	}
	return 0
}

type TaskInfo struct {
	Id                   *ConnectorTaskId  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	Config               map[string]string `protobuf:"bytes,2,rep,name=config,proto3" json:"config,omitempty" db:"config,omitempty" url:"config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TaskInfo) Reset()         { *m = TaskInfo{} }
func (m *TaskInfo) String() string { return proto.CompactTextString(m) }
func (*TaskInfo) ProtoMessage()    {}
func (*TaskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{29}
}
func (m *TaskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskInfo.Merge(m, src)
}
func (m *TaskInfo) XXX_Size() int {
	return m.Size()
}
func (m *TaskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TaskInfo proto.InternalMessageInfo

func (m *TaskInfo) GetId() *ConnectorTaskId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TaskInfo) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

type ConfigInfos struct {
	Name                 string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Groups               []string   `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty" db:"groups,omitempty" url:"groups,omitempty"`
	ErrorCount           int32      `protobuf:"varint,3,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty" db:"error_count,omitempty" url:"error_count,omitempty"`
	Configs              []*Configs `protobuf:"bytes,4,rep,name=configs,proto3" json:"configs,omitempty" db:"configs,omitempty" url:"configs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ConfigInfos) Reset()         { *m = ConfigInfos{} }
func (m *ConfigInfos) String() string { return proto.CompactTextString(m) }
func (*ConfigInfos) ProtoMessage()    {}
func (*ConfigInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{30}
}
func (m *ConfigInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigInfos.Merge(m, src)
}
func (m *ConfigInfos) XXX_Size() int {
	return m.Size()
}
func (m *ConfigInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigInfos.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigInfos proto.InternalMessageInfo

func (m *ConfigInfos) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigInfos) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ConfigInfos) GetErrorCount() int32 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

func (m *ConfigInfos) GetConfigs() []*Configs {
	if m != nil {
		return m.Configs
	}
	return nil
}

type ConnectorPlugin struct {
	Name                 string                               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Clouds               string                               `protobuf:"bytes,2,opt,name=clouds,proto3" json:"clouds,omitempty" db:"clouds,omitempty" url:"clouds,omitempty"`
	Plugin               *ConnectorPluginInfo                 `protobuf:"bytes,3,opt,name=plugin,proto3" json:"plugin,omitempty" db:"plugin,omitempty" url:"plugin,omitempty"`
	Display              *ConnectorPluginDisplayInfo          `protobuf:"bytes,4,opt,name=display,proto3" json:"display,omitempty" db:"display,omitempty" url:"display,omitempty"`
	ValidationParameters *ConnectorPluginValidationParameters `protobuf:"bytes,5,opt,name=validation_parameters,json=validationParameters,proto3" json:"validation_parameters,omitempty" db:"validation_parameters,omitempty" url:"validation_parameters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *ConnectorPlugin) Reset()         { *m = ConnectorPlugin{} }
func (m *ConnectorPlugin) String() string { return proto.CompactTextString(m) }
func (*ConnectorPlugin) ProtoMessage()    {}
func (*ConnectorPlugin) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{31}
}
func (m *ConnectorPlugin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorPlugin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorPlugin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorPlugin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorPlugin.Merge(m, src)
}
func (m *ConnectorPlugin) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorPlugin) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorPlugin.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorPlugin proto.InternalMessageInfo

func (m *ConnectorPlugin) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConnectorPlugin) GetClouds() string {
	if m != nil {
		return m.Clouds
	}
	return ""
}

func (m *ConnectorPlugin) GetPlugin() *ConnectorPluginInfo {
	if m != nil {
		return m.Plugin
	}
	return nil
}

func (m *ConnectorPlugin) GetDisplay() *ConnectorPluginDisplayInfo {
	if m != nil {
		return m.Display
	}
	return nil
}

func (m *ConnectorPlugin) GetValidationParameters() *ConnectorPluginValidationParameters {
	if m != nil {
		return m.ValidationParameters
	}
	return nil
}

type ConnectOverrideMessage struct {
	ErrorMessage         string   `protobuf:"bytes,1,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty" db:"error_message,omitempty" url:"error_message,omitempty"`
	UserMessage          string   `protobuf:"bytes,2,opt,name=user_message,json=userMessage,proto3" json:"user_message,omitempty" db:"user_message,omitempty" url:"user_message,omitempty"`
	ConnectorType        string   `protobuf:"bytes,3,opt,name=connector_type,json=connectorType,proto3" json:"connector_type,omitempty" db:"connector_type,omitempty" url:"connector_type,omitempty"`
	ErrorMappingId       int32    `protobuf:"varint,4,opt,name=error_mapping_id,json=errorMappingId,proto3" json:"error_mapping_id,omitempty" db:"error_mapping_id,omitempty" url:"error_mapping_id,omitempty"`
	CheckLd              bool     `protobuf:"varint,5,opt,name=check_ld,json=checkLd,proto3" json:"check_ld,omitempty" db:"check_ld,omitempty" url:"check_ld,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectOverrideMessage) Reset()         { *m = ConnectOverrideMessage{} }
func (m *ConnectOverrideMessage) String() string { return proto.CompactTextString(m) }
func (*ConnectOverrideMessage) ProtoMessage()    {}
func (*ConnectOverrideMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{32}
}
func (m *ConnectOverrideMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectOverrideMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectOverrideMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectOverrideMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectOverrideMessage.Merge(m, src)
}
func (m *ConnectOverrideMessage) XXX_Size() int {
	return m.Size()
}
func (m *ConnectOverrideMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectOverrideMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectOverrideMessage proto.InternalMessageInfo

func (m *ConnectOverrideMessage) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *ConnectOverrideMessage) GetUserMessage() string {
	if m != nil {
		return m.UserMessage
	}
	return ""
}

func (m *ConnectOverrideMessage) GetConnectorType() string {
	if m != nil {
		return m.ConnectorType
	}
	return ""
}

func (m *ConnectOverrideMessage) GetErrorMappingId() int32 {
	if m != nil {
		return m.ErrorMappingId
	}
	return 0
}

func (m *ConnectOverrideMessage) GetCheckLd() bool {
	if m != nil {
		return m.CheckLd
	}
	return false
}

// Holds all the connect error message overrides
type ConnectOverrideMap struct {
	ConnectOverrides     []*ConnectOverrideMessage `protobuf:"bytes,1,rep,name=connect_overrides,json=connectOverrides,proto3" json:"connect_overrides,omitempty" db:"connect_overrides,omitempty" url:"connect_overrides,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ConnectOverrideMap) Reset()         { *m = ConnectOverrideMap{} }
func (m *ConnectOverrideMap) String() string { return proto.CompactTextString(m) }
func (*ConnectOverrideMap) ProtoMessage()    {}
func (*ConnectOverrideMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_349e733de1b29479, []int{33}
}
func (m *ConnectOverrideMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectOverrideMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectOverrideMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectOverrideMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectOverrideMap.Merge(m, src)
}
func (m *ConnectOverrideMap) XXX_Size() int {
	return m.Size()
}
func (m *ConnectOverrideMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectOverrideMap.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectOverrideMap proto.InternalMessageInfo

func (m *ConnectOverrideMap) GetConnectOverrides() []*ConnectOverrideMessage {
	if m != nil {
		return m.ConnectOverrides
	}
	return nil
}

func init() {
	proto.RegisterEnum("operator.v1.ConnectPlugin", ConnectPlugin_name, ConnectPlugin_value)
	proto.RegisterEnum("operator.v1.ConnectorStatus_Status", ConnectorStatus_Status_name, ConnectorStatus_Status_value)
	proto.RegisterEnum("operator.v1.ActualState_Values", ActualState_Values_name, ActualState_Values_value)
	proto.RegisterEnum("operator.v1.ConnectorSpec_DesiredState", ConnectorSpec_DesiredState_name, ConnectorSpec_DesiredState_value)
	proto.RegisterEnum("operator.v1.ConfigType_Values", ConfigType_Values_name, ConfigType_Values_value)
	proto.RegisterEnum("operator.v1.ConfigWidth_Values", ConfigWidth_Values_name, ConfigWidth_Values_value)
	proto.RegisterEnum("operator.v1.ConfigImportance_Values", ConfigImportance_Values_name, ConfigImportance_Values_value)
	proto.RegisterEnum("operator.v1.ProductMaturityPhase_Values", ProductMaturityPhase_Values_name, ProductMaturityPhase_Values_value)
	proto.RegisterEnum("operator.v1.ConnectorIdType_Values", ConnectorIdType_Values_name, ConnectorIdType_Values_value)
	proto.RegisterType((*ConnectorList)(nil), "operator.v1.ConnectorList")
	proto.RegisterType((*Connector)(nil), "operator.v1.Connector")
	proto.RegisterType((*ConnectorStatus)(nil), "operator.v1.ConnectorStatus")
	proto.RegisterMapType((map[string]*TaskStatus)(nil), "operator.v1.ConnectorStatus.TaskStatusesEntry")
	proto.RegisterType((*TaskStatus)(nil), "operator.v1.TaskStatus")
	proto.RegisterType((*ActualState)(nil), "operator.v1.ActualState")
	proto.RegisterType((*ConnectorSpec)(nil), "operator.v1.ConnectorSpec")
	proto.RegisterType((*ConnectFeatureFlags)(nil), "operator.v1.ConnectFeatureFlags")
	proto.RegisterType((*PluginMetadata)(nil), "operator.v1.PluginMetadata")
	proto.RegisterType((*ConnectorConfigs)(nil), "operator.v1.ConnectorConfigs")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.ConnectorConfigs.UserConfigsEntry")
	proto.RegisterType((*ConfigDefinition)(nil), "operator.v1.ConfigDefinition")
	proto.RegisterType((*ConfigValue)(nil), "operator.v1.ConfigValue")
	proto.RegisterType((*Configs)(nil), "operator.v1.Configs")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.Configs.MetadataEntry")
	proto.RegisterType((*ValidatedConnectorConfig)(nil), "operator.v1.ValidatedConnectorConfig")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.ValidatedConnectorConfig.MaterializedConfigsEntry")
	proto.RegisterType((*ConfigType)(nil), "operator.v1.ConfigType")
	proto.RegisterType((*ConfigWidth)(nil), "operator.v1.ConfigWidth")
	proto.RegisterType((*ConfigImportance)(nil), "operator.v1.ConfigImportance")
	proto.RegisterType((*ConnectorState)(nil), "operator.v1.ConnectorState")
	proto.RegisterType((*TaskState)(nil), "operator.v1.TaskState")
	proto.RegisterType((*ConnectorStateInfo)(nil), "operator.v1.ConnectorStateInfo")
	proto.RegisterType((*ProductMaturityPhase)(nil), "operator.v1.ProductMaturityPhase")
	proto.RegisterType((*ConnectorIdType)(nil), "operator.v1.ConnectorIdType")
	proto.RegisterType((*ConnectorId)(nil), "operator.v1.ConnectorId")
	proto.RegisterType((*ConnectorPluginInfo)(nil), "operator.v1.ConnectorPluginInfo")
	proto.RegisterType((*ConnectorPluginDisplayInfo)(nil), "operator.v1.ConnectorPluginDisplayInfo")
	proto.RegisterType((*ConnectorPluginValidationParameters)(nil), "operator.v1.ConnectorPluginValidationParameters")
	proto.RegisterType((*ConnectorExpansion)(nil), "operator.v1.ConnectorExpansion")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.ConnectorExpansion.ExtensionsEntry")
	proto.RegisterType((*ConnectorPluginExpansion)(nil), "operator.v1.ConnectorPluginExpansion")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.ConnectorPluginExpansion.ExtensionsEntry")
	proto.RegisterType((*ConnectorInfo)(nil), "operator.v1.ConnectorInfo")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.ConnectorInfo.ConfigEntry")
	proto.RegisterType((*ConnectorTaskId)(nil), "operator.v1.ConnectorTaskId")
	proto.RegisterType((*TaskInfo)(nil), "operator.v1.TaskInfo")
	proto.RegisterMapType((map[string]string)(nil), "operator.v1.TaskInfo.ConfigEntry")
	proto.RegisterType((*ConfigInfos)(nil), "operator.v1.ConfigInfos")
	proto.RegisterType((*ConnectorPlugin)(nil), "operator.v1.ConnectorPlugin")
	proto.RegisterType((*ConnectOverrideMessage)(nil), "operator.v1.ConnectOverrideMessage")
	proto.RegisterType((*ConnectOverrideMap)(nil), "operator.v1.ConnectOverrideMap")
}

func init() { proto.RegisterFile("operator/v1/connect.proto", fileDescriptor_349e733de1b29479) }

var fileDescriptor_349e733de1b29479 = []byte{
	// 3937 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x3b, 0x5d, 0x8f, 0x24, 0xc9,
	0x51, 0xae, 0xfe, 0x98, 0xe9, 0xce, 0xf9, 0xd8, 0xde, 0xbc, 0xbd, 0x73, 0x7b, 0xcc, 0x5d, 0xaf,
	0xeb, 0x0e, 0x7b, 0x75, 0x3a, 0x7a, 0x6e, 0xef, 0x0e, 0xb3, 0x5a, 0x4e, 0xc7, 0x4d, 0x6f, 0xf7,
	0xce, 0xf6, 0x79, 0xa6, 0xa7, 0xc9, 0x9e, 0xd9, 0x35, 0xf8, 0xa0, 0xa8, 0xa9, 0xca, 0xe9, 0xad,
	0xeb, 0x8f, 0x2a, 0x57, 0x55, 0xcf, 0x7a, 0xfc, 0x60, 0x09, 0x84, 0x2d, 0x1f, 0x02, 0x5b, 0x60,
	0x3e, 0x0e, 0x24, 0x2c, 0x64, 0x24, 0x10, 0x4f, 0xf0, 0x00, 0x82, 0xe3, 0x09, 0xc4, 0x03, 0x3c,
	0xde, 0x2b, 0x3c, 0xb4, 0xd0, 0xbd, 0x20, 0xe0, 0x01, 0xd1, 0xbf, 0x00, 0xe5, 0x47, 0x65, 0x7d,
	0x64, 0x56, 0xef, 0xec, 0xce, 0xc8, 0x5a, 0x89, 0xa7, 0xe9, 0x89, 0x88, 0x8c, 0x88, 0xcc, 0x88,
	0x8c, 0x8c, 0x88, 0xcc, 0x02, 0x9f, 0x73, 0x3d, 0xec, 0x9b, 0xa1, 0xeb, 0x6f, 0x9f, 0xde, 0xdc,
	0xb6, 0xdc, 0xe9, 0x14, 0x5b, 0x61, 0xd3, 0xf3, 0xdd, 0xd0, 0x85, 0x6b, 0x11, 0xaa, 0x79, 0x7a,
	0x73, 0xeb, 0xda, 0xd0, 0x1d, 0xba, 0x14, 0xbe, 0x4d, 0x7e, 0x31, 0x92, 0xad, 0xb7, 0x46, 0xb7,
	0x82, 0xa6, 0xe3, 0x6e, 0x9b, 0x9e, 0x33, 0x31, 0xad, 0x87, 0xce, 0x14, 0xfb, 0x67, 0xdb, 0xde,
	0x68, 0x48, 0x00, 0xc1, 0xf6, 0x04, 0x87, 0x26, 0x61, 0x3b, 0xc4, 0x53, 0xc2, 0x08, 0xdb, 0x7c,
	0x54, 0x3d, 0x2d, 0x73, 0x32, 0x71, 0xa7, 0x0c, 0xa3, 0xff, 0xa8, 0x08, 0x36, 0xee, 0x30, 0x25,
	0x5c, 0x7f, 0xcf, 0x09, 0x42, 0xf8, 0x3b, 0x1a, 0xa8, 0x86, 0x67, 0x1e, 0x36, 0x08, 0xb3, 0xba,
	0x76, 0x5d, 0xbb, 0xb1, 0xf6, 0x46, 0xb3, 0xc9, 0xc4, 0x36, 0x93, 0x62, 0x9b, 0xde, 0x68, 0x48,
	0x00, 0x41, 0x93, 0x50, 0x36, 0x4f, 0x6f, 0x36, 0x0f, 0xcf, 0x3c, 0xbc, 0x8f, 0x43, 0xb3, 0xd5,
	0xf9, 0x64, 0xde, 0xd0, 0xfe, 0x6b, 0xde, 0x58, 0x7d, 0xcd, 0x99, 0x8e, 0x9d, 0x29, 0x5e, 0xcc,
	0x1b, 0x6f, 0xd8, 0xc7, 0xb7, 0x75, 0xc1, 0xf7, 0x35, 0x77, 0xe2, 0x84, 0x78, 0xe2, 0x85, 0x67,
	0xfa, 0xf5, 0x99, 0x3f, 0x56, 0x63, 0x50, 0x25, 0xe4, 0x0c, 0xe1, 0x1f, 0x6b, 0xa0, 0x3a, 0x76,
	0x82, 0x90, 0x29, 0x55, 0x78, 0x12, 0xa5, 0xc8, 0xa4, 0xa8, 0x52, 0x7d, 0xae, 0x14, 0x24, 0x18,
	0xdb, 0x4c, 0x8a, 0x8a, 0xf4, 0x13, 0x22, 0x24, 0xfd, 0x54, 0x18, 0x54, 0x19, 0x73, 0xde, 0xf0,
	0x7d, 0x50, 0x26, 0xd0, 0xa0, 0x5e, 0xbc, 0x5e, 0xbc, 0xb1, 0xf6, 0xc6, 0x0b, 0xcd, 0x84, 0x25,
	0x9b, 0x62, 0x7d, 0x5b, 0xcd, 0xc5, 0xbc, 0xf1, 0x2a, 0x11, 0x44, 0x89, 0x25, 0x21, 0x59, 0x28,
	0x62, 0x4c, 0xf5, 0x8f, 0x56, 0x41, 0x55, 0x30, 0x79, 0x36, 0x0d, 0xf4, 0xe7, 0x1a, 0x58, 0x73,
	0x8f, 0x3f, 0xc0, 0x56, 0xca, 0x44, 0xaf, 0x9f, 0x4f, 0xad, 0x03, 0x3a, 0x90, 0x2a, 0x76, 0xb8,
	0xd4, 0x48, 0x5f, 0x26, 0x3a, 0x26, 0xc4, 0x48, 0x5a, 0xaa, 0x71, 0x08, 0xb8, 0x42, 0x02, 0x3c,
	0x01, 0x2b, 0x41, 0x68, 0x86, 0x33, 0x62, 0x2b, 0xa2, 0xe3, 0x4f, 0xa8, 0x6d, 0x35, 0xa0, 0x34,
	0xad, 0xd7, 0x17, 0xf3, 0xc6, 0x6b, 0x44, 0x2a, 0x1b, 0x23, 0x09, 0x94, 0xc0, 0x88, 0x73, 0x87,
	0xef, 0x83, 0x52, 0xe0, 0x61, 0xab, 0x5e, 0xa2, 0x52, 0xb6, 0x72, 0xa4, 0x78, 0xd8, 0x6a, 0xbd,
	0xb6, 0x98, 0x37, 0x6e, 0x50, 0x19, 0x1e, 0xb6, 0x64, 0x09, 0x69, 0x20, 0xa2, 0x5c, 0xe1, 0xaf,
	0x6b, 0x60, 0x03, 0xfb, 0xbe, 0xeb, 0x1b, 0x13, 0xd3, 0xf3, 0x9c, 0xe9, 0xb0, 0x5e, 0xa6, 0x72,
	0x1a, 0x2a, 0x39, 0x07, 0xa7, 0xd8, 0xf7, 0x1d, 0x1b, 0xef, 0x9b, 0x5e, 0xeb, 0x9d, 0xc5, 0xbc,
	0x71, 0x9b, 0x08, 0x4b, 0x8d, 0x96, 0xa4, 0xe6, 0x61, 0xd1, 0x3a, 0xc5, 0xec, 0x33, 0x04, 0xdc,
	0x05, 0x2b, 0xae, 0x3f, 0x34, 0x1c, 0xbb, 0xbe, 0x72, 0x5d, 0xbb, 0x51, 0x8e, 0x97, 0x8b, 0x41,
	0x65, 0xfb, 0x64, 0xc1, 0xa8, 0xec, 0xfa, 0xc3, 0xae, 0x0d, 0x1f, 0x00, 0x60, 0x5a, 0x96, 0x3b,
	0x9b, 0x86, 0x84, 0xd9, 0xea, 0x75, 0xed, 0x46, 0xb5, 0x75, 0x6b, 0x31, 0x6f, 0xbc, 0x45, 0x98,
	0xc5, 0x18, 0x89, 0xa1, 0x12, 0x85, 0xaa, 0x1c, 0xcc, 0x18, 0xfb, 0xf8, 0xeb, 0x33, 0x1c, 0x50,
	0xc6, 0x95, 0x34, 0xe3, 0x18, 0x23, 0x31, 0x56, 0xa2, 0x50, 0x95, 0x83, 0xbb, 0xf6, 0xed, 0xd2,
	0x47, 0x7f, 0xd2, 0xf8, 0x8c, 0xfe, 0x3f, 0x55, 0x70, 0x25, 0xe3, 0x33, 0x70, 0x0c, 0x4a, 0xa1,
	0x33, 0xc1, 0x7c, 0x6b, 0xbe, 0x7a, 0xce, 0xad, 0xe9, 0x4c, 0x70, 0xec, 0x09, 0x64, 0xbc, 0xbc,
	0x05, 0xd3, 0x40, 0x44, 0xa5, 0xc0, 0xdf, 0xd7, 0x40, 0xcd, 0x8a, 0x34, 0x30, 0x2c, 0x77, 0x7a,
	0xe2, 0x0c, 0xf9, 0xf6, 0xfb, 0xc9, 0x94, 0x33, 0xdc, 0x37, 0xc7, 0x8e, 0x4d, 0x0e, 0x05, 0xa1,
	0xef, 0x1d, 0x4a, 0xdc, 0x6a, 0x2f, 0xe6, 0x8d, 0x77, 0x89, 0xd4, 0x2c, 0x1b, 0x49, 0x83, 0x25,
	0x04, 0xe8, 0x8a, 0x95, 0x66, 0x0b, 0x7f, 0xa0, 0x81, 0x8d, 0xd0, 0x0c, 0x46, 0x06, 0xdb, 0x10,
	0x38, 0x0a, 0x8e, 0xcd, 0x65, 0x1b, 0xae, 0x79, 0x68, 0x06, 0xa3, 0x01, 0x1f, 0xd0, 0x99, 0x86,
	0xfe, 0x59, 0xec, 0xb1, 0x29, 0x66, 0xf2, 0xea, 0xe4, 0x60, 0xd1, 0x7a, 0x98, 0x60, 0x09, 0x47,
	0xe0, 0x8a, 0xcb, 0xb7, 0x03, 0xa7, 0xa6, 0x3b, 0xb4, 0xda, 0x6a, 0x2d, 0xe6, 0x8d, 0x77, 0xa8,
	0xeb, 0xa6, 0xd1, 0xb2, 0x0f, 0xe7, 0xe2, 0xd1, 0x66, 0x84, 0xe3, 0x9e, 0x30, 0x11, 0xb1, 0x86,
	0xec, 0xce, 0xcd, 0x37, 0x5e, 0x5e, 0x3a, 0xf5, 0x0b, 0x87, 0x9c, 0x8f, 0x35, 0x50, 0x67, 0x3f,
	0x8d, 0xb1, 0x19, 0x84, 0xc6, 0xcc, 0xa3, 0xf6, 0x36, 0xa8, 0x37, 0xae, 0x3c, 0xb1, 0x37, 0x1e,
	0x2e, 0xe6, 0x8d, 0x7e, 0xac, 0x88, 0xcc, 0x33, 0x47, 0xb5, 0xa5, 0x84, 0xe8, 0x79, 0x46, 0xb4,
	0x67, 0x06, 0xe1, 0x11, 0x23, 0x21, 0xc2, 0xe0, 0x87, 0x1a, 0xf8, 0x6c, 0xec, 0x5e, 0xbe, 0xf9,
	0xc8, 0xe0, 0x21, 0x28, 0x18, 0xf2, 0x70, 0x80, 0x16, 0xf3, 0x46, 0x2f, 0xed, 0xa6, 0x29, 0xb2,
	0x25, 0xde, 0x9a, 0x47, 0x87, 0xae, 0x09, 0x1a, 0x64, 0x3e, 0xea, 0xd0, 0xc8, 0x16, 0x0c, 0xb7,
	0xfe, 0x5a, 0x03, 0x57, 0x25, 0x3f, 0x84, 0x6f, 0x83, 0xe2, 0x08, 0x9f, 0xd1, 0x5d, 0x5d, 0x6d,
	0xbd, 0xba, 0x98, 0x37, 0xbe, 0x48, 0x94, 0x19, 0xe1, 0x33, 0x49, 0x70, 0x1a, 0x86, 0xc8, 0x30,
	0xf8, 0x4b, 0xa0, 0x7c, 0x6a, 0x8e, 0x67, 0x98, 0x6f, 0xcd, 0xcf, 0xa6, 0x3c, 0x21, 0x16, 0x16,
	0xa7, 0x08, 0x94, 0x5a, 0x62, 0x9d, 0x85, 0x22, 0xc6, 0xf5, 0x76, 0xe1, 0x96, 0xa6, 0xdb, 0x60,
	0x85, 0xfb, 0x5d, 0x05, 0x94, 0x7a, 0x07, 0xbd, 0x4e, 0xed, 0x33, 0xb0, 0x06, 0xd6, 0xfb, 0xe8,
	0xe0, 0x7e, 0x77, 0xd0, 0x3d, 0xe8, 0x75, 0x7b, 0xbb, 0x35, 0x0d, 0xae, 0x81, 0x55, 0x74, 0xd4,
	0xa3, 0xff, 0x14, 0xe0, 0x3a, 0xa8, 0xb4, 0x3b, 0xbb, 0x68, 0xa7, 0xdd, 0x69, 0xd7, 0x8a, 0x10,
	0x80, 0x95, 0xbb, 0x3b, 0xdd, 0xbd, 0x4e, 0xbb, 0x56, 0x22, 0xbf, 0xfb, 0x3b, 0x47, 0x83, 0x4e,
	0xbb, 0x56, 0x26, 0x43, 0xda, 0x9d, 0xbd, 0xce, 0x61, 0xa7, 0x5d, 0x5b, 0xd1, 0x3f, 0x2e, 0x00,
	0x10, 0xeb, 0x0b, 0x31, 0x28, 0x13, 0x83, 0xb2, 0x68, 0xb7, 0x99, 0x39, 0x7f, 0x76, 0xac, 0x70,
	0x66, 0x8e, 0x09, 0x25, 0x26, 0xe1, 0x67, 0x86, 0x13, 0xf3, 0xa3, 0xa3, 0x94, 0x1e, 0x94, 0x9e,
	0x1f, 0x85, 0x40, 0x03, 0xac, 0x27, 0xbd, 0x8a, 0xae, 0x62, 0xa9, 0xf5, 0xf6, 0x62, 0xde, 0xb8,
	0x45, 0x13, 0xb7, 0x04, 0x4e, 0xce, 0xdd, 0xd4, 0x48, 0xb4, 0x36, 0x8e, 0x7d, 0x10, 0x5a, 0xe2,
	0x3c, 0xc5, 0x41, 0x60, 0x0e, 0x31, 0xcd, 0x0e, 0xaa, 0xd2, 0x71, 0xc9, 0x90, 0x79, 0xc7, 0xa5,
	0x84, 0x8d, 0x8e, 0x4b, 0x86, 0xd0, 0x7f, 0xa8, 0x81, 0xb5, 0xc4, 0x9a, 0xe8, 0xdf, 0xd3, 0xc0,
	0x0a, 0x5b, 0x97, 0x84, 0xc9, 0x12, 0x06, 0xa2, 0xd6, 0x1a, 0x1c, 0x1e, 0xf4, 0xfb, 0x9d, 0x76,
	0xad, 0x90, 0xb4, 0x43, 0x11, 0x6e, 0x02, 0x70, 0xd4, 0xdb, 0x19, 0x0c, 0xba, 0xbb, 0x3d, 0x6a,
	0xb0, 0x2a, 0x28, 0x77, 0x10, 0x3a, 0x40, 0x35, 0x9b, 0xd0, 0xf5, 0x3b, 0xbd, 0x36, 0xe1, 0x80,
	0x89, 0x07, 0x0c, 0x7e, 0x61, 0x70, 0xd8, 0xd9, 0x37, 0x18, 0xfa, 0x04, 0x7e, 0x0e, 0x3c, 0x7f,
	0x34, 0xe8, 0x20, 0x63, 0xe7, 0xce, 0x61, 0xf7, 0xa0, 0xb7, 0xd3, 0xda, 0xeb, 0x70, 0xd4, 0x50,
	0xff, 0x87, 0xcd, 0x44, 0x39, 0x40, 0x92, 0x13, 0x78, 0x0b, 0x14, 0x1c, 0x9b, 0x3b, 0xfd, 0x8d,
	0xc5, 0xbc, 0xf1, 0x0a, 0x4d, 0x5f, 0xe5, 0x45, 0x4e, 0x9f, 0x93, 0x05, 0xc7, 0x86, 0xdf, 0x04,
	0xcf, 0x79, 0x0f, 0xcf, 0x02, 0xc7, 0x32, 0xc7, 0x86, 0x35, 0x9e, 0x05, 0x21, 0xf6, 0xc9, 0x11,
	0x5c, 0xa0, 0xac, 0xde, 0x5b, 0xcc, 0x1b, 0x77, 0x09, 0x2b, 0x05, 0x89, 0xc4, 0x7b, 0x39, 0x0d,
	0xba, 0x1a, 0xe1, 0xef, 0x30, 0x74, 0xd7, 0x86, 0xdf, 0xd7, 0xc0, 0x55, 0x1b, 0x7b, 0x3e, 0xb6,
	0x68, 0x0c, 0xf2, 0xc6, 0xb3, 0xa1, 0x33, 0xa5, 0x26, 0xdd, 0x54, 0xa7, 0x62, 0x7d, 0x4a, 0xd1,
	0xba, 0xbb, 0x98, 0x37, 0x5a, 0x44, 0x2d, 0x69, 0xb0, 0xa4, 0xd4, 0x32, 0x0a, 0x54, 0x8b, 0xb1,
	0x8c, 0x33, 0xfc, 0x2d, 0x0d, 0xd4, 0x9c, 0x69, 0x88, 0xfd, 0x69, 0x3c, 0x0f, 0x9e, 0x1b, 0xa6,
	0x33, 0xd0, 0xaf, 0x98, 0x27, 0x23, 0xb3, 0x8d, 0x3d, 0x3c, 0xb5, 0xf1, 0xd4, 0x3a, 0x8b, 0x4f,
	0xe7, 0xec, 0x68, 0xd9, 0x04, 0xf9, 0x04, 0xe8, 0x4a, 0x84, 0xe4, 0x6b, 0x04, 0x47, 0x60, 0x95,
	0x9d, 0xe1, 0x01, 0xcf, 0x1c, 0x5f, 0x54, 0x9f, 0x4d, 0xec, 0x30, 0x0f, 0x5a, 0x6f, 0x2c, 0xe6,
	0x8d, 0x26, 0x8f, 0xbe, 0x04, 0xa0, 0x8a, 0xb6, 0x19, 0x38, 0x8a, 0x24, 0xc0, 0x6f, 0x81, 0x6b,
	0x8f, 0x5c, 0x7f, 0x84, 0x7d, 0xc3, 0x27, 0x39, 0x15, 0x9e, 0xda, 0x9e, 0xeb, 0x4c, 0x43, 0x7a,
	0x26, 0x55, 0x5b, 0x7b, 0x8b, 0x79, 0xe3, 0x1e, 0x61, 0xad, 0xa2, 0x91, 0xe4, 0x3c, 0x86, 0x08,
	0x41, 0x46, 0x80, 0x70, 0x10, 0x76, 0x38, 0x1a, 0xfe, 0xa6, 0x06, 0x36, 0x6c, 0x1c, 0x38, 0x3e,
	0xb6, 0x0d, 0x16, 0xad, 0x56, 0xa9, 0x2b, 0x7c, 0x29, 0x3f, 0x2b, 0x6f, 0xb6, 0x19, 0x3d, 0xdd,
	0xa8, 0x71, 0x18, 0x48, 0x71, 0x51, 0xf8, 0x84, 0x1a, 0x8b, 0xd6, 0xed, 0x04, 0x37, 0xf8, 0x35,
	0xb0, 0xc6, 0x5c, 0xc6, 0x20, 0xf5, 0x13, 0x4f, 0x4a, 0x6f, 0x47, 0xf5, 0x4d, 0x02, 0x25, 0xef,
	0x04, 0x25, 0x0e, 0x01, 0x06, 0x27, 0xe5, 0x1d, 0xfc, 0xae, 0x06, 0xae, 0x70, 0xb2, 0xa8, 0x86,
	0xaa, 0x57, 0xa9, 0x85, 0x3f, 0x9f, 0x9a, 0x2d, 0xf3, 0xcb, 0x7d, 0x4e, 0x12, 0xa7, 0x3f, 0x99,
	0xb1, 0x79, 0x2a, 0x28, 0xf0, 0x68, 0xd3, 0x4b, 0xf1, 0x84, 0xdf, 0xd1, 0xc0, 0xa6, 0x49, 0xc3,
	0x9d, 0x11, 0xf9, 0x1a, 0x38, 0x8f, 0xaf, 0xbd, 0xbb, 0x98, 0x37, 0xde, 0x66, 0x89, 0x7f, 0x72,
	0xb0, 0x22, 0xf9, 0xcf, 0x41, 0xa3, 0x0d, 0x86, 0xe2, 0x0c, 0xe1, 0xb7, 0x35, 0xb0, 0x71, 0x82,
	0xcd, 0x70, 0xe6, 0x63, 0xe3, 0x64, 0x6c, 0x0e, 0x83, 0xfa, 0x1a, 0xd5, 0xe3, 0xba, 0x4a, 0x8f,
	0xbb, 0x8c, 0xf0, 0x2e, 0xa1, 0x8b, 0x0d, 0x9f, 0x1a, 0x2e, 0x69, 0x92, 0x87, 0x45, 0xeb, 0x27,
	0x09, 0x6e, 0x24, 0x57, 0xdf, 0x0a, 0xac, 0x87, 0xd8, 0x9e, 0x8d, 0xb1, 0x6d, 0xd8, 0x78, 0x8c,
	0x43, 0x4c, 0x13, 0xa4, 0x20, 0x34, 0x27, 0x5e, 0x7d, 0xfd, 0xba, 0x76, 0xa3, 0xd8, 0xfa, 0xea,
	0x62, 0xde, 0x38, 0xa4, 0x27, 0x64, 0x2e, 0xa5, 0x7c, 0x6c, 0x9e, 0x87, 0x14, 0xd5, 0x05, 0x59,
	0x9b, 0x52, 0x1d, 0x46, 0x44, 0xf0, 0x7b, 0x1a, 0xa8, 0x89, 0xbc, 0x36, 0xb2, 0xd5, 0xc6, 0x79,
	0x6c, 0x25, 0xc2, 0x53, 0x76, 0x78, 0x7e, 0xde, 0xac, 0xb0, 0x97, 0xc8, 0xc9, 0x23, 0x8b, 0x3d,
	0x02, 0xd0, 0xf2, 0xb1, 0x19, 0x3a, 0xee, 0x34, 0xb1, 0x40, 0x9b, 0x74, 0x81, 0xee, 0x2d, 0xe6,
	0x8d, 0x36, 0x0d, 0x45, 0x12, 0x85, 0x1c, 0x95, 0x96, 0x91, 0xa0, 0xab, 0x11, 0x5a, 0xac, 0x84,
	0xfe, 0x73, 0x60, 0x3d, 0xb9, 0xf3, 0x9f, 0xf8, 0x5c, 0xd6, 0x7f, 0xb7, 0x04, 0x9e, 0x53, 0x78,
	0x12, 0xb5, 0x3d, 0x31, 0xce, 0xd0, 0x0c, 0x9d, 0xe9, 0xd0, 0x08, 0xb0, 0x7f, 0xea, 0x58, 0xd8,
	0xc0, 0x53, 0xf3, 0x78, 0x8c, 0xd9, 0x09, 0x5b, 0x89, 0x6d, 0x9f, 0x4f, 0xa9, 0x08, 0x3a, 0xe7,
	0x20, 0x45, 0xf5, 0x98, 0x6c, 0xc0, 0xa8, 0x3a, 0x8c, 0x08, 0xfe, 0x95, 0x06, 0xbe, 0x10, 0x99,
	0xd8, 0xf0, 0xdc, 0xf1, 0x98, 0x17, 0x36, 0x86, 0x6d, 0xfa, 0x23, 0xa1, 0x5f, 0x81, 0xea, 0x77,
	0xb2, 0x98, 0x37, 0x8e, 0xa9, 0xb5, 0x1f, 0x37, 0x40, 0x36, 0xff, 0x13, 0x8c, 0x40, 0x2f, 0x46,
	0xd4, 0x7d, 0x77, 0x3c, 0x66, 0x99, 0x66, 0xdb, 0xf4, 0x47, 0x8f, 0x55, 0xd9, 0xf3, 0x5d, 0x5b,
	0xa8, 0x5c, 0x3c, 0x87, 0xca, 0xc9, 0x01, 0xe7, 0x53, 0x39, 0x67, 0x84, 0x4a, 0xe5, 0xbe, 0xef,
	0xda, 0x5c, 0x65, 0xfd, 0x9f, 0x34, 0xb0, 0x99, 0x0e, 0xb9, 0x64, 0x16, 0x2f, 0x10, 0x6e, 0x33,
	0x2b, 0x34, 0x26, 0xc4, 0x53, 0x9c, 0xf0, 0xcc, 0xf0, 0x1e, 0x9a, 0x41, 0x94, 0x4c, 0xdf, 0x48,
	0x07, 0x6c, 0x46, 0xba, 0xcf, 0x29, 0xfb, 0x84, 0x30, 0xca, 0xaa, 0xfb, 0x8b, 0x79, 0x63, 0x8f,
	0x46, 0x6f, 0x25, 0x3f, 0x39, 0x88, 0x3f, 0x8e, 0x0c, 0x5d, 0xf3, 0x14, 0xe2, 0xf4, 0xbf, 0x2f,
	0x81, 0x5a, 0x36, 0x04, 0x90, 0xe3, 0x8c, 0x8c, 0x1a, 0x9b, 0x21, 0x36, 0x44, 0xae, 0x28, 0x8e,
	0xb3, 0x04, 0x4a, 0xae, 0xd9, 0x95, 0x38, 0x04, 0x22, 0x38, 0xcb, 0xe4, 0xd6, 0x67, 0x01, 0xf6,
	0x45, 0x54, 0x2a, 0x2c, 0x6b, 0x22, 0x70, 0x95, 0x9a, 0x47, 0x01, 0x8e, 0x7e, 0xb3, 0x26, 0x82,
	0xa8, 0x14, 0x92, 0xbc, 0x24, 0x7d, 0x72, 0x90, 0x68, 0x6d, 0x16, 0xf3, 0x83, 0x3f, 0xd0, 0xc0,
	0x26, 0x6f, 0x03, 0x45, 0xb5, 0x75, 0xe9, 0x89, 0x6b, 0x6b, 0x71, 0xc4, 0xa5, 0x39, 0xe5, 0xb5,
	0xa1, 0x14, 0x75, 0xf4, 0x86, 0x40, 0x11, 0x86, 0x5b, 0x7f, 0xa4, 0x81, 0x5a, 0x76, 0xd6, 0x17,
	0x2c, 0x59, 0xdb, 0xc9, 0x92, 0xb5, 0x7a, 0x81, 0xca, 0xf4, 0xbd, 0x52, 0xa5, 0x58, 0x2b, 0xe9,
	0xff, 0x5c, 0xa1, 0xce, 0x73, 0xe2, 0x0c, 0xdb, 0xf8, 0xc4, 0x99, 0x3a, 0x24, 0xf0, 0xc2, 0x77,
	0x41, 0x69, 0x6a, 0xf2, 0x66, 0x59, 0x35, 0x6e, 0x80, 0x11, 0x98, 0x24, 0x22, 0x03, 0x44, 0x74,
	0x24, 0xfc, 0x15, 0x50, 0xa2, 0x69, 0x54, 0x81, 0xee, 0x99, 0x97, 0xb2, 0x8e, 0x71, 0xe2, 0x0c,
	0x49, 0x5e, 0x14, 0xed, 0x94, 0xb8, 0xc5, 0xa6, 0xca, 0xaf, 0xb2, 0x89, 0x15, 0xe5, 0x0c, 0xfb,
	0xa0, 0x42, 0x16, 0x9b, 0x1c, 0x0a, 0x3c, 0xa8, 0xbc, 0xb5, 0x98, 0x37, 0x5e, 0x8f, 0xcc, 0x47,
	0xe0, 0x4a, 0xc3, 0x65, 0x10, 0x48, 0x70, 0x21, 0xd5, 0xa6, 0x8d, 0x4f, 0xcc, 0xd9, 0x38, 0x34,
	0xd8, 0x12, 0x97, 0xd2, 0xd5, 0x66, 0x0a, 0xa9, 0x88, 0xf8, 0x6a, 0x2c, 0x49, 0x33, 0x29, 0x86,
	0xce, 0x15, 0x7e, 0x0b, 0x00, 0x67, 0xe2, 0xb9, 0x7e, 0x68, 0x4e, 0x2d, 0xcc, 0x3b, 0x50, 0xaf,
	0x28, 0x96, 0xa7, 0x2b, 0x88, 0xa2, 0x45, 0x12, 0x0d, 0xd2, 0x78, 0xbc, 0x5c, 0x6d, 0xa8, 0x50,
	0x28, 0x21, 0x11, 0xda, 0x60, 0xc3, 0x76, 0xad, 0xd9, 0x04, 0x4f, 0x43, 0x7a, 0xc8, 0xf2, 0x74,
	0x3f, 0x9e, 0x64, 0x12, 0x29, 0x4f, 0x32, 0x07, 0x8b, 0xd2, 0x4c, 0x89, 0x97, 0x0e, 0x7d, 0x77,
	0xe6, 0xf1, 0x2e, 0x91, 0xf0, 0x52, 0x0a, 0x94, 0xb8, 0x66, 0xa1, 0x88, 0x0d, 0x86, 0x18, 0x94,
	0x1f, 0x39, 0x76, 0xf8, 0x90, 0x26, 0xe3, 0x9b, 0x72, 0x1b, 0xfd, 0xc4, 0x19, 0x3e, 0x20, 0x78,
	0xa9, 0x8d, 0x41, 0x47, 0xc9, 0x45, 0x4a, 0x06, 0x8a, 0x18, 0x77, 0x68, 0x80, 0x75, 0xdb, 0x09,
	0xbc, 0xb1, 0x79, 0x66, 0x50, 0xaf, 0xaf, 0x52, 0x9d, 0x45, 0x70, 0x4a, 0xe2, 0xe4, 0x05, 0x51,
	0x23, 0xd1, 0x1a, 0x47, 0xf4, 0xc8, 0x66, 0xf8, 0x2a, 0x00, 0x36, 0xaf, 0x1d, 0x43, 0x92, 0x6d,
	0x17, 0x93, 0xed, 0xee, 0x18, 0xa3, 0xaa, 0x66, 0x65, 0x14, 0x4a, 0xf0, 0x22, 0xeb, 0xec, 0xfa,
	0x36, 0xf6, 0x69, 0xea, 0x5c, 0x8e, 0x17, 0x80, 0x02, 0x15, 0x8d, 0xfe, 0x34, 0x14, 0xb1, 0xc1,
	0x84, 0x8b, 0x39, 0x76, 0xcc, 0x80, 0xe6, 0xba, 0x09, 0x6b, 0x51, 0xa0, 0x9c, 0xe0, 0x67, 0xa0,
	0x88, 0x0d, 0xd6, 0xff, 0xac, 0x08, 0xd6, 0x98, 0x51, 0x98, 0xa7, 0x5f, 0x3c, 0x88, 0x5c, 0x4a,
	0xac, 0x23, 0x59, 0xab, 0x8f, 0x2d, 0x77, 0x32, 0x21, 0x8b, 0x66, 0xb3, 0xfd, 0xc9, 0xda, 0xde,
	0xd5, 0x38, 0x6b, 0x95, 0x29, 0x14, 0xc1, 0x63, 0x09, 0x09, 0xba, 0x9a, 0x40, 0xf3, 0xee, 0xd1,
	0x3d, 0xb0, 0x42, 0x1b, 0x4d, 0x41, 0xbd, 0x44, 0x85, 0x89, 0x1e, 0x32, 0x83, 0xaa, 0xfb, 0x55,
	0xe9, 0x1e, 0x32, 0x03, 0xc1, 0x3d, 0xb0, 0x7a, 0xea, 0x04, 0xce, 0xf1, 0x98, 0x45, 0x8c, 0x4a,
	0x5c, 0xf8, 0x73, 0xb0, 0xbc, 0x18, 0x12, 0x1c, 0x45, 0x2c, 0xf4, 0x0f, 0x4b, 0x60, 0x35, 0x4e,
	0xe9, 0x81, 0x2d, 0xe2, 0x3e, 0xbf, 0x1c, 0x79, 0x51, 0xb1, 0xcf, 0xe2, 0xc3, 0x21, 0xe9, 0xb9,
	0x11, 0x4c, 0x15, 0x0c, 0x65, 0x14, 0x4a, 0x88, 0x82, 0xbf, 0x9c, 0x6e, 0xbd, 0xd6, 0x15, 0x32,
	0xe9, 0x32, 0x3e, 0xad, 0xd5, 0x7f, 0x43, 0x03, 0x15, 0x51, 0x6a, 0xb3, 0x3b, 0x0e, 0x5d, 0x21,
	0x23, 0x68, 0x46, 0x99, 0x1f, 0x4b, 0x49, 0xde, 0xcb, 0xbd, 0xe6, 0xa4, 0x27, 0x4b, 0x6e, 0x01,
	0xae, 0xaa, 0xbc, 0x85, 0xfc, 0xad, 0x3f, 0xd0, 0xc0, 0x46, 0x4a, 0xce, 0xb3, 0x92, 0x04, 0xe8,
	0x9f, 0x94, 0x41, 0x3d, 0xef, 0x0e, 0xea, 0x12, 0x76, 0xf0, 0xd7, 0xc0, 0x1a, 0xeb, 0xc2, 0xd2,
	0x9b, 0x3f, 0xaa, 0x6e, 0x39, 0xce, 0x42, 0x13, 0xa8, 0x9c, 0xe6, 0x6d, 0x16, 0x87, 0x00, 0x85,
	0xdf, 0x21, 0x60, 0xb2, 0xbf, 0xe8, 0x39, 0x11, 0x6d, 0x66, 0xb1, 0xbf, 0x18, 0x54, 0x7d, 0xcc,
	0xa4, 0xf7, 0x17, 0x03, 0xc1, 0xe3, 0xb8, 0xef, 0x56, 0xa2, 0xae, 0x72, 0x4d, 0xe5, 0x2a, 0x17,
	0x6b, 0xb7, 0xfd, 0xa3, 0x06, 0xae, 0x4d, 0xcc, 0x10, 0xfb, 0x8e, 0x39, 0x76, 0xbe, 0x89, 0x6d,
	0x23, 0xee, 0xf4, 0x11, 0x89, 0xef, 0x9c, 0xeb, 0x5a, 0xb0, 0xb9, 0x9f, 0xe0, 0x90, 0xca, 0xa5,
	0x7b, 0x51, 0xbf, 0x4e, 0x25, 0x43, 0x76, 0xd7, 0xe5, 0x44, 0x75, 0x0d, 0x3d, 0x37, 0x91, 0x25,
	0x6d, 0xfd, 0x48, 0x03, 0xf5, 0x3c, 0x0d, 0x9e, 0x19, 0x97, 0xfe, 0x6d, 0x0d, 0x80, 0x38, 0xc5,
	0xd4, 0x7f, 0x2d, 0xa7, 0x9d, 0xdf, 0x3a, 0x38, 0xd8, 0xeb, 0xec, 0xf4, 0x6a, 0x1a, 0x5c, 0x05,
	0xc5, 0x6e, 0xef, 0xb0, 0x56, 0x80, 0x55, 0x50, 0x1e, 0xdc, 0x3b, 0x40, 0x87, 0xb5, 0x22, 0x21,
	0xdd, 0x3b, 0xe8, 0xed, 0xb2, 0x3b, 0x97, 0xf6, 0xc1, 0x51, 0x6b, 0xaf, 0x53, 0x2b, 0x93, 0xdf,
	0x83, 0x43, 0xd4, 0xed, 0xed, 0xd6, 0x56, 0x28, 0x45, 0x77, 0x70, 0x58, 0x5b, 0x25, 0xbf, 0x3a,
	0xbd, 0xa3, 0xfd, 0x5a, 0x05, 0xae, 0x83, 0x4a, 0x7f, 0x67, 0x30, 0x78, 0x70, 0x80, 0xda, 0xb5,
	0x2a, 0x61, 0x77, 0x67, 0x6f, 0x67, 0x30, 0xa8, 0x01, 0xbd, 0x15, 0x1d, 0x8d, 0x34, 0x5f, 0xd1,
	0xdf, 0x54, 0xa8, 0x24, 0x84, 0x6b, 0x44, 0xcc, 0x7e, 0xa7, 0xdd, 0x3d, 0xda, 0xaf, 0x15, 0x84,
	0x22, 0x45, 0xbd, 0x13, 0x25, 0xea, 0x71, 0x6a, 0xa8, 0xdf, 0x54, 0x30, 0xaa, 0x80, 0xd2, 0xbd,
	0xee, 0xee, 0xbd, 0x0c, 0x9f, 0x55, 0x50, 0xdc, 0x3b, 0x78, 0x50, 0x2b, 0xea, 0xff, 0xab, 0x81,
	0xcd, 0xd4, 0x25, 0x27, 0x3d, 0x67, 0xe3, 0xeb, 0xa2, 0xea, 0xd3, 0xde, 0x06, 0x0d, 0x40, 0x95,
	0xb7, 0x81, 0xc5, 0x85, 0xc2, 0x97, 0xa3, 0x27, 0x2c, 0x02, 0x91, 0xd7, 0x39, 0x4e, 0xd7, 0x9a,
	0x15, 0x06, 0xed, 0xda, 0x44, 0xb5, 0xd0, 0x37, 0xad, 0xe8, 0xe6, 0x47, 0xa8, 0x46, 0x81, 0x72,
	0xa5, 0x90, 0x81, 0x22, 0x36, 0x58, 0xff, 0x61, 0x01, 0x54, 0xa3, 0xeb, 0x31, 0x9c, 0xb8, 0x3d,
	0x29, 0x3f, 0xe1, 0xed, 0x89, 0x58, 0xa8, 0xc2, 0xa5, 0x2d, 0x54, 0xf1, 0x92, 0x16, 0xea, 0x6d,
	0x50, 0x9c, 0x04, 0x43, 0x5e, 0xb2, 0x88, 0xdd, 0xa7, 0xba, 0x81, 0xcd, 0xdc, 0xb6, 0x92, 0x61,
	0xfa, 0x7f, 0x16, 0x00, 0x4c, 0x3b, 0x45, 0x77, 0x7a, 0xe2, 0x5e, 0xc2, 0x01, 0xf0, 0x75, 0x50,
	0x15, 0xb7, 0xb9, 0xfc, 0xa8, 0xff, 0x7c, 0xfe, 0x7d, 0x3b, 0x8e, 0x17, 0x42, 0x8c, 0xca, 0xbf,
	0x41, 0x4e, 0xbd, 0x01, 0x11, 0x50, 0xf8, 0x3e, 0x28, 0x87, 0x66, 0x30, 0x52, 0x3f, 0xfb, 0x12,
	0x5e, 0x90, 0x70, 0x25, 0x42, 0xac, 0x7c, 0xb9, 0x90, 0xce, 0x72, 0x29, 0x84, 0x2c, 0x09, 0x2d,
	0x6c, 0x4b, 0xe9, 0x25, 0x39, 0x7f, 0xe1, 0xaa, 0x9b, 0xe0, 0x9a, 0xaa, 0x6b, 0xa4, 0x77, 0x15,
	0x7b, 0x79, 0x1d, 0x54, 0xba, 0xbd, 0xc3, 0x0e, 0xea, 0xed, 0xec, 0xb1, 0xfe, 0x66, 0x1f, 0x75,
	0xee, 0x77, 0x3b, 0x0f, 0x6a, 0x05, 0xb8, 0x02, 0x0a, 0xfd, 0x9d, 0x5a, 0x91, 0xfc, 0xdd, 0xdd,
	0x61, 0x71, 0x6a, 0x6f, 0xa7, 0xd7, 0xee, 0xb4, 0x6b, 0x65, 0xfd, 0x67, 0x12, 0xef, 0x5f, 0xba,
	0x36, 0x0d, 0x83, 0xaf, 0x28, 0xb8, 0xaf, 0x80, 0x42, 0xb7, 0x5d, 0xd3, 0x28, 0x64, 0x67, 0xbf,
	0x53, 0x2b, 0xe8, 0x1f, 0x6b, 0x34, 0x50, 0x45, 0x23, 0x2f, 0x70, 0xd1, 0xe8, 0x81, 0x55, 0xc7,
	0x36, 0x12, 0x3d, 0x80, 0x9c, 0x67, 0x16, 0x4c, 0xbd, 0xa8, 0x82, 0x13, 0x27, 0x2c, 0x1f, 0xab,
	0x10, 0x24, 0xdd, 0xb3, 0xac, 0x38, 0x6c, 0x86, 0xff, 0xad, 0x89, 0x1e, 0xaf, 0xeb, 0xb3, 0xae,
	0x1e, 0x75, 0xe2, 0x36, 0x28, 0x5b, 0x63, 0x33, 0x08, 0xb2, 0xd1, 0x8d, 0x02, 0x65, 0xef, 0xca,
	0x40, 0x11, 0x1b, 0x2c, 0xec, 0x5e, 0x78, 0x5a, 0xbb, 0xd3, 0x24, 0x1e, 0xfb, 0x01, 0xc9, 0xb3,
	0xd9, 0xa6, 0x8f, 0x93, 0x78, 0x06, 0x96, 0x4f, 0x39, 0x09, 0x8e, 0x22, 0x16, 0xfa, 0xb7, 0x8b,
	0x60, 0x2b, 0x33, 0xdb, 0x36, 0x2b, 0x39, 0xe9, 0xa4, 0x07, 0xa0, 0xea, 0x4c, 0xcc, 0x21, 0x36,
	0x66, 0xfe, 0x98, 0x4f, 0x5c, 0x6c, 0x2d, 0x81, 0x50, 0xb4, 0x0f, 0x64, 0x0c, 0xaa, 0x50, 0xe8,
	0x91, 0x3f, 0x5e, 0xd6, 0x1b, 0x2d, 0x3c, 0x9b, 0xbd, 0x51, 0xa9, 0xb6, 0x2f, 0x5e, 0x72, 0x6d,
	0xaf, 0xff, 0x6d, 0x01, 0xbc, 0x9c, 0xb1, 0x03, 0x4f, 0xde, 0x1c, 0x77, 0xda, 0x37, 0x7d, 0x73,
	0x82, 0x43, 0xec, 0x07, 0xf0, 0x3b, 0x1a, 0x78, 0xe1, 0x94, 0x67, 0x75, 0x46, 0xd4, 0x4a, 0xb5,
	0x8d, 0x53, 0xcf, 0xe2, 0xb7, 0x0c, 0x62, 0x45, 0xd4, 0x54, 0xaa, 0x14, 0x68, 0x39, 0x19, 0xba,
	0x16, 0x91, 0x1c, 0x46, 0x14, 0xf7, 0x3d, 0x2b, 0xad, 0x08, 0xbf, 0x7f, 0xe0, 0x8a, 0x14, 0x72,
	0x14, 0x49, 0x51, 0xe5, 0x2b, 0x92, 0x47, 0x16, 0x2b, 0xd2, 0x8e, 0x28, 0xee, 0x7b, 0x96, 0xfe,
	0xaf, 0xa5, 0xc4, 0x99, 0xd3, 0xf9, 0x86, 0x67, 0x4e, 0x89, 0x63, 0x43, 0x47, 0x3c, 0xcf, 0xd2,
	0xf2, 0x1f, 0x4f, 0x26, 0x0e, 0xa9, 0x8b, 0xbd, 0x06, 0x75, 0xa6, 0x27, 0x2e, 0x3f, 0x97, 0x72,
	0x5e, 0x83, 0x52, 0x19, 0x62, 0xbf, 0x13, 0x7a, 0xc5, 0x1d, 0x7f, 0x0a, 0x88, 0x28, 0x57, 0x88,
	0x68, 0xec, 0x2c, 0xaa, 0xcb, 0xdb, 0x28, 0xf8, 0x3d, 0x61, 0x54, 0xfd, 0x50, 0x03, 0x00, 0x7f,
	0x23, 0xc4, 0x74, 0xa9, 0xa2, 0x62, 0x65, 0x5b, 0xcd, 0x5c, 0x2c, 0x69, 0xb3, 0x23, 0x46, 0xb0,
	0x5a, 0x41, 0x54, 0xf0, 0x31, 0x2b, 0xb9, 0xfe, 0x52, 0xa1, 0x50, 0x42, 0xf8, 0xd6, 0x1f, 0x6a,
	0xe0, 0x4a, 0x86, 0xf3, 0x33, 0x53, 0x03, 0xfc, 0x69, 0x09, 0xd4, 0x33, 0xbb, 0x32, 0xf6, 0xb0,
	0x19, 0x58, 0xe5, 0x3b, 0x98, 0xbb, 0x58, 0xce, 0x8b, 0x03, 0x29, 0xaa, 0xc6, 0x11, 0x9b, 0x8f,
	0xcf, 0x0b, 0x19, 0xa9, 0x88, 0xcd, 0x61, 0xf0, 0x38, 0xe5, 0x6d, 0xd7, 0x97, 0xc9, 0x7c, 0x6a,
	0x9f, 0xfb, 0x7e, 0xda, 0x3f, 0x58, 0x06, 0xf4, 0xd3, 0xcb, 0x44, 0xfd, 0x7f, 0xf6, 0x92, 0x5f,
	0x2d, 0x25, 0x1e, 0x56, 0x5d, 0x52, 0xc2, 0x7b, 0xf1, 0x3c, 0xc1, 0x03, 0x2b, 0xfc, 0xc1, 0x30,
	0x33, 0xdf, 0x17, 0xf3, 0xe3, 0x12, 0xef, 0x4c, 0x30, 0x7b, 0x89, 0x38, 0x98, 0xff, 0x4e, 0x38,
	0xf3, 0x3a, 0x98, 0xcb, 0x81, 0xc7, 0x51, 0xc6, 0xcc, 0xe2, 0x49, 0xce, 0xe3, 0x7b, 0x92, 0x3a,
	0x77, 0xed, 0xa7, 0xcc, 0x9b, 0xb7, 0x7e, 0x4f, 0x8b, 0x4a, 0xe0, 0x67, 0xcb, 0x07, 0xfe, 0x42,
	0x4b, 0xe4, 0xca, 0x6c, 0x8a, 0xf0, 0x30, 0x59, 0xb4, 0x64, 0x92, 0xa7, 0xa7, 0xaf, 0x4b, 0x88,
	0x67, 0x98, 0xc1, 0x88, 0x37, 0xc1, 0x62, 0xcf, 0x30, 0x83, 0x91, 0x72, 0x15, 0xd3, 0x9e, 0x61,
	0x06, 0x23, 0xfd, 0x3f, 0x0a, 0xa0, 0x42, 0x55, 0x24, 0xae, 0x7a, 0x5f, 0xa4, 0xe6, 0x8f, 0xb3,
	0xd8, 0x93, 0x1d, 0x31, 0x23, 0xe1, 0x7e, 0xec, 0x52, 0xf7, 0x0b, 0x52, 0xfd, 0x74, 0x79, 0x9e,
	0xf7, 0xcc, 0x7a, 0xc5, 0xbf, 0x15, 0x22, 0xbd, 0xc8, 0x64, 0x83, 0x4b, 0x88, 0x0b, 0x71, 0xb3,
	0xb2, 0x70, 0xc1, 0x66, 0x65, 0xa6, 0xa7, 0x5a, 0xbc, 0xd4, 0x9e, 0xea, 0x8f, 0xa1, 0x13, 0xaa,
	0xff, 0x5d, 0x29, 0xb1, 0xe5, 0xf8, 0x4b, 0xcc, 0x4b, 0x59, 0x60, 0x6b, 0xec, 0xce, 0xec, 0x80,
	0x5b, 0x3f, 0x76, 0x4a, 0x0a, 0x55, 0x14, 0x7a, 0x19, 0x30, 0xe2, 0xe3, 0xe1, 0x07, 0x60, 0x25,
	0xf1, 0x36, 0xf5, 0x3c, 0x47, 0xb5, 0x90, 0x95, 0xf3, 0x2c, 0x55, 0x7e, 0x8b, 0xca, 0x25, 0x24,
	0x73, 0x91, 0xd2, 0x8f, 0x31, 0x17, 0xf9, 0x1b, 0x0d, 0x3c, 0x7f, 0x2a, 0xca, 0x14, 0xc3, 0x13,
	0x75, 0x0a, 0x7f, 0x77, 0xfa, 0xfa, 0x32, 0x2d, 0x54, 0xf5, 0x0d, 0xed, 0x3f, 0xbf, 0x97, 0xa8,
	0x1a, 0xd2, 0x6c, 0xf3, 0x8a, 0x86, 0x5c, 0x2a, 0x51, 0x33, 0xa4, 0xa4, 0xe8, 0xdf, 0x2d, 0x81,
	0x17, 0xb2, 0xdf, 0x4f, 0xb1, 0x67, 0xdc, 0xf2, 0x5b, 0x71, 0xed, 0xf2, 0xdf, 0x8a, 0x93, 0x72,
	0x92, 0x3e, 0x47, 0x89, 0x64, 0x14, 0xd2, 0xe5, 0x64, 0x12, 0xa7, 0x7e, 0xc7, 0xa2, 0x90, 0x40,
	0xdf, 0xb1, 0x44, 0x02, 0x86, 0x60, 0x33, 0xfe, 0x42, 0x82, 0x26, 0x12, 0xac, 0x62, 0x15, 0x4f,
	0x53, 0xd2, 0xd8, 0x25, 0x9f, 0x57, 0x64, 0x93, 0x8b, 0x0d, 0x81, 0xa2, 0x2f, 0x52, 0xa7, 0xa0,
	0x96, 0xfa, 0x9c, 0xcc, 0x70, 0x6c, 0xea, 0x81, 0xe5, 0xf8, 0xf1, 0x60, 0x16, 0xbf, 0xfc, 0x7b,
	0xb4, 0x4c, 0x67, 0x72, 0x33, 0xf9, 0x49, 0x5a, 0xd7, 0x86, 0x07, 0xa0, 0x62, 0x3d, 0xc4, 0xd6,
	0xc8, 0x18, 0xdb, 0xfc, 0x0e, 0x53, 0x3c, 0xd7, 0x88, 0xe0, 0xf2, 0x64, 0x64, 0x04, 0x5a, 0xa5,
	0xc0, 0x3d, 0x5b, 0xff, 0x4b, 0x4d, 0x94, 0x8f, 0x89, 0x4f, 0xe9, 0xe0, 0x47, 0x1a, 0xb8, 0xca,
	0x67, 0x6a, 0x44, 0xef, 0x17, 0x49, 0x29, 0x49, 0x62, 0xd9, 0xcb, 0x4b, 0xbf, 0xc3, 0x63, 0x16,
	0x88, 0x5f, 0x9b, 0x4b, 0x5c, 0xf2, 0x16, 0x5b, 0x49, 0x81, 0xa2, 0xef, 0xbf, 0x22, 0xfe, 0xc1,
	0xab, 0x6d, 0x91, 0x6d, 0xf2, 0xa0, 0xb7, 0x06, 0x56, 0x07, 0x6f, 0x1a, 0x83, 0x6e, 0xef, 0x2b,
	0xac, 0xd5, 0xb7, 0x7b, 0x67, 0xc0, 0xfe, 0xa3, 0xad, 0xbe, 0x0e, 0xff, 0x87, 0x3e, 0x65, 0x6c,
	0xfd, 0x3c, 0xfb, 0xa7, 0xd8, 0xfa, 0xe0, 0x5f, 0x3e, 0x7d, 0x49, 0xfb, 0xe4, 0xd3, 0x97, 0xb4,
	0x7f, 0xff, 0xf4, 0x25, 0x0d, 0x7c, 0xc9, 0x71, 0x9b, 0x24, 0xae, 0x8e, 0x67, 0x78, 0x1a, 0x36,
	0x69, 0x00, 0x63, 0x1f, 0x11, 0x1f, 0xcf, 0x4e, 0x92, 0xb3, 0xed, 0x6b, 0xbf, 0x78, 0x73, 0xe8,
	0x84, 0x0f, 0x67, 0xc7, 0x4d, 0xcb, 0x9d, 0x6c, 0x8b, 0x21, 0xce, 0xd4, 0xda, 0xb6, 0xac, 0x9f,
	0x0a, 0x42, 0x7f, 0x66, 0x85, 0xc1, 0x76, 0xe2, 0x93, 0xe4, 0x9f, 0x3d, 0xbd, 0x79, 0xbc, 0x42,
	0x59, 0xbd, 0xf9, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xad, 0xde, 0x93, 0xb1, 0x1f, 0x3d, 0x00,
	0x00,
}

func (m *ConnectorList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.TypeMeta.Size()))
		n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ListMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ListMeta.Size()))
		n2, err := m.ListMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintConnect(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Connector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeMeta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.TypeMeta.Size()))
		n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ObjectMeta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ObjectMeta.Size()))
		n4, err := m.ObjectMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Status.Size()))
		n5, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Spec != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Spec.Size()))
		n6, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ErrorMapping != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ErrorMapping.Size()))
		n7, err := m.ErrorMapping.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.OrgId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.OrgId))
	}
	if len(m.AccountId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	if len(m.RequestId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.RequestId)))
		i += copy(dAtA[i:], m.RequestId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Time.Size()))
		n8, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ConnectorConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ConnectorConfig.Size()))
		n9, err := m.ConnectorConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.TaskStatuses) > 0 {
		for k, _ := range m.TaskStatuses {
			dAtA[i] = 0x1a
			i++
			v := m.TaskStatuses[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnect(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovConnect(uint64(len(k))) + msgSize
			i = encodeVarintConnect(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintConnect(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	if len(m.OverrideStatus) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.OverrideStatus)))
		i += copy(dAtA[i:], m.OverrideStatus)
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Status))
	}
	if m.StatusLastUpdatedTime != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.StatusLastUpdatedTime.Size()))
		n11, err := m.StatusLastUpdatedTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.ConnectorRawErrorMsg) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.ConnectorRawErrorMsg)))
		i += copy(dAtA[i:], m.ConnectorRawErrorMsg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TaskStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.State))
	}
	if m.LastUpdated != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.LastUpdated))
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActualState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActualState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.PhysicalClusterId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.PhysicalClusterId)))
		i += copy(dAtA[i:], m.PhysicalClusterId)
	}
	if m.DeprecatedPlugin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.DeprecatedPlugin))
	}
	if m.InternalCluster != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.InternalCluster.Size()))
		n12, err := m.InternalCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Configs != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Configs.Size()))
		n13, err := m.Configs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.WorkerRestEndpoint) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.WorkerRestEndpoint)))
		i += copy(dAtA[i:], m.WorkerRestEndpoint)
	}
	if m.DesiredState != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.DesiredState))
	}
	if len(m.PluginType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.PluginType)))
		i += copy(dAtA[i:], m.PluginType)
	}
	if m.PluginMetadata != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.PluginMetadata.Size()))
		n14, err := m.PluginMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.ActualConfigs != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ActualConfigs.Size()))
		n15, err := m.ActualConfigs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.FeatureFlags != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.FeatureFlags.Size()))
		n16, err := m.FeatureFlags.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.ScheduledDeleteTimestamp != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ScheduledDeleteTimestamp))
	}
	if m.OverrideConfigs != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.OverrideConfigs.Size()))
		n17, err := m.OverrideConfigs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.CreationTimestamp != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.CreationTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectFeatureFlags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectFeatureFlags) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DelegatingServiceEnabled {
		dAtA[i] = 0x8
		i++
		if m.DelegatingServiceEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OperatorPollStatusDarkEnabled {
		dAtA[i] = 0x10
		i++
		if m.OperatorPollStatusDarkEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OperatorPollStatusProdEnabled {
		dAtA[i] = 0x18
		i++
		if m.OperatorPollStatusProdEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PluginMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProductMaturityPhase != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ProductMaturityPhase))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorConfigs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorConfigs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TemplateId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.TemplateId)))
		i += copy(dAtA[i:], m.TemplateId)
	}
	if len(m.UserConfigs) > 0 {
		for k, _ := range m.UserConfigs {
			dAtA[i] = 0x12
			i++
			v := m.UserConfigs[k]
			mapSize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			i = encodeVarintConnect(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.RequestedTime != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.RequestedTime.Size()))
		n18, err := m.RequestedTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Type))
	}
	if m.Required {
		dAtA[i] = 0x18
		i++
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DefaultValue) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.DefaultValue)))
		i += copy(dAtA[i:], m.DefaultValue)
	}
	if m.Importance != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Importance))
	}
	if len(m.Documentation) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Documentation)))
		i += copy(dAtA[i:], m.Documentation)
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if m.Width != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Width))
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if len(m.Dependents) > 0 {
		for _, s := range m.Dependents {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Order != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Order))
	}
	if len(m.Alias) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Alias)))
		i += copy(dAtA[i:], m.Alias)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.RecommendedValues) > 0 {
		for _, s := range m.RecommendedValues {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Visible {
		dAtA[i] = 0x28
		i++
		if m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Configs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Configs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Definition != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Definition.Size()))
		n19, err := m.Definition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Value.Size()))
		n20, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0x1a
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			i = encodeVarintConnect(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatedConnectorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatedConnectorConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.ErrorCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ErrorCount))
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Configs) > 0 {
		for _, msg := range m.Configs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintConnect(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MaterializedConfigs) > 0 {
		for k, _ := range m.MaterializedConfigs {
			dAtA[i] = 0x2a
			i++
			v := m.MaterializedConfigs[k]
			mapSize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			i = encodeVarintConnect(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigWidth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigWidth) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigImportance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigImportance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.WorkerId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.WorkerId)))
		i += copy(dAtA[i:], m.WorkerId)
	}
	if len(m.Trace) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Trace)))
		i += copy(dAtA[i:], m.Trace)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TaskState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Id))
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.WorkerId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.WorkerId)))
		i += copy(dAtA[i:], m.WorkerId)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorStateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorStateInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Connector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Connector.Size()))
		n21, err := m.Connector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintConnect(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProductMaturityPhase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductMaturityPhase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorIdType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorIdType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.IdType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.IdType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorPluginInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorPluginInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Class) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Class)))
		i += copy(dAtA[i:], m.Class)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorPluginDisplayInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorPluginDisplayInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ImageUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.ImageUrl)))
		i += copy(dAtA[i:], m.ImageUrl)
	}
	if m.ProductMaturityPhase != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ProductMaturityPhase))
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorPluginValidationParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorPluginValidationParameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ValidateTemplatedVpc {
		dAtA[i] = 0x8
		i++
		if m.ValidateTemplatedVpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ValidateDelegatedVpc {
		dAtA[i] = 0x10
		i++
		if m.ValidateDelegatedVpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorExpansion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorExpansion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Status.Size()))
		n22, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Info.Size()))
		n23, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Id != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Id.Size()))
		n24, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.Extensions) > 0 {
		for k, _ := range m.Extensions {
			dAtA[i] = 0x22
			i++
			v := m.Extensions[k]
			mapSize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			i = encodeVarintConnect(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorPluginExpansion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorPluginExpansion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Display != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Display.Size()))
		n25, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Info.Size()))
		n26, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.Extensions) > 0 {
		for k, _ := range m.Extensions {
			dAtA[i] = 0x1a
			i++
			v := m.Extensions[k]
			mapSize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			i = encodeVarintConnect(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Config) > 0 {
		for k, _ := range m.Config {
			dAtA[i] = 0x1a
			i++
			v := m.Config[k]
			mapSize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			i = encodeVarintConnect(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			dAtA[i] = 0x22
			i++
			i = encodeVarintConnect(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorTaskId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorTaskId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Connector) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Connector)))
		i += copy(dAtA[i:], m.Connector)
	}
	if m.Task != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Task))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Id.Size()))
		n27, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Config) > 0 {
		for k, _ := range m.Config {
			dAtA[i] = 0x12
			i++
			v := m.Config[k]
			mapSize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			i = encodeVarintConnect(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintConnect(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ErrorCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ErrorCount))
	}
	if len(m.Configs) > 0 {
		for _, msg := range m.Configs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintConnect(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectorPlugin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorPlugin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Clouds) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.Clouds)))
		i += copy(dAtA[i:], m.Clouds)
	}
	if m.Plugin != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Plugin.Size()))
		n28, err := m.Plugin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Display != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.Display.Size()))
		n29, err := m.Display.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.ValidationParameters != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ValidationParameters.Size()))
		n30, err := m.ValidationParameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectOverrideMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectOverrideMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	if len(m.UserMessage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.UserMessage)))
		i += copy(dAtA[i:], m.UserMessage)
	}
	if len(m.ConnectorType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConnect(dAtA, i, uint64(len(m.ConnectorType)))
		i += copy(dAtA[i:], m.ConnectorType)
	}
	if m.ErrorMappingId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConnect(dAtA, i, uint64(m.ErrorMappingId))
	}
	if m.CheckLd {
		dAtA[i] = 0x28
		i++
		if m.CheckLd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConnectOverrideMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectOverrideMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConnectOverrides) > 0 {
		for _, msg := range m.ConnectOverrides {
			dAtA[i] = 0xa
			i++
			i = encodeVarintConnect(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintConnect(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ConnectorList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ListMeta != nil {
		l = m.ListMeta.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Connector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeMeta != nil {
		l = m.TypeMeta.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ErrorMapping != nil {
		l = m.ErrorMapping.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.OrgId != 0 {
		n += 1 + sovConnect(uint64(m.OrgId))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ConnectorConfig != nil {
		l = m.ConnectorConfig.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.TaskStatuses) > 0 {
		for k, v := range m.TaskStatuses {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnect(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovConnect(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovConnect(uint64(mapEntrySize))
		}
	}
	l = len(m.OverrideStatus)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovConnect(uint64(m.Status))
	}
	if m.StatusLastUpdatedTime != nil {
		l = m.StatusLastUpdatedTime.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.ConnectorRawErrorMsg)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovConnect(uint64(m.State))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovConnect(uint64(m.LastUpdated))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActualState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.PhysicalClusterId)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.DeprecatedPlugin != 0 {
		n += 1 + sovConnect(uint64(m.DeprecatedPlugin))
	}
	if m.InternalCluster != nil {
		l = m.InternalCluster.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Configs != nil {
		l = m.Configs.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.WorkerRestEndpoint)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.DesiredState != 0 {
		n += 1 + sovConnect(uint64(m.DesiredState))
	}
	l = len(m.PluginType)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.PluginMetadata != nil {
		l = m.PluginMetadata.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ActualConfigs != nil {
		l = m.ActualConfigs.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.FeatureFlags != nil {
		l = m.FeatureFlags.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ScheduledDeleteTimestamp != 0 {
		n += 1 + sovConnect(uint64(m.ScheduledDeleteTimestamp))
	}
	if m.OverrideConfigs != nil {
		l = m.OverrideConfigs.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.CreationTimestamp != 0 {
		n += 1 + sovConnect(uint64(m.CreationTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectFeatureFlags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelegatingServiceEnabled {
		n += 2
	}
	if m.OperatorPollStatusDarkEnabled {
		n += 2
	}
	if m.OperatorPollStatusProdEnabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductMaturityPhase != 0 {
		n += 1 + sovConnect(uint64(m.ProductMaturityPhase))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorConfigs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TemplateId)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.UserConfigs) > 0 {
		for k, v := range m.UserConfigs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			n += mapEntrySize + 1 + sovConnect(uint64(mapEntrySize))
		}
	}
	if m.RequestedTime != nil {
		l = m.RequestedTime.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovConnect(uint64(m.Type))
	}
	if m.Required {
		n += 2
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Importance != 0 {
		n += 1 + sovConnect(uint64(m.Importance))
	}
	l = len(m.Documentation)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovConnect(uint64(m.Width))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.Dependents) > 0 {
		for _, s := range m.Dependents {
			l = len(s)
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if m.Order != 0 {
		n += 1 + sovConnect(uint64(m.Order))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.RecommendedValues) > 0 {
		for _, s := range m.RecommendedValues {
			l = len(s)
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if m.Visible {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Configs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			n += mapEntrySize + 1 + sovConnect(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatedConnectorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ErrorCount != 0 {
		n += 1 + sovConnect(uint64(m.ErrorCount))
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			l = len(s)
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if len(m.Configs) > 0 {
		for _, e := range m.Configs {
			l = e.Size()
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if len(m.MaterializedConfigs) > 0 {
		for k, v := range m.MaterializedConfigs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			n += mapEntrySize + 1 + sovConnect(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigWidth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigImportance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.WorkerId)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.Trace)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovConnect(uint64(m.Id))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.WorkerId)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorStateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductMaturityPhase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorIdType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.IdType != 0 {
		n += 1 + sovConnect(uint64(m.IdType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorPluginInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Class)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorPluginDisplayInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageUrl)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ProductMaturityPhase != 0 {
		n += 1 + sovConnect(uint64(m.ProductMaturityPhase))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorPluginValidationParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidateTemplatedVpc {
		n += 2
	}
	if m.ValidateDelegatedVpc {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorExpansion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.Extensions) > 0 {
		for k, v := range m.Extensions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			n += mapEntrySize + 1 + sovConnect(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorPluginExpansion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.Extensions) > 0 {
		for k, v := range m.Extensions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			n += mapEntrySize + 1 + sovConnect(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.Config) > 0 {
		for k, v := range m.Config {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			n += mapEntrySize + 1 + sovConnect(uint64(mapEntrySize))
		}
	}
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorTaskId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Connector)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Task != 0 {
		n += 1 + sovConnect(uint64(m.Task))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.Config) > 0 {
		for k, v := range m.Config {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnect(uint64(len(k))) + 1 + len(v) + sovConnect(uint64(len(v)))
			n += mapEntrySize + 1 + sovConnect(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			l = len(s)
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if m.ErrorCount != 0 {
		n += 1 + sovConnect(uint64(m.ErrorCount))
	}
	if len(m.Configs) > 0 {
		for _, e := range m.Configs {
			l = e.Size()
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorPlugin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.Clouds)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Plugin != nil {
		l = m.Plugin.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ValidationParameters != nil {
		l = m.ValidationParameters.Size()
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectOverrideMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.UserMessage)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	l = len(m.ConnectorType)
	if l > 0 {
		n += 1 + l + sovConnect(uint64(l))
	}
	if m.ErrorMappingId != 0 {
		n += 1 + sovConnect(uint64(m.ErrorMappingId))
	}
	if m.CheckLd {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectOverrideMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConnectOverrides) > 0 {
		for _, e := range m.ConnectOverrides {
			l = e.Size()
			n += 1 + l + sovConnect(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovConnect(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozConnect(x uint64) (n int) {
	return sovConnect(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConnectorList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &v1.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ListMeta == nil {
				m.ListMeta = &v1.ListMeta{}
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Connector{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TypeMeta == nil {
				m.TypeMeta = &v1.TypeMeta{}
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &v1.ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ConnectorStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ConnectorSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ErrorMapping == nil {
				m.ErrorMapping = &ConnectOverrideMap{}
			}
			if err := m.ErrorMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &v1.Time{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectorConfig == nil {
				m.ConnectorConfig = &ValidatedConnectorConfig{}
			}
			if err := m.ConnectorConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaskStatuses == nil {
				m.TaskStatuses = make(map[string]*TaskStatus)
			}
			var mapkey string
			var mapvalue *TaskStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthConnect
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthConnect
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TaskStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConnect(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConnect
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TaskStatuses[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OverrideStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ConnectorStatus_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusLastUpdatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatusLastUpdatedTime == nil {
				m.StatusLastUpdatedTime = &v1.Time{}
			}
			if err := m.StatusLastUpdatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorRawErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorRawErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ActualState_Values(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActualState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActualState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActualState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedPlugin", wireType)
			}
			m.DeprecatedPlugin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedPlugin |= ConnectPlugin(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalCluster == nil {
				m.InternalCluster = &KafkaDependency{}
			}
			if err := m.InternalCluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configs == nil {
				m.Configs = &ConnectorConfigs{}
			}
			if err := m.Configs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerRestEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerRestEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredState", wireType)
			}
			m.DesiredState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredState |= ConnectorSpec_DesiredState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PluginType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PluginType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PluginMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PluginMetadata == nil {
				m.PluginMetadata = &PluginMetadata{}
			}
			if err := m.PluginMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActualConfigs == nil {
				m.ActualConfigs = &ConnectorConfigs{}
			}
			if err := m.ActualConfigs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeatureFlags == nil {
				m.FeatureFlags = &ConnectFeatureFlags{}
			}
			if err := m.FeatureFlags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduledDeleteTimestamp", wireType)
			}
			m.ScheduledDeleteTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduledDeleteTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OverrideConfigs == nil {
				m.OverrideConfigs = &ConnectorConfigs{}
			}
			if err := m.OverrideConfigs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			m.CreationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectFeatureFlags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectFeatureFlags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectFeatureFlags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatingServiceEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelegatingServiceEnabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorPollStatusDarkEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OperatorPollStatusDarkEnabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorPollStatusProdEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OperatorPollStatusProdEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductMaturityPhase", wireType)
			}
			m.ProductMaturityPhase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductMaturityPhase |= ProductMaturityPhase_Values(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorConfigs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorConfigs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorConfigs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TemplateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserConfigs == nil {
				m.UserConfigs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConnect(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConnect
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserConfigs[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestedTime == nil {
				m.RequestedTime = &v1.Time{}
			}
			if err := m.RequestedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConfigType_Values(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Importance", wireType)
			}
			m.Importance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Importance |= ConfigImportance_Values(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Documentation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Documentation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= ConfigWidth_Values(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependents = append(m.Dependents, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendedValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecommendedValues = append(m.RecommendedValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Configs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Configs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Configs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &ConfigDefinition{}
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &ConfigValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConnect(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConnect
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatedConnectorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatedConnectorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatedConnectorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configs = append(m.Configs, &Configs{})
			if err := m.Configs[len(m.Configs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaterializedConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaterializedConfigs == nil {
				m.MaterializedConfigs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConnect(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConnect
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MaterializedConfigs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigWidth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigWidth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigWidth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigImportance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigImportance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigImportance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorStateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorStateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorStateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &ConnectorState{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &TaskState{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductMaturityPhase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductMaturityPhase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductMaturityPhase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorIdType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorIdType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorIdType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdType", wireType)
			}
			m.IdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdType |= ConnectorIdType_Values(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorPluginInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorPluginInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorPluginInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Class = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorPluginDisplayInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorPluginDisplayInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorPluginDisplayInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductMaturityPhase", wireType)
			}
			m.ProductMaturityPhase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductMaturityPhase |= ProductMaturityPhase_Values(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorPluginValidationParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorPluginValidationParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorPluginValidationParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateTemplatedVpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidateTemplatedVpc = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateDelegatedVpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidateDelegatedVpc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorExpansion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorExpansion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorExpansion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ConnectorStateInfo{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ConnectorInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &ConnectorId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConnect(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConnect
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Extensions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorPluginExpansion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorPluginExpansion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorPluginExpansion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &ConnectorPluginDisplayInfo{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ConnectorPluginInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConnect(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConnect
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Extensions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConnect(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConnect
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Config[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &ConnectorTaskId{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorTaskId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorTaskId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorTaskId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			m.Task = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Task |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &ConnectorTaskId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConnect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthConnect
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConnect(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConnect
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Config[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configs = append(m.Configs, &Configs{})
			if err := m.Configs[len(m.Configs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorPlugin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorPlugin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorPlugin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clouds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clouds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plugin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plugin == nil {
				m.Plugin = &ConnectorPluginInfo{}
			}
			if err := m.Plugin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &ConnectorPluginDisplayInfo{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidationParameters == nil {
				m.ValidationParameters = &ConnectorPluginValidationParameters{}
			}
			if err := m.ValidationParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectOverrideMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectOverrideMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectOverrideMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMappingId", wireType)
			}
			m.ErrorMappingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorMappingId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckLd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckLd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectOverrideMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectOverrideMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectOverrideMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectOverrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConnect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectOverrides = append(m.ConnectOverrides, &ConnectOverrideMessage{})
			if err := m.ConnectOverrides[len(m.ConnectOverrides)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConnect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConnect(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConnect
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConnect
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConnect
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthConnect
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConnect
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConnect(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthConnect
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConnect = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConnect   = fmt.Errorf("proto: integer overflow")
)
