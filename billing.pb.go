// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: billing/billing.proto

package ccloud

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/confluentinc/proto-go-setter"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type PaymentMethodType int32

const (
	PaymentMethodType_NONE PaymentMethodType = 0
	PaymentMethodType_CARD PaymentMethodType = 1
	PaymentMethodType_ACH  PaymentMethodType = 2
)

var PaymentMethodType_name = map[int32]string{
	0: "NONE",
	1: "CARD",
	2: "ACH",
}

var PaymentMethodType_value = map[string]int32{
	"NONE": 0,
	"CARD": 1,
	"ACH":  2,
}

func (x PaymentMethodType) String() string {
	return proto.EnumName(PaymentMethodType_name, int32(x))
}

func (PaymentMethodType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{0}
}

type GetPriceTableReply struct {
	PriceTable           *PriceTable `protobuf:"bytes,1,opt,name=price_table,json=priceTable,proto3" json:"price_table,omitempty" db:"price_table,omitempty" url:"price_table,omitempty"`
	Error                *Error      `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetPriceTableReply) Reset()         { *m = GetPriceTableReply{} }
func (m *GetPriceTableReply) String() string { return proto.CompactTextString(m) }
func (*GetPriceTableReply) ProtoMessage()    {}
func (*GetPriceTableReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{0}
}
func (m *GetPriceTableReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPriceTableReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPriceTableReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPriceTableReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPriceTableReply.Merge(m, src)
}
func (m *GetPriceTableReply) XXX_Size() int {
	return m.Size()
}
func (m *GetPriceTableReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPriceTableReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetPriceTableReply proto.InternalMessageInfo

func (m *GetPriceTableReply) GetPriceTable() *PriceTable {
	if m != nil {
		return m.PriceTable
	}
	return nil
}

func (m *GetPriceTableReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

// promo code api object for users
type ClaimPromoCodeRequest struct {
	OrgId                int32             `protobuf:"varint,1,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty" db:"org_id,omitempty" url:"org_id,omitempty"`
	Code                 string            `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty" db:"code,omitempty" url:"code,omitempty"`
	ClaimedBy            int32             `protobuf:"varint,3,opt,name=claimed_by,json=claimedBy,proto3" json:"claimed_by,omitempty" db:"claimed_by,omitempty" url:"claimed_by,omitempty"`
	RequestCarrier       map[string]string `protobuf:"bytes,4,rep,name=request_carrier,json=requestCarrier,proto3" json:"request_carrier,omitempty" redact:"-" db:"request_carrier,omitempty" url:"request_carrier,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ClaimPromoCodeRequest) Reset()         { *m = ClaimPromoCodeRequest{} }
func (m *ClaimPromoCodeRequest) String() string { return proto.CompactTextString(m) }
func (*ClaimPromoCodeRequest) ProtoMessage()    {}
func (*ClaimPromoCodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{1}
}
func (m *ClaimPromoCodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimPromoCodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimPromoCodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimPromoCodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimPromoCodeRequest.Merge(m, src)
}
func (m *ClaimPromoCodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClaimPromoCodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimPromoCodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimPromoCodeRequest proto.InternalMessageInfo

func (m *ClaimPromoCodeRequest) GetOrgId() int32 {
	if m != nil {
		return m.OrgId
	}
	return 0
}

func (m *ClaimPromoCodeRequest) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *ClaimPromoCodeRequest) GetClaimedBy() int32 {
	if m != nil {
		return m.ClaimedBy
	}
	return 0
}

func (m *ClaimPromoCodeRequest) GetRequestCarrier() map[string]string {
	if m != nil {
		return m.RequestCarrier
	}
	return nil
}

type ClaimPromoCodeReply struct {
	Claim                *PromoCodeClaim `protobuf:"bytes,1,opt,name=claim,proto3" json:"claim,omitempty" db:"claim,omitempty" url:"claim,omitempty"`
	Error                *Error          `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ClaimPromoCodeReply) Reset()         { *m = ClaimPromoCodeReply{} }
func (m *ClaimPromoCodeReply) String() string { return proto.CompactTextString(m) }
func (*ClaimPromoCodeReply) ProtoMessage()    {}
func (*ClaimPromoCodeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{2}
}
func (m *ClaimPromoCodeReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimPromoCodeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimPromoCodeReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimPromoCodeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimPromoCodeReply.Merge(m, src)
}
func (m *ClaimPromoCodeReply) XXX_Size() int {
	return m.Size()
}
func (m *ClaimPromoCodeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimPromoCodeReply.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimPromoCodeReply proto.InternalMessageInfo

func (m *ClaimPromoCodeReply) GetClaim() *PromoCodeClaim {
	if m != nil {
		return m.Claim
	}
	return nil
}

func (m *ClaimPromoCodeReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type GetPromoCodeClaimsRequest struct {
	OrgId                int32             `protobuf:"varint,1,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty" db:"org_id,omitempty" url:"org_id,omitempty"`
	RequestCarrier       map[string]string `protobuf:"bytes,2,rep,name=request_carrier,json=requestCarrier,proto3" json:"request_carrier,omitempty" redact:"-" db:"request_carrier,omitempty" url:"request_carrier,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ExcludeExpired       bool              `protobuf:"varint,3,opt,name=exclude_expired,json=excludeExpired,proto3" json:"exclude_expired,omitempty" db:"exclude_expired,omitempty" url:"exclude_expired,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetPromoCodeClaimsRequest) Reset()         { *m = GetPromoCodeClaimsRequest{} }
func (m *GetPromoCodeClaimsRequest) String() string { return proto.CompactTextString(m) }
func (*GetPromoCodeClaimsRequest) ProtoMessage()    {}
func (*GetPromoCodeClaimsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{3}
}
func (m *GetPromoCodeClaimsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPromoCodeClaimsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPromoCodeClaimsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPromoCodeClaimsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPromoCodeClaimsRequest.Merge(m, src)
}
func (m *GetPromoCodeClaimsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPromoCodeClaimsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPromoCodeClaimsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPromoCodeClaimsRequest proto.InternalMessageInfo

func (m *GetPromoCodeClaimsRequest) GetOrgId() int32 {
	if m != nil {
		return m.OrgId
	}
	return 0
}

func (m *GetPromoCodeClaimsRequest) GetRequestCarrier() map[string]string {
	if m != nil {
		return m.RequestCarrier
	}
	return nil
}

func (m *GetPromoCodeClaimsRequest) GetExcludeExpired() bool {
	if m != nil {
		return m.ExcludeExpired
	}
	return false
}

type GetPromoCodeClaimsReply struct {
	Claims               []*PromoCodeClaim `protobuf:"bytes,1,rep,name=claims,proto3" json:"claims,omitempty" db:"claims,omitempty" url:"claims,omitempty"`
	Error                *Error            `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetPromoCodeClaimsReply) Reset()         { *m = GetPromoCodeClaimsReply{} }
func (m *GetPromoCodeClaimsReply) String() string { return proto.CompactTextString(m) }
func (*GetPromoCodeClaimsReply) ProtoMessage()    {}
func (*GetPromoCodeClaimsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{4}
}
func (m *GetPromoCodeClaimsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPromoCodeClaimsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPromoCodeClaimsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPromoCodeClaimsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPromoCodeClaimsReply.Merge(m, src)
}
func (m *GetPromoCodeClaimsReply) XXX_Size() int {
	return m.Size()
}
func (m *GetPromoCodeClaimsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPromoCodeClaimsReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetPromoCodeClaimsReply proto.InternalMessageInfo

func (m *GetPromoCodeClaimsReply) GetClaims() []*PromoCodeClaim {
	if m != nil {
		return m.Claims
	}
	return nil
}

func (m *GetPromoCodeClaimsReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type PromoCodeClaim struct {
	OrgId                int32            `protobuf:"varint,1,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty" db:"org_id,omitempty" url:"org_id,omitempty"`
	Code                 string           `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty" db:"code,omitempty" url:"code,omitempty"`
	Amount               int64            `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty" db:"amount,omitempty" url:"amount,omitempty"`
	Balance              int64            `protobuf:"varint,4,opt,name=balance,proto3" json:"balance,omitempty" db:"balance,omitempty" url:"balance,omitempty"`
	ClaimDate            *types.Timestamp `protobuf:"bytes,5,opt,name=claim_date,json=claimDate,proto3" json:"claim_date,omitempty" db:"claim_date,omitempty" url:"claim_date,omitempty"`
	CreditExpirationDate *types.Timestamp `protobuf:"bytes,6,opt,name=credit_expiration_date,json=creditExpirationDate,proto3" json:"credit_expiration_date,omitempty" db:"credit_expiration_date,omitempty" url:"credit_expiration_date,omitempty"`
	ClaimedBy            int32            `protobuf:"varint,7,opt,name=claimed_by,json=claimedBy,proto3" json:"claimed_by,omitempty" db:"claimed_by,omitempty" url:"claimed_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PromoCodeClaim) Reset()         { *m = PromoCodeClaim{} }
func (m *PromoCodeClaim) String() string { return proto.CompactTextString(m) }
func (*PromoCodeClaim) ProtoMessage()    {}
func (*PromoCodeClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{5}
}
func (m *PromoCodeClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PromoCodeClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PromoCodeClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PromoCodeClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PromoCodeClaim.Merge(m, src)
}
func (m *PromoCodeClaim) XXX_Size() int {
	return m.Size()
}
func (m *PromoCodeClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_PromoCodeClaim.DiscardUnknown(m)
}

var xxx_messageInfo_PromoCodeClaim proto.InternalMessageInfo

func (m *PromoCodeClaim) GetOrgId() int32 {
	if m != nil {
		return m.OrgId
	}
	return 0
}

func (m *PromoCodeClaim) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *PromoCodeClaim) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *PromoCodeClaim) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *PromoCodeClaim) GetClaimDate() *types.Timestamp {
	if m != nil {
		return m.ClaimDate
	}
	return nil
}

func (m *PromoCodeClaim) GetCreditExpirationDate() *types.Timestamp {
	if m != nil {
		return m.CreditExpirationDate
	}
	return nil
}

func (m *PromoCodeClaim) GetClaimedBy() int32 {
	if m != nil {
		return m.ClaimedBy
	}
	return 0
}

type PriceTable struct {
	PriceTable           map[string]*UnitPrices `protobuf:"bytes,1,rep,name=price_table,json=priceTable,proto3" json:"price_table,omitempty" db:"price_table,omitempty" url:"price_table,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *PriceTable) Reset()         { *m = PriceTable{} }
func (m *PriceTable) String() string { return proto.CompactTextString(m) }
func (*PriceTable) ProtoMessage()    {}
func (*PriceTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{6}
}
func (m *PriceTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceTable.Merge(m, src)
}
func (m *PriceTable) XXX_Size() int {
	return m.Size()
}
func (m *PriceTable) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceTable.DiscardUnknown(m)
}

var xxx_messageInfo_PriceTable proto.InternalMessageInfo

func (m *PriceTable) GetPriceTable() map[string]*UnitPrices {
	if m != nil {
		return m.PriceTable
	}
	return nil
}

type UnitPrices struct {
	Prices               map[string]float64 `protobuf:"bytes,1,rep,name=prices,proto3" json:"prices,omitempty" db:"prices,omitempty" url:"prices,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	Unit                 string             `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit,omitempty" db:"unit,omitempty" url:"unit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *UnitPrices) Reset()         { *m = UnitPrices{} }
func (m *UnitPrices) String() string { return proto.CompactTextString(m) }
func (*UnitPrices) ProtoMessage()    {}
func (*UnitPrices) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{7}
}
func (m *UnitPrices) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnitPrices) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnitPrices.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnitPrices) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnitPrices.Merge(m, src)
}
func (m *UnitPrices) XXX_Size() int {
	return m.Size()
}
func (m *UnitPrices) XXX_DiscardUnknown() {
	xxx_messageInfo_UnitPrices.DiscardUnknown(m)
}

var xxx_messageInfo_UnitPrices proto.InternalMessageInfo

func (m *UnitPrices) GetPrices() map[string]float64 {
	if m != nil {
		return m.Prices
	}
	return nil
}

func (m *UnitPrices) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

type Card struct {
	Cardholder           string   `protobuf:"bytes,1,opt,name=cardholder,proto3" json:"cardholder,omitempty" db:"cardholder,omitempty" url:"cardholder,omitempty"`
	Brand                string   `protobuf:"bytes,2,opt,name=brand,proto3" json:"brand,omitempty" db:"brand,omitempty" url:"brand,omitempty"`
	Last4                string   `protobuf:"bytes,3,opt,name=last4,proto3" json:"last4,omitempty" db:"last4,omitempty" url:"last4,omitempty"`
	ExpMonth             string   `protobuf:"bytes,4,opt,name=exp_month,json=expMonth,proto3" json:"exp_month,omitempty" db:"exp_month,omitempty" url:"exp_month,omitempty"`
	ExpYear              string   `protobuf:"bytes,5,opt,name=exp_year,json=expYear,proto3" json:"exp_year,omitempty" db:"exp_year,omitempty" url:"exp_year,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Card) Reset()         { *m = Card{} }
func (m *Card) String() string { return proto.CompactTextString(m) }
func (*Card) ProtoMessage()    {}
func (*Card) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{8}
}
func (m *Card) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Card) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Card.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Card) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Card.Merge(m, src)
}
func (m *Card) XXX_Size() int {
	return m.Size()
}
func (m *Card) XXX_DiscardUnknown() {
	xxx_messageInfo_Card.DiscardUnknown(m)
}

var xxx_messageInfo_Card proto.InternalMessageInfo

func (m *Card) GetCardholder() string {
	if m != nil {
		return m.Cardholder
	}
	return ""
}

func (m *Card) GetBrand() string {
	if m != nil {
		return m.Brand
	}
	return ""
}

func (m *Card) GetLast4() string {
	if m != nil {
		return m.Last4
	}
	return ""
}

func (m *Card) GetExpMonth() string {
	if m != nil {
		return m.ExpMonth
	}
	return ""
}

func (m *Card) GetExpYear() string {
	if m != nil {
		return m.ExpYear
	}
	return ""
}

type Account struct {
	BankName             string   `protobuf:"bytes,1,opt,name=bank_name,json=bankName,proto3" json:"bank_name,omitempty" db:"bank_name,omitempty" url:"bank_name,omitempty"`
	Last4                string   `protobuf:"bytes,2,opt,name=last4,proto3" json:"last4,omitempty" db:"last4,omitempty" url:"last4,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{9}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetBankName() string {
	if m != nil {
		return m.BankName
	}
	return ""
}

func (m *Account) GetLast4() string {
	if m != nil {
		return m.Last4
	}
	return ""
}

type PaymentMethod struct {
	Type PaymentMethodType `protobuf:"varint,1,opt,name=type,proto3,enum=ccloud.billing.PaymentMethodType" json:"type,omitempty" db:"type,omitempty" url:"type,omitempty"`
	// Types that are valid to be assigned to PaymentDetails:
	//	*PaymentMethod_Card
	//	*PaymentMethod_Account
	PaymentDetails       isPaymentMethod_PaymentDetails `protobuf_oneof:"payment_details"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *PaymentMethod) Reset()         { *m = PaymentMethod{} }
func (m *PaymentMethod) String() string { return proto.CompactTextString(m) }
func (*PaymentMethod) ProtoMessage()    {}
func (*PaymentMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{10}
}
func (m *PaymentMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentMethod.Merge(m, src)
}
func (m *PaymentMethod) XXX_Size() int {
	return m.Size()
}
func (m *PaymentMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentMethod.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentMethod proto.InternalMessageInfo

type isPaymentMethod_PaymentDetails interface {
	isPaymentMethod_PaymentDetails()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PaymentMethod_Card struct {
	Card *Card `protobuf:"bytes,2,opt,name=card,proto3,oneof"`
}
type PaymentMethod_Account struct {
	Account *Account `protobuf:"bytes,3,opt,name=account,proto3,oneof"`
}

func (*PaymentMethod_Card) isPaymentMethod_PaymentDetails()    {}
func (*PaymentMethod_Account) isPaymentMethod_PaymentDetails() {}

func (m *PaymentMethod) GetPaymentDetails() isPaymentMethod_PaymentDetails {
	if m != nil {
		return m.PaymentDetails
	}
	return nil
}

func (m *PaymentMethod) GetType() PaymentMethodType {
	if m != nil {
		return m.Type
	}
	return PaymentMethodType_NONE
}

func (m *PaymentMethod) GetCard() *Card {
	if x, ok := m.GetPaymentDetails().(*PaymentMethod_Card); ok {
		return x.Card
	}
	return nil
}

func (m *PaymentMethod) GetAccount() *Account {
	if x, ok := m.GetPaymentDetails().(*PaymentMethod_Account); ok {
		return x.Account
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PaymentMethod) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PaymentMethod_OneofMarshaler, _PaymentMethod_OneofUnmarshaler, _PaymentMethod_OneofSizer, []interface{}{
		(*PaymentMethod_Card)(nil),
		(*PaymentMethod_Account)(nil),
	}
}

func _PaymentMethod_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PaymentMethod)
	// payment_details
	switch x := m.PaymentDetails.(type) {
	case *PaymentMethod_Card:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Card); err != nil {
			return err
		}
	case *PaymentMethod_Account:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Account); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PaymentMethod.PaymentDetails has unexpected type %T", x)
	}
	return nil
}

func _PaymentMethod_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PaymentMethod)
	switch tag {
	case 2: // payment_details.card
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Card)
		err := b.DecodeMessage(msg)
		m.PaymentDetails = &PaymentMethod_Card{msg}
		return true, err
	case 3: // payment_details.account
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Account)
		err := b.DecodeMessage(msg)
		m.PaymentDetails = &PaymentMethod_Account{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PaymentMethod_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PaymentMethod)
	// payment_details
	switch x := m.PaymentDetails.(type) {
	case *PaymentMethod_Card:
		s := proto.Size(x.Card)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PaymentMethod_Account:
		s := proto.Size(x.Account)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetPaymentInfoReply struct {
	Card                 *Card          `protobuf:"bytes,1,opt,name=card,proto3" json:"card,omitempty" db:"card,omitempty" url:"card,omitempty"`
	Organization         *Organization  `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty" db:"organization,omitempty" url:"organization,omitempty"`
	Error                *Error         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	TaxAddress           *TaxAddress    `protobuf:"bytes,4,opt,name=tax_address,json=taxAddress,proto3" json:"tax_address,omitempty" db:"tax_address,omitempty" url:"tax_address,omitempty"`
	TaxIds               []*TaxId       `protobuf:"bytes,5,rep,name=tax_ids,json=taxIds,proto3" json:"tax_ids,omitempty" db:"tax_ids,omitempty" url:"tax_ids,omitempty"`
	PaymentMethod        *PaymentMethod `protobuf:"bytes,6,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty" db:"payment_method,omitempty" url:"payment_method,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetPaymentInfoReply) Reset()         { *m = GetPaymentInfoReply{} }
func (m *GetPaymentInfoReply) String() string { return proto.CompactTextString(m) }
func (*GetPaymentInfoReply) ProtoMessage()    {}
func (*GetPaymentInfoReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{11}
}
func (m *GetPaymentInfoReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPaymentInfoReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPaymentInfoReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPaymentInfoReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPaymentInfoReply.Merge(m, src)
}
func (m *GetPaymentInfoReply) XXX_Size() int {
	return m.Size()
}
func (m *GetPaymentInfoReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPaymentInfoReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetPaymentInfoReply proto.InternalMessageInfo

func (m *GetPaymentInfoReply) GetCard() *Card {
	if m != nil {
		return m.Card
	}
	return nil
}

func (m *GetPaymentInfoReply) GetOrganization() *Organization {
	if m != nil {
		return m.Organization
	}
	return nil
}

func (m *GetPaymentInfoReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetPaymentInfoReply) GetTaxAddress() *TaxAddress {
	if m != nil {
		return m.TaxAddress
	}
	return nil
}

func (m *GetPaymentInfoReply) GetTaxIds() []*TaxId {
	if m != nil {
		return m.TaxIds
	}
	return nil
}

func (m *GetPaymentInfoReply) GetPaymentMethod() *PaymentMethod {
	if m != nil {
		return m.PaymentMethod
	}
	return nil
}

type UpdatePaymentInfoRequest struct {
	StripeToken          string            `protobuf:"bytes,1,opt,name=stripe_token,json=stripeToken,proto3" json:"stripe_token,omitempty" redact:"-" db:"stripe_token,omitempty" url:"stripe_token,omitempty"`
	Organization         *Organization     `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty" db:"organization,omitempty" url:"organization,omitempty"`
	RequestCarrier       map[string]string `protobuf:"bytes,3,rep,name=request_carrier,json=requestCarrier,proto3" json:"request_carrier,omitempty" redact:"-" db:"request_carrier,omitempty" url:"request_carrier,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *UpdatePaymentInfoRequest) Reset()         { *m = UpdatePaymentInfoRequest{} }
func (m *UpdatePaymentInfoRequest) String() string { return proto.CompactTextString(m) }
func (*UpdatePaymentInfoRequest) ProtoMessage()    {}
func (*UpdatePaymentInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{12}
}
func (m *UpdatePaymentInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePaymentInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePaymentInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePaymentInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePaymentInfoRequest.Merge(m, src)
}
func (m *UpdatePaymentInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePaymentInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePaymentInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePaymentInfoRequest proto.InternalMessageInfo

func (m *UpdatePaymentInfoRequest) GetStripeToken() string {
	if m != nil {
		return m.StripeToken
	}
	return ""
}

func (m *UpdatePaymentInfoRequest) GetOrganization() *Organization {
	if m != nil {
		return m.Organization
	}
	return nil
}

func (m *UpdatePaymentInfoRequest) GetRequestCarrier() map[string]string {
	if m != nil {
		return m.RequestCarrier
	}
	return nil
}

type UpdatePaymentInfoReply struct {
	Card                 *Card         `protobuf:"bytes,1,opt,name=card,proto3" json:"card,omitempty" db:"card,omitempty" url:"card,omitempty"`
	Organization         *Organization `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty" db:"organization,omitempty" url:"organization,omitempty"`
	Error                *Error        `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdatePaymentInfoReply) Reset()         { *m = UpdatePaymentInfoReply{} }
func (m *UpdatePaymentInfoReply) String() string { return proto.CompactTextString(m) }
func (*UpdatePaymentInfoReply) ProtoMessage()    {}
func (*UpdatePaymentInfoReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{13}
}
func (m *UpdatePaymentInfoReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePaymentInfoReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePaymentInfoReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePaymentInfoReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePaymentInfoReply.Merge(m, src)
}
func (m *UpdatePaymentInfoReply) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePaymentInfoReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePaymentInfoReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePaymentInfoReply proto.InternalMessageInfo

func (m *UpdatePaymentInfoReply) GetCard() *Card {
	if m != nil {
		return m.Card
	}
	return nil
}

func (m *UpdatePaymentInfoReply) GetOrganization() *Organization {
	if m != nil {
		return m.Organization
	}
	return nil
}

func (m *UpdatePaymentInfoReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type TaxAddress struct {
	Line1 string `protobuf:"bytes,1,opt,name=line1,proto3" json:"line1,omitempty" db:"line1,omitempty" url:"line1,omitempty"`
	Line2 string `protobuf:"bytes,2,opt,name=line2,proto3" json:"line2,omitempty" db:"line2,omitempty" url:"line2,omitempty"`
	City  string `protobuf:"bytes,3,opt,name=city,proto3" json:"city,omitempty" db:"city,omitempty" url:"city,omitempty"`
	State string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty" db:"state,omitempty" url:"state,omitempty"`
	// country must follow the ISO 3166-1 alpha-2 standard
	// https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	Country              string   `protobuf:"bytes,5,opt,name=country,proto3" json:"country,omitempty" db:"country,omitempty" url:"country,omitempty"`
	PostalCode           string   `protobuf:"bytes,6,opt,name=postal_code,json=postalCode,proto3" json:"postal_code,omitempty" db:"postal_code,omitempty" url:"postal_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaxAddress) Reset()         { *m = TaxAddress{} }
func (m *TaxAddress) String() string { return proto.CompactTextString(m) }
func (*TaxAddress) ProtoMessage()    {}
func (*TaxAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{14}
}
func (m *TaxAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaxAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaxAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaxAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaxAddress.Merge(m, src)
}
func (m *TaxAddress) XXX_Size() int {
	return m.Size()
}
func (m *TaxAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_TaxAddress.DiscardUnknown(m)
}

var xxx_messageInfo_TaxAddress proto.InternalMessageInfo

func (m *TaxAddress) GetLine1() string {
	if m != nil {
		return m.Line1
	}
	return ""
}

func (m *TaxAddress) GetLine2() string {
	if m != nil {
		return m.Line2
	}
	return ""
}

func (m *TaxAddress) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *TaxAddress) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *TaxAddress) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *TaxAddress) GetPostalCode() string {
	if m != nil {
		return m.PostalCode
	}
	return ""
}

type TaxId struct {
	// details of taxId definition is here:
	// https://stripe.com/docs/api/customer_tax_ids/object
	TypeEnum             string   `protobuf:"bytes,1,opt,name=type_enum,json=typeEnum,proto3" json:"type_enum,omitempty" db:"type_enum,omitempty" url:"type_enum,omitempty"`
	TaxId                string   `protobuf:"bytes,2,opt,name=tax_id,json=taxId,proto3" json:"tax_id,omitempty" db:"tax_id,omitempty" url:"tax_id,omitempty"`
	StripeObjectId       string   `protobuf:"bytes,3,opt,name=stripe_object_id,json=stripeObjectId,proto3" json:"stripe_object_id,omitempty" redact:"-" db:"stripe_object_id,omitempty" url:"stripe_object_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaxId) Reset()         { *m = TaxId{} }
func (m *TaxId) String() string { return proto.CompactTextString(m) }
func (*TaxId) ProtoMessage()    {}
func (*TaxId) Descriptor() ([]byte, []int) {
	return fileDescriptor_76f8da37d8b92239, []int{15}
}
func (m *TaxId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaxId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaxId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaxId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaxId.Merge(m, src)
}
func (m *TaxId) XXX_Size() int {
	return m.Size()
}
func (m *TaxId) XXX_DiscardUnknown() {
	xxx_messageInfo_TaxId.DiscardUnknown(m)
}

var xxx_messageInfo_TaxId proto.InternalMessageInfo

func (m *TaxId) GetTypeEnum() string {
	if m != nil {
		return m.TypeEnum
	}
	return ""
}

func (m *TaxId) GetTaxId() string {
	if m != nil {
		return m.TaxId
	}
	return ""
}

func (m *TaxId) GetStripeObjectId() string {
	if m != nil {
		return m.StripeObjectId
	}
	return ""
}

func init() {
	proto.RegisterEnum("ccloud.billing.PaymentMethodType", PaymentMethodType_name, PaymentMethodType_value)
	proto.RegisterType((*GetPriceTableReply)(nil), "ccloud.billing.GetPriceTableReply")
	proto.RegisterType((*ClaimPromoCodeRequest)(nil), "ccloud.billing.ClaimPromoCodeRequest")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.billing.ClaimPromoCodeRequest.RequestCarrierEntry")
	proto.RegisterType((*ClaimPromoCodeReply)(nil), "ccloud.billing.ClaimPromoCodeReply")
	proto.RegisterType((*GetPromoCodeClaimsRequest)(nil), "ccloud.billing.GetPromoCodeClaimsRequest")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.billing.GetPromoCodeClaimsRequest.RequestCarrierEntry")
	proto.RegisterType((*GetPromoCodeClaimsReply)(nil), "ccloud.billing.GetPromoCodeClaimsReply")
	proto.RegisterType((*PromoCodeClaim)(nil), "ccloud.billing.PromoCodeClaim")
	proto.RegisterType((*PriceTable)(nil), "ccloud.billing.PriceTable")
	proto.RegisterMapType((map[string]*UnitPrices)(nil), "ccloud.billing.PriceTable.PriceTableEntry")
	proto.RegisterType((*UnitPrices)(nil), "ccloud.billing.UnitPrices")
	proto.RegisterMapType((map[string]float64)(nil), "ccloud.billing.UnitPrices.PricesEntry")
	proto.RegisterType((*Card)(nil), "ccloud.billing.Card")
	proto.RegisterType((*Account)(nil), "ccloud.billing.Account")
	proto.RegisterType((*PaymentMethod)(nil), "ccloud.billing.PaymentMethod")
	proto.RegisterType((*GetPaymentInfoReply)(nil), "ccloud.billing.GetPaymentInfoReply")
	proto.RegisterType((*UpdatePaymentInfoRequest)(nil), "ccloud.billing.UpdatePaymentInfoRequest")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.billing.UpdatePaymentInfoRequest.RequestCarrierEntry")
	proto.RegisterType((*UpdatePaymentInfoReply)(nil), "ccloud.billing.UpdatePaymentInfoReply")
	proto.RegisterType((*TaxAddress)(nil), "ccloud.billing.TaxAddress")
	proto.RegisterType((*TaxId)(nil), "ccloud.billing.TaxId")
}

func init() { proto.RegisterFile("billing/billing.proto", fileDescriptor_76f8da37d8b92239) }

var fileDescriptor_76f8da37d8b92239 = []byte{
	// 1750 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0x4f, 0xcf, 0x97, 0xed, 0x9a, 0xc4, 0xf1, 0x76, 0x92, 0xdd, 0xc1, 0x12, 0xe9, 0x30, 0x87,
	0x55, 0x14, 0xec, 0x99, 0x64, 0x88, 0xa2, 0x60, 0x0c, 0x5a, 0xcf, 0xc4, 0x8a, 0x2d, 0x76, 0x63,
	0x53, 0xeb, 0x85, 0x00, 0x87, 0xa1, 0xa6, 0xbb, 0x3c, 0xee, 0x9d, 0x9e, 0xae, 0xa6, 0xba, 0x26,
	0xeb, 0xd9, 0x3f, 0x00, 0xee, 0x48, 0x1c, 0x91, 0x10, 0x42, 0x48, 0x1c, 0x38, 0x22, 0xc1, 0x3f,
	0x80, 0x10, 0x48, 0x08, 0x09, 0x21, 0x71, 0xd9, 0x16, 0xca, 0x85, 0x2b, 0xea, 0x23, 0x27, 0x54,
	0x1f, 0xd3, 0x3d, 0xd3, 0x55, 0x43, 0x84, 0xec, 0xc0, 0x1e, 0xf6, 0xe4, 0xf1, 0xef, 0xd5, 0xfb,
	0xd5, 0xab, 0x57, 0xef, 0xab, 0x1a, 0xdc, 0x1a, 0xf8, 0x41, 0xe0, 0x87, 0xc3, 0xb6, 0xfa, 0xdb,
	0x8a, 0x28, 0x61, 0xc4, 0x5e, 0x77, 0xdd, 0x80, 0x4c, 0xbc, 0x96, 0x42, 0x37, 0x6f, 0x0e, 0xc9,
	0x90, 0x08, 0x51, 0x9b, 0xff, 0x92, 0xab, 0x36, 0x9d, 0x21, 0x21, 0xc3, 0x00, 0xb7, 0xc5, 0x7f,
	0x83, 0xc9, 0x69, 0x9b, 0xf9, 0x63, 0x1c, 0x33, 0x34, 0x8e, 0xd4, 0x82, 0x0d, 0x97, 0x50, 0xdc,
	0xc6, 0x94, 0x12, 0xaa, 0x90, 0x6b, 0x84, 0x0e, 0xdb, 0x84, 0xaa, 0x7d, 0x36, 0xaf, 0xc6, 0x98,
	0x31, 0xac, 0x84, 0xcd, 0x7f, 0x58, 0xc0, 0x7e, 0x8a, 0xd9, 0x31, 0xf5, 0x5d, 0x7c, 0x82, 0x06,
	0x01, 0x86, 0x38, 0x0a, 0xa6, 0xf6, 0x47, 0xa0, 0x1e, 0x71, 0xa8, 0xcf, 0x38, 0xd6, 0xb0, 0xee,
	0x58, 0x77, 0xeb, 0x9d, 0xcd, 0xd6, 0xa2, 0x89, 0xad, 0x5c, 0xab, 0xbb, 0x93, 0x26, 0xce, 0x23,
	0x6f, 0xb0, 0xd3, 0x9c, 0x53, 0xdb, 0x22, 0x63, 0x9f, 0xe1, 0x71, 0xc4, 0xa6, 0xcd, 0x3b, 0x13,
	0x1a, 0x2c, 0x93, 0x41, 0x10, 0x65, 0x3c, 0xf6, 0x73, 0x50, 0x15, 0xb6, 0x37, 0x4a, 0x62, 0x4b,
	0x7b, 0xb6, 0x25, 0x3f, 0x55, 0x6b, 0x9f, 0x4b, 0xba, 0xad, 0x34, 0x71, 0xee, 0xf1, 0xad, 0xc4,
	0x42, 0x6d, 0x93, 0x22, 0x0a, 0x25, 0x61, 0xf3, 0x2f, 0x15, 0x70, 0xab, 0x17, 0x20, 0x7f, 0x7c,
	0x4c, 0xc9, 0x98, 0xf4, 0x88, 0x87, 0x21, 0xfe, 0xfe, 0x04, 0xc7, 0xcc, 0x7e, 0x0a, 0x6a, 0x84,
	0x0e, 0xfb, 0xbe, 0x27, 0xce, 0x59, 0xed, 0xde, 0x4f, 0x13, 0x67, 0x8b, 0x6f, 0x20, 0x51, 0x6d,
	0x07, 0x0d, 0x86, 0x55, 0x42, 0x87, 0x87, 0x9e, 0xfd, 0x0e, 0xa8, 0xb8, 0xc4, 0xc3, 0xc2, 0xf6,
	0xb5, 0xee, 0x56, 0x9a, 0x38, 0x77, 0x39, 0x0d, 0xc7, 0x34, 0x92, 0x02, 0x08, 0x85, 0xa6, 0xfd,
	0x2d, 0x00, 0x5c, 0x6e, 0x23, 0xf6, 0xfa, 0x83, 0x69, 0xa3, 0x2c, 0xcc, 0x79, 0x9c, 0x26, 0xce,
	0x43, 0xc1, 0x93, 0x49, 0x74, 0x36, 0x93, 0x08, 0xae, 0x29, 0xb8, 0x3b, 0xb5, 0x7f, 0x6d, 0x81,
	0xeb, 0x54, 0x9e, 0xb7, 0xef, 0x22, 0x4a, 0x7d, 0x4c, 0x1b, 0x95, 0x3b, 0xe5, 0xbb, 0xf5, 0xce,
	0x97, 0x8b, 0xb7, 0x6a, 0x74, 0x52, 0x4b, 0xfd, 0xed, 0x49, 0xdd, 0xfd, 0x90, 0xd1, 0x69, 0xf7,
	0x1b, 0x69, 0xe2, 0x1c, 0x52, 0xec, 0x21, 0x97, 0xed, 0x34, 0xb7, 0x9b, 0x77, 0xb8, 0x91, 0x85,
	0x4d, 0x34, 0x4b, 0x97, 0xcb, 0xff, 0xf9, 0xaf, 0x2f, 0x5a, 0x70, 0x9d, 0x2e, 0xec, 0xb3, 0xf9,
	0x13, 0x0b, 0xdc, 0x30, 0x6c, 0x6d, 0xef, 0x82, 0xf2, 0x08, 0x4f, 0xc5, 0x85, 0xad, 0x75, 0xef,
	0xa5, 0x89, 0xf3, 0x36, 0xdf, 0x7c, 0x84, 0x75, 0xd7, 0x2c, 0x62, 0x90, 0xab, 0xd9, 0x4f, 0x40,
	0xf5, 0x05, 0x0a, 0x26, 0xb3, 0x9b, 0xca, 0x22, 0x4a, 0x80, 0x1a, 0x43, 0x11, 0x85, 0x52, 0x79,
	0xa7, 0xf4, 0xd8, 0x6a, 0xfe, 0xd5, 0x02, 0x37, 0x8a, 0x0e, 0xe3, 0x09, 0xe4, 0x81, 0xaa, 0x70,
	0xbe, 0x4a, 0x9d, 0xdb, 0x7a, 0xea, 0xa8, 0xe5, 0x42, 0x39, 0xb7, 0x40, 0x28, 0x99, 0xaf, 0x77,
	0xc1, 0x02, 0x81, 0xbc, 0xc6, 0x6c, 0xf9, 0x55, 0x05, 0x7c, 0x4e, 0xd4, 0x85, 0x79, 0x33, 0xe3,
	0x4b, 0xcf, 0x98, 0xdf, 0x1a, 0xc2, 0xb2, 0x24, 0xc2, 0xf2, 0xab, 0x45, 0x8f, 0x2d, 0xb5, 0xe6,
	0xff, 0x14, 0x9a, 0xf6, 0x08, 0x5c, 0xc7, 0xe7, 0x6e, 0x30, 0xf1, 0x70, 0x1f, 0x9f, 0x47, 0x3e,
	0xc5, 0x9e, 0x48, 0xd8, 0xd5, 0x6e, 0x37, 0x4d, 0x9c, 0xaf, 0x09, 0x97, 0x2f, 0x8a, 0x75, 0xe7,
	0x2f, 0x95, 0xc3, 0x75, 0x25, 0xdb, 0x97, 0xa2, 0x4f, 0x7d, 0x1e, 0x7c, 0x62, 0x81, 0xb7, 0x4c,
	0x37, 0xc4, 0x73, 0xe1, 0x0c, 0xd4, 0x44, 0xb8, 0xc6, 0x0d, 0x4b, 0x5c, 0xed, 0xab, 0x92, 0x21,
	0x8b, 0x26, 0xa9, 0x65, 0xce, 0x86, 0x79, 0x18, 0x2a, 0xfe, 0xd7, 0x98, 0x0f, 0xbf, 0xa8, 0x82,
	0xf5, 0x45, 0x33, 0x3f, 0x4d, 0x6d, 0xe3, 0x00, 0xd4, 0xd0, 0x98, 0x4c, 0x42, 0x26, 0x22, 0xb0,
	0x9c, 0x9b, 0x22, 0x51, 0x8d, 0x45, 0x83, 0xa1, 0xd2, 0xb7, 0xdf, 0x05, 0x2b, 0x03, 0x14, 0xa0,
	0xd0, 0xc5, 0x8d, 0x8a, 0xa0, 0xea, 0xa4, 0x89, 0xd3, 0xe2, 0x54, 0x0a, 0xd6, 0xb8, 0x74, 0x1c,
	0xce, 0x28, 0xec, 0x58, 0xb5, 0xb3, 0xbe, 0x87, 0x18, 0x6e, 0x54, 0xd5, 0x14, 0x21, 0x47, 0x98,
	0xd6, 0x6c, 0x84, 0x69, 0x9d, 0xcc, 0x46, 0x98, 0x42, 0xab, 0x13, 0x5a, 0xe6, 0xdb, 0x2f, 0x8a,
	0x54, 0xab, 0x7b, 0x82, 0x18, 0xb6, 0x7f, 0x66, 0x81, 0x37, 0x5d, 0x8a, 0x3d, 0x9f, 0xc9, 0xc4,
	0x42, 0xcc, 0x27, 0xa1, 0xb4, 0xa0, 0xf6, 0x4a, 0x0b, 0x8e, 0xd3, 0xc4, 0x79, 0x57, 0x58, 0x60,
	0x64, 0xd0, 0xad, 0x79, 0xd5, 0x32, 0x78, 0x53, 0x2e, 0xd9, 0xcf, 0x56, 0x08, 0x23, 0x17, 0x1b,
	0xfd, 0xca, 0xa5, 0x35, 0xfa, 0xe6, 0x9f, 0x4a, 0x00, 0xe4, 0x73, 0x99, 0xfd, 0x43, 0xab, 0x38,
	0xc9, 0xf1, 0x0c, 0xbc, 0xb7, 0x7c, 0x92, 0x9b, 0xfb, 0x29, 0x2b, 0xe9, 0x25, 0x4d, 0x76, 0x9b,
	0x7c, 0x02, 0x29, 0x70, 0x5f, 0xb0, 0x7a, 0x7d, 0x6f, 0xbe, 0x7a, 0x19, 0xc6, 0xd3, 0x0f, 0x42,
	0x5f, 0x0e, 0xb6, 0xf1, 0x45, 0x2a, 0xdb, 0xdf, 0x4a, 0x00, 0xe4, 0x4c, 0x76, 0x04, 0x6a, 0xe2,
	0x50, 0xb3, 0x62, 0xf6, 0xf6, 0xf2, 0x5d, 0xa5, 0x2b, 0x63, 0xe9, 0xc6, 0x2c, 0x25, 0xa5, 0xb6,
	0xd9, 0x83, 0x8b, 0x45, 0x4d, 0x42, 0xbc, 0x3c, 0x4c, 0x42, 0x9f, 0x15, 0xcb, 0x03, 0xc7, 0x34,
	0x96, 0x02, 0x08, 0x85, 0xe6, 0xe6, 0x8f, 0x2d, 0x50, 0x9f, 0xb3, 0xe5, 0x32, 0x9b, 0x86, 0x75,
	0x11, 0xd7, 0xfe, 0xa8, 0x0c, 0x2a, 0x3d, 0x44, 0x3d, 0xfb, 0x39, 0x00, 0x2e, 0xa2, 0xde, 0x19,
	0x09, 0x3c, 0x4c, 0x95, 0x5d, 0x79, 0x36, 0x64, 0x12, 0x3d, 0x1b, 0x4c, 0x22, 0x38, 0xc7, 0xc5,
	0x8d, 0x1d, 0x50, 0x14, 0x7a, 0xc5, 0x0e, 0x27, 0x40, 0xbd, 0x96, 0x15, 0x50, 0x28, 0x95, 0x39,
	0x4b, 0x80, 0x62, 0xf6, 0x50, 0x94, 0xd7, 0x39, 0x16, 0x01, 0x6a, 0x2c, 0x45, 0x14, 0x4a, 0x65,
	0xfb, 0x7d, 0xb0, 0x86, 0xcf, 0xa3, 0xfe, 0x98, 0x84, 0xec, 0x4c, 0x54, 0xd7, 0xb5, 0xee, 0xa3,
	0x34, 0x71, 0x3a, 0x72, 0x54, 0x50, 0x02, 0xc3, 0x90, 0xa0, 0x4b, 0xe0, 0x2a, 0x3e, 0x8f, 0xde,
	0xe3, 0xa0, 0x7d, 0x04, 0xf8, 0xef, 0xfe, 0x14, 0x23, 0x2a, 0x0a, 0xec, 0x5a, 0xf7, 0x61, 0x9a,
	0x38, 0xf7, 0x67, 0x9c, 0x1c, 0x37, 0x52, 0x16, 0x04, 0x70, 0x05, 0x9f, 0x47, 0xdf, 0xc6, 0x88,
	0x36, 0x7f, 0x6e, 0x81, 0x95, 0x3d, 0xd7, 0x15, 0xdd, 0xe0, 0x7d, 0xb0, 0x36, 0x40, 0xe1, 0xa8,
	0x1f, 0xa2, 0x31, 0x56, 0xd7, 0x92, 0x59, 0x9c, 0x09, 0x0c, 0x1d, 0x41, 0x97, 0xc0, 0x55, 0x8e,
	0x3e, 0x43, 0x63, 0x9c, 0x3b, 0xb3, 0x74, 0x01, 0x67, 0x36, 0xff, 0x50, 0x02, 0xd7, 0x8e, 0xd1,
	0x74, 0x8c, 0x43, 0xf6, 0x1e, 0x66, 0x67, 0xc4, 0xb3, 0x5d, 0x50, 0x61, 0xd3, 0x48, 0xda, 0xb9,
	0xde, 0xf9, 0x82, 0x56, 0xe2, 0xe6, 0x17, 0x9f, 0x4c, 0x23, 0x9c, 0xa7, 0x12, 0x57, 0xd3, 0x36,
	0x2e, 0x80, 0x50, 0x90, 0xdb, 0xcf, 0x41, 0x85, 0x47, 0x97, 0x2a, 0x39, 0x37, 0xb5, 0xb7, 0x13,
	0xa2, 0xde, 0x5c, 0x07, 0x47, 0xd4, 0x33, 0xc6, 0xec, 0x1c, 0x78, 0x70, 0x05, 0x0a, 0x46, 0x7b,
	0x08, 0x56, 0x90, 0x74, 0xbb, 0x88, 0xb2, 0x7a, 0xe7, 0xad, 0x22, 0xb9, 0xba, 0x95, 0xbc, 0x25,
	0xab, 0xf5, 0x7a, 0x7b, 0xd7, 0xf0, 0x83, 0x2b, 0x70, 0xc6, 0xde, 0x7d, 0x03, 0x5c, 0x8f, 0xa4,
	0x2f, 0xfa, 0x1e, 0x66, 0xc8, 0x0f, 0xe2, 0xe6, 0x2f, 0xab, 0xe0, 0x06, 0x9f, 0xde, 0x24, 0x7c,
	0x18, 0x9e, 0x12, 0x39, 0xb9, 0x7d, 0x53, 0x9d, 0xd6, 0xba, 0xac, 0xd3, 0xaa, 0xb3, 0x7e, 0x0c,
	0xae, 0x12, 0x3a, 0x44, 0xa1, 0xff, 0xb1, 0xe8, 0x88, 0xea, 0xc0, 0x8d, 0x19, 0x3f, 0xa1, 0xc3,
	0xd6, 0xd1, 0x9c, 0xbc, 0xbb, 0x9b, 0x26, 0xce, 0x63, 0x35, 0x5a, 0x65, 0xa8, 0x69, 0xc0, 0x32,
	0x09, 0xe1, 0xc2, 0x5e, 0xaf, 0x6f, 0x46, 0xb4, 0x3f, 0x02, 0x75, 0x86, 0xce, 0xfb, 0xc8, 0xf3,
	0x28, 0x8e, 0x63, 0x91, 0xe1, 0x86, 0xae, 0x74, 0x82, 0xce, 0xf7, 0xe4, 0x8a, 0xbc, 0xb5, 0xce,
	0xa9, 0xe9, 0x71, 0x68, 0x94, 0x41, 0xc0, 0x32, 0x1e, 0x7b, 0x00, 0x56, 0xf8, 0x2a, 0xdf, 0x8b,
	0x1b, 0x55, 0xd1, 0x94, 0x6e, 0x19, 0x36, 0x3d, 0xf4, 0xf2, 0xc0, 0x51, 0xab, 0x8d, 0x7b, 0x2d,
	0xe2, 0xb0, 0xc6, 0xb8, 0x6a, 0x6c, 0xff, 0xc0, 0x02, 0xeb, 0xb3, 0xb0, 0x19, 0x8b, 0x1c, 0x52,
	0xd3, 0xd4, 0xe7, 0xff, 0x63, 0xa2, 0x75, 0xdf, 0x49, 0x13, 0x67, 0x57, 0xf4, 0xbd, 0x05, 0x65,
	0xbd, 0xff, 0x2d, 0x13, 0xc3, 0x6b, 0xd1, 0x3c, 0x61, 0xf3, 0x93, 0x0a, 0x68, 0x7c, 0x10, 0xf1,
	0x29, 0x6b, 0x21, 0x5c, 0xe5, 0xc3, 0xf4, 0x43, 0x70, 0x35, 0x66, 0xd4, 0x8f, 0x70, 0x9f, 0x91,
	0x11, 0x0e, 0x55, 0xcd, 0x7a, 0x9a, 0x26, 0x4e, 0xaf, 0xf0, 0x18, 0x9c, 0x5f, 0xa6, 0x19, 0xb3,
	0x44, 0x08, 0xeb, 0x52, 0x70, 0xc2, 0x71, 0x2d, 0x88, 0x4b, 0xff, 0xc3, 0x20, 0xfe, 0x8d, 0xe1,
	0xdd, 0x5c, 0x16, 0x57, 0xbf, 0xab, 0xcd, 0x23, 0x4b, 0x7c, 0xf5, 0xd9, 0x17, 0x1d, 0xf3, 0x50,
	0xf2, 0xbb, 0x12, 0x78, 0xd3, 0xe0, 0xb3, 0xcf, 0xca, 0xe1, 0x7f, 0xfb, 0x64, 0xfe, 0x63, 0x19,
	0x80, 0xbc, 0xd8, 0x89, 0xb6, 0xef, 0x87, 0xf8, 0x81, 0xba, 0xe1, 0xbc, 0xed, 0x73, 0x50, 0x6f,
	0xfb, 0x05, 0x14, 0x4a, 0xe5, 0x19, 0x4b, 0x47, 0x1b, 0x1e, 0x38, 0x68, 0x64, 0xe9, 0x68, 0x2c,
	0x1d, 0xf1, 0xe2, 0xf6, 0xd9, 0x54, 0x8d, 0x73, 0xf9, 0x95, 0xf9, 0xcc, 0xf0, 0xe2, 0x5a, 0x04,
	0xa1, 0xd0, 0xe4, 0x76, 0xc4, 0x8c, 0x3f, 0x29, 0x2b, 0x8b, 0x76, 0x08, 0xd0, 0x50, 0x4f, 0x0a,
	0x8f, 0x42, 0xa9, 0xcc, 0x5f, 0xdb, 0xa2, 0x27, 0xd3, 0xa9, 0x9a, 0xdd, 0xb2, 0x0a, 0xad, 0x60,
	0xc3, 0xfb, 0xbf, 0x88, 0xc3, 0x19, 0x85, 0xfd, 0x5d, 0x50, 0x8f, 0x48, 0xcc, 0x50, 0xd0, 0x17,
	0x9f, 0x13, 0x6a, 0x82, 0x31, 0x7f, 0xbe, 0xe5, 0x22, 0xbd, 0xf8, 0x1a, 0x65, 0x10, 0x48, 0xbc,
	0x47, 0x3c, 0xdc, 0xfc, 0x69, 0x09, 0x54, 0x45, 0x17, 0xe1, 0x43, 0x21, 0x1f, 0x85, 0xfa, 0x38,
	0x9c, 0x8c, 0x8b, 0x43, 0x61, 0x26, 0x30, 0x8e, 0x53, 0x45, 0x09, 0x5c, 0xe5, 0xe8, 0x7e, 0x38,
	0x11, 0x1f, 0x53, 0x64, 0xf3, 0x51, 0x17, 0x9b, 0x3d, 0x97, 0x24, 0xba, 0xa4, 0x53, 0x2d, 0xb8,
	0x54, 0x34, 0x2a, 0x7b, 0x0a, 0x36, 0x54, 0xf5, 0x26, 0x83, 0x0f, 0xb1, 0xcb, 0x38, 0xa5, 0xbc,
	0xe6, 0xa3, 0x34, 0x71, 0xbe, 0x6e, 0xee, 0x02, 0xd9, 0xd2, 0x65, 0x9d, 0xc0, 0xb4, 0x00, 0xae,
	0x4b, 0xe1, 0x91, 0x90, 0x1d, 0x7a, 0xf7, 0xee, 0x83, 0x37, 0xb4, 0x21, 0xd3, 0x5e, 0x05, 0x95,
	0x67, 0x47, 0xcf, 0xf6, 0x37, 0xae, 0xf0, 0x5f, 0xbd, 0x3d, 0xf8, 0x64, 0xc3, 0xb2, 0x57, 0x40,
	0x79, 0xaf, 0x77, 0xb0, 0x51, 0xea, 0xb2, 0xdf, 0xbf, 0xbc, 0x6d, 0xfd, 0xf9, 0xe5, 0x6d, 0xeb,
	0xef, 0x2f, 0x6f, 0x5b, 0x60, 0xcb, 0x27, 0x2d, 0x97, 0x84, 0xa7, 0xc1, 0x04, 0x87, 0xac, 0x25,
	0xd3, 0x30, 0xfb, 0x44, 0x31, 0x42, 0xa7, 0x23, 0x94, 0x95, 0x9a, 0x17, 0x0f, 0x8e, 0xad, 0xef,
	0x3c, 0x1a, 0xfa, 0xec, 0x6c, 0x32, 0x68, 0xb9, 0x64, 0xdc, 0xce, 0xf4, 0xfc, 0xd0, 0x6d, 0xcb,
	0x14, 0xde, 0x8e, 0xbd, 0xd1, 0xf6, 0x90, 0x6c, 0xbf, 0x78, 0xb0, 0x1d, 0x4d, 0x06, 0x81, 0xef,
	0x7e, 0x45, 0xe2, 0x83, 0x9a, 0x20, 0xfd, 0xd2, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x24, 0x35,
	0x5f, 0xd3, 0x89, 0x1a, 0x00, 0x00,
}

func (m *GetPriceTableReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPriceTableReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PriceTable != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.PriceTable.Size()))
		n1, err := m.PriceTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Error.Size()))
		n2, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClaimPromoCodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimPromoCodeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.OrgId))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.ClaimedBy != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.ClaimedBy))
	}
	if len(m.RequestCarrier) > 0 {
		for k, _ := range m.RequestCarrier {
			dAtA[i] = 0x22
			i++
			v := m.RequestCarrier[k]
			mapSize := 1 + len(k) + sovBilling(uint64(len(k))) + 1 + len(v) + sovBilling(uint64(len(v)))
			i = encodeVarintBilling(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintBilling(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintBilling(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClaimPromoCodeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimPromoCodeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Claim != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Claim.Size()))
		n3, err := m.Claim.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Error.Size()))
		n4, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetPromoCodeClaimsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPromoCodeClaimsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.OrgId))
	}
	if len(m.RequestCarrier) > 0 {
		for k, _ := range m.RequestCarrier {
			dAtA[i] = 0x12
			i++
			v := m.RequestCarrier[k]
			mapSize := 1 + len(k) + sovBilling(uint64(len(k))) + 1 + len(v) + sovBilling(uint64(len(v)))
			i = encodeVarintBilling(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintBilling(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintBilling(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.ExcludeExpired {
		dAtA[i] = 0x18
		i++
		if m.ExcludeExpired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetPromoCodeClaimsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPromoCodeClaimsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Claims) > 0 {
		for _, msg := range m.Claims {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBilling(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Error.Size()))
		n5, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PromoCodeClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PromoCodeClaim) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.OrgId))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Amount))
	}
	if m.Balance != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Balance))
	}
	if m.ClaimDate != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.ClaimDate.Size()))
		n6, err := m.ClaimDate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.CreditExpirationDate != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.CreditExpirationDate.Size()))
		n7, err := m.CreditExpirationDate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ClaimedBy != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.ClaimedBy))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PriceTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PriceTable) > 0 {
		for k, _ := range m.PriceTable {
			dAtA[i] = 0xa
			i++
			v := m.PriceTable[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovBilling(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovBilling(uint64(len(k))) + msgSize
			i = encodeVarintBilling(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintBilling(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintBilling(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UnitPrices) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnitPrices) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prices) > 0 {
		for k, _ := range m.Prices {
			dAtA[i] = 0xa
			i++
			v := m.Prices[k]
			mapSize := 1 + len(k) + sovBilling(uint64(len(k))) + 1 + 8
			i = encodeVarintBilling(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintBilling(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i += 8
		}
	}
	if len(m.Unit) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Unit)))
		i += copy(dAtA[i:], m.Unit)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Card) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Card) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cardholder) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Cardholder)))
		i += copy(dAtA[i:], m.Cardholder)
	}
	if len(m.Brand) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Brand)))
		i += copy(dAtA[i:], m.Brand)
	}
	if len(m.Last4) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Last4)))
		i += copy(dAtA[i:], m.Last4)
	}
	if len(m.ExpMonth) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.ExpMonth)))
		i += copy(dAtA[i:], m.ExpMonth)
	}
	if len(m.ExpYear) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.ExpYear)))
		i += copy(dAtA[i:], m.ExpYear)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BankName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.BankName)))
		i += copy(dAtA[i:], m.BankName)
	}
	if len(m.Last4) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Last4)))
		i += copy(dAtA[i:], m.Last4)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PaymentMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentMethod) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Type))
	}
	if m.PaymentDetails != nil {
		nn9, err := m.PaymentDetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PaymentMethod_Card) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Card != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Card.Size()))
		n10, err := m.Card.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *PaymentMethod_Account) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Account != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Account.Size()))
		n11, err := m.Account.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *GetPaymentInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPaymentInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Card.Size()))
		n12, err := m.Card.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Error.Size()))
		n13, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Organization != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Organization.Size()))
		n14, err := m.Organization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.TaxAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.TaxAddress.Size()))
		n15, err := m.TaxAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.TaxIds) > 0 {
		for _, msg := range m.TaxIds {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintBilling(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PaymentMethod != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.PaymentMethod.Size()))
		n16, err := m.PaymentMethod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdatePaymentInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePaymentInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StripeToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.StripeToken)))
		i += copy(dAtA[i:], m.StripeToken)
	}
	if m.Organization != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Organization.Size()))
		n17, err := m.Organization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.RequestCarrier) > 0 {
		for k, _ := range m.RequestCarrier {
			dAtA[i] = 0x1a
			i++
			v := m.RequestCarrier[k]
			mapSize := 1 + len(k) + sovBilling(uint64(len(k))) + 1 + len(v) + sovBilling(uint64(len(v)))
			i = encodeVarintBilling(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintBilling(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintBilling(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdatePaymentInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePaymentInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Card.Size()))
		n18, err := m.Card.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Error.Size()))
		n19, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Organization != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBilling(dAtA, i, uint64(m.Organization.Size()))
		n20, err := m.Organization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TaxAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaxAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Line1) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Line1)))
		i += copy(dAtA[i:], m.Line1)
	}
	if len(m.Line2) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Line2)))
		i += copy(dAtA[i:], m.Line2)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if len(m.PostalCode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.PostalCode)))
		i += copy(dAtA[i:], m.PostalCode)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TaxId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaxId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TypeEnum) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.TypeEnum)))
		i += copy(dAtA[i:], m.TypeEnum)
	}
	if len(m.TaxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.TaxId)))
		i += copy(dAtA[i:], m.TaxId)
	}
	if len(m.StripeObjectId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBilling(dAtA, i, uint64(len(m.StripeObjectId)))
		i += copy(dAtA[i:], m.StripeObjectId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintBilling(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetPriceTableReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceTable != nil {
		l = m.PriceTable.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClaimPromoCodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgId != 0 {
		n += 1 + sovBilling(uint64(m.OrgId))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.ClaimedBy != 0 {
		n += 1 + sovBilling(uint64(m.ClaimedBy))
	}
	if len(m.RequestCarrier) > 0 {
		for k, v := range m.RequestCarrier {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBilling(uint64(len(k))) + 1 + len(v) + sovBilling(uint64(len(v)))
			n += mapEntrySize + 1 + sovBilling(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClaimPromoCodeReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Claim != nil {
		l = m.Claim.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPromoCodeClaimsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgId != 0 {
		n += 1 + sovBilling(uint64(m.OrgId))
	}
	if len(m.RequestCarrier) > 0 {
		for k, v := range m.RequestCarrier {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBilling(uint64(len(k))) + 1 + len(v) + sovBilling(uint64(len(v)))
			n += mapEntrySize + 1 + sovBilling(uint64(mapEntrySize))
		}
	}
	if m.ExcludeExpired {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPromoCodeClaimsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Claims) > 0 {
		for _, e := range m.Claims {
			l = e.Size()
			n += 1 + l + sovBilling(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PromoCodeClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgId != 0 {
		n += 1 + sovBilling(uint64(m.OrgId))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovBilling(uint64(m.Amount))
	}
	if m.Balance != 0 {
		n += 1 + sovBilling(uint64(m.Balance))
	}
	if m.ClaimDate != nil {
		l = m.ClaimDate.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.CreditExpirationDate != nil {
		l = m.CreditExpirationDate.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.ClaimedBy != 0 {
		n += 1 + sovBilling(uint64(m.ClaimedBy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PriceTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PriceTable) > 0 {
		for k, v := range m.PriceTable {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBilling(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBilling(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBilling(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnitPrices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prices) > 0 {
		for k, v := range m.Prices {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBilling(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovBilling(uint64(mapEntrySize))
		}
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Card) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cardholder)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.Brand)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.Last4)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.ExpMonth)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.ExpYear)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BankName)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.Last4)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBilling(uint64(m.Type))
	}
	if m.PaymentDetails != nil {
		n += m.PaymentDetails.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaymentMethod_Card) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	return n
}
func (m *PaymentMethod_Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	return n
}
func (m *GetPaymentInfoReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.Organization != nil {
		l = m.Organization.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.TaxAddress != nil {
		l = m.TaxAddress.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if len(m.TaxIds) > 0 {
		for _, e := range m.TaxIds {
			l = e.Size()
			n += 1 + l + sovBilling(uint64(l))
		}
	}
	if m.PaymentMethod != nil {
		l = m.PaymentMethod.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdatePaymentInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StripeToken)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.Organization != nil {
		l = m.Organization.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if len(m.RequestCarrier) > 0 {
		for k, v := range m.RequestCarrier {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBilling(uint64(len(k))) + 1 + len(v) + sovBilling(uint64(len(v)))
			n += mapEntrySize + 1 + sovBilling(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdatePaymentInfoReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.Organization != nil {
		l = m.Organization.Size()
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaxAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Line1)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.Line2)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.PostalCode)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaxId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TypeEnum)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.TaxId)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	l = len(m.StripeObjectId)
	if l > 0 {
		n += 1 + l + sovBilling(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBilling(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBilling(x uint64) (n int) {
	return sovBilling(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetPriceTableReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPriceTableReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPriceTableReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PriceTable == nil {
				m.PriceTable = &PriceTable{}
			}
			if err := m.PriceTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimPromoCodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimPromoCodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimPromoCodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedBy", wireType)
			}
			m.ClaimedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCarrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestCarrier == nil {
				m.RequestCarrier = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBilling
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBilling
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBilling
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBilling
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBilling
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBilling(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBilling
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestCarrier[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimPromoCodeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimPromoCodeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimPromoCodeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Claim == nil {
				m.Claim = &PromoCodeClaim{}
			}
			if err := m.Claim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPromoCodeClaimsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPromoCodeClaimsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPromoCodeClaimsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCarrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestCarrier == nil {
				m.RequestCarrier = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBilling
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBilling
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBilling
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBilling
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBilling
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBilling(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBilling
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestCarrier[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeExpired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeExpired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPromoCodeClaimsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPromoCodeClaimsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPromoCodeClaimsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claims", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Claims = append(m.Claims, &PromoCodeClaim{})
			if err := m.Claims[len(m.Claims)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PromoCodeClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PromoCodeClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PromoCodeClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimDate == nil {
				m.ClaimDate = &types.Timestamp{}
			}
			if err := m.ClaimDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditExpirationDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreditExpirationDate == nil {
				m.CreditExpirationDate = &types.Timestamp{}
			}
			if err := m.CreditExpirationDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedBy", wireType)
			}
			m.ClaimedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PriceTable == nil {
				m.PriceTable = make(map[string]*UnitPrices)
			}
			var mapkey string
			var mapvalue *UnitPrices
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBilling
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBilling
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBilling
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBilling
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBilling
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &UnitPrices{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBilling(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBilling
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PriceTable[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitPrices) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitPrices: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitPrices: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prices == nil {
				m.Prices = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBilling
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBilling
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBilling(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBilling
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Prices[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Card) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Card: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Card: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cardholder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cardholder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Last4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpMonth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpMonth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpYear", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpYear = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Last4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PaymentMethodType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Card{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PaymentDetails = &PaymentMethod_Card{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Account{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PaymentDetails = &PaymentMethod_Account{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPaymentInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPaymentInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPaymentInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &Card{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Organization == nil {
				m.Organization = &Organization{}
			}
			if err := m.Organization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaxAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaxAddress == nil {
				m.TaxAddress = &TaxAddress{}
			}
			if err := m.TaxAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaxIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaxIds = append(m.TaxIds, &TaxId{})
			if err := m.TaxIds[len(m.TaxIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaymentMethod == nil {
				m.PaymentMethod = &PaymentMethod{}
			}
			if err := m.PaymentMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePaymentInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePaymentInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePaymentInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripeToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StripeToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Organization == nil {
				m.Organization = &Organization{}
			}
			if err := m.Organization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCarrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestCarrier == nil {
				m.RequestCarrier = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBilling
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBilling
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBilling
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBilling
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBilling
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBilling
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBilling(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBilling
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestCarrier[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePaymentInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePaymentInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePaymentInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &Card{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Organization == nil {
				m.Organization = &Organization{}
			}
			if err := m.Organization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaxAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaxAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaxAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Line1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Line2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostalCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostalCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaxId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaxId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaxId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeEnum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeEnum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripeObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBilling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBilling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StripeObjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBilling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBilling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBilling(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBilling
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBilling
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBilling
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthBilling
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBilling
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBilling(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthBilling
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBilling = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBilling   = fmt.Errorf("proto: integer overflow")
)
