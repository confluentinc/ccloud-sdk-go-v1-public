// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flow/flow.proto

package ccloud

import (
	fmt "fmt"
	_ "github.com/confluentinc/proto-go-setter"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type AuthenticateRequest struct {
	Email                string            `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty" db:"email,omitempty" url:"email,omitempty"`
	Password             string            `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty" redact:"-" db:"password,omitempty" url:"password,omitempty"`
	RequestCarrier       map[string]string `protobuf:"bytes,3,rep,name=request_carrier,json=requestCarrier,proto3" json:"request_carrier,omitempty" redact:"-" db:"request_carrier,omitempty" url:"request_carrier,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	IdToken              string            `protobuf:"bytes,4,opt,name=id_token,json=idToken,proto3" json:"id_token,omitempty" db:"id_token,omitempty" url:"id_token,omitempty"`
	ExternalOauthToken   string            `protobuf:"bytes,5,opt,name=external_oauth_token,json=externalOauthToken,proto3" json:"external_oauth_token,omitempty" db:"external_oauth_token,omitempty" url:"external_oauth_token,omitempty"`
	OrgResourceId        string            `protobuf:"bytes,6,opt,name=org_resource_id,json=orgResourceId,proto3" json:"org_resource_id,omitempty" db:"org_resource_id,omitempty" url:"org_resource_id,omitempty"`
	IdentityPool         string            `protobuf:"bytes,7,opt,name=identity_pool,json=identityPool,proto3" json:"identity_pool,omitempty" db:"identity_pool,omitempty" url:"identity_pool,omitempty"`
	RefreshToken         string            `protobuf:"bytes,8,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty" db:"refresh_token,omitempty" url:"refresh_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AuthenticateRequest) Reset()         { *m = AuthenticateRequest{} }
func (m *AuthenticateRequest) String() string { return proto.CompactTextString(m) }
func (*AuthenticateRequest) ProtoMessage()    {}
func (*AuthenticateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{0}
}
func (m *AuthenticateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticateRequest.Merge(m, src)
}
func (m *AuthenticateRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticateRequest proto.InternalMessageInfo

func (m *AuthenticateRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *AuthenticateRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AuthenticateRequest) GetRequestCarrier() map[string]string {
	if m != nil {
		return m.RequestCarrier
	}
	return nil
}

func (m *AuthenticateRequest) GetIdToken() string {
	if m != nil {
		return m.IdToken
	}
	return ""
}

func (m *AuthenticateRequest) GetExternalOauthToken() string {
	if m != nil {
		return m.ExternalOauthToken
	}
	return ""
}

func (m *AuthenticateRequest) GetOrgResourceId() string {
	if m != nil {
		return m.OrgResourceId
	}
	return ""
}

func (m *AuthenticateRequest) GetIdentityPool() string {
	if m != nil {
		return m.IdentityPool
	}
	return ""
}

func (m *AuthenticateRequest) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

type AuthenticateReply struct {
	Token                string        `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty" db:"token,omitempty" url:"token,omitempty"`
	Error                *Error        `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	User                 *User         `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty" db:"user,omitempty" url:"user,omitempty"`
	Organization         *Organization `protobuf:"bytes,4,opt,name=organization,proto3" json:"organization,omitempty" db:"organization,omitempty" url:"organization,omitempty"`
	RefreshToken         string        `protobuf:"bytes,5,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty" db:"refresh_token,omitempty" url:"refresh_token,omitempty"`
	IdentityProvider     string        `protobuf:"bytes,6,opt,name=identity_provider,json=identityProvider,proto3" json:"identity_provider,omitempty" db:"identity_provider,omitempty" url:"identity_provider,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AuthenticateReply) Reset()         { *m = AuthenticateReply{} }
func (m *AuthenticateReply) String() string { return proto.CompactTextString(m) }
func (*AuthenticateReply) ProtoMessage()    {}
func (*AuthenticateReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{1}
}
func (m *AuthenticateReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticateReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticateReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticateReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticateReply.Merge(m, src)
}
func (m *AuthenticateReply) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticateReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticateReply.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticateReply proto.InternalMessageInfo

func (m *AuthenticateReply) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AuthenticateReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *AuthenticateReply) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *AuthenticateReply) GetOrganization() *Organization {
	if m != nil {
		return m.Organization
	}
	return nil
}

func (m *AuthenticateReply) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *AuthenticateReply) GetIdentityProvider() string {
	if m != nil {
		return m.IdentityProvider
	}
	return ""
}

type CreateConnectAuthTokenReply struct {
	Error                *Error   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty" db:"token,omitempty" url:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateConnectAuthTokenReply) Reset()         { *m = CreateConnectAuthTokenReply{} }
func (m *CreateConnectAuthTokenReply) String() string { return proto.CompactTextString(m) }
func (*CreateConnectAuthTokenReply) ProtoMessage()    {}
func (*CreateConnectAuthTokenReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{2}
}
func (m *CreateConnectAuthTokenReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateConnectAuthTokenReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateConnectAuthTokenReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateConnectAuthTokenReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateConnectAuthTokenReply.Merge(m, src)
}
func (m *CreateConnectAuthTokenReply) XXX_Size() int {
	return m.Size()
}
func (m *CreateConnectAuthTokenReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateConnectAuthTokenReply.DiscardUnknown(m)
}

var xxx_messageInfo_CreateConnectAuthTokenReply proto.InternalMessageInfo

func (m *CreateConnectAuthTokenReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CreateConnectAuthTokenReply) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type CreateDecisionEngineAuthTokenReply struct {
	Error                *Error   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty" db:"token,omitempty" url:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateDecisionEngineAuthTokenReply) Reset()         { *m = CreateDecisionEngineAuthTokenReply{} }
func (m *CreateDecisionEngineAuthTokenReply) String() string { return proto.CompactTextString(m) }
func (*CreateDecisionEngineAuthTokenReply) ProtoMessage()    {}
func (*CreateDecisionEngineAuthTokenReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{3}
}
func (m *CreateDecisionEngineAuthTokenReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDecisionEngineAuthTokenReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDecisionEngineAuthTokenReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDecisionEngineAuthTokenReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDecisionEngineAuthTokenReply.Merge(m, src)
}
func (m *CreateDecisionEngineAuthTokenReply) XXX_Size() int {
	return m.Size()
}
func (m *CreateDecisionEngineAuthTokenReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDecisionEngineAuthTokenReply.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDecisionEngineAuthTokenReply proto.InternalMessageInfo

func (m *CreateDecisionEngineAuthTokenReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CreateDecisionEngineAuthTokenReply) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type GetMeRequest struct {
	RequestCarrier       map[string]string `protobuf:"bytes,1,rep,name=request_carrier,json=requestCarrier,proto3" json:"request_carrier,omitempty" redact:"-" db:"request_carrier,omitempty" url:"request_carrier,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetMeRequest) Reset()         { *m = GetMeRequest{} }
func (m *GetMeRequest) String() string { return proto.CompactTextString(m) }
func (*GetMeRequest) ProtoMessage()    {}
func (*GetMeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{4}
}
func (m *GetMeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMeRequest.Merge(m, src)
}
func (m *GetMeRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMeRequest proto.InternalMessageInfo

func (m *GetMeRequest) GetRequestCarrier() map[string]string {
	if m != nil {
		return m.RequestCarrier
	}
	return nil
}

type GetMeReply struct {
	Error                *Error        `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	User                 *User         `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty" db:"user,omitempty" url:"user,omitempty"`
	Organization         *Organization `protobuf:"bytes,3,opt,name=organization,proto3" json:"organization,omitempty" db:"organization,omitempty" url:"organization,omitempty"`
	Accounts             []*Account    `protobuf:"bytes,4,rep,name=accounts,proto3" json:"accounts,omitempty" db:"accounts,omitempty" url:"accounts,omitempty"`
	Account              *Account      `protobuf:"bytes,5,opt,name=account,proto3" json:"account,omitempty" db:"account,omitempty" url:"account,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetMeReply) Reset()         { *m = GetMeReply{} }
func (m *GetMeReply) String() string { return proto.CompactTextString(m) }
func (*GetMeReply) ProtoMessage()    {}
func (*GetMeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{5}
}
func (m *GetMeReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMeReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMeReply.Merge(m, src)
}
func (m *GetMeReply) XXX_Size() int {
	return m.Size()
}
func (m *GetMeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMeReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetMeReply proto.InternalMessageInfo

func (m *GetMeReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetMeReply) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *GetMeReply) GetOrganization() *Organization {
	if m != nil {
		return m.Organization
	}
	return nil
}

func (m *GetMeReply) GetAccounts() []*Account {
	if m != nil {
		return m.Accounts
	}
	return nil
}

func (m *GetMeReply) GetAccount() *Account {
	if m != nil {
		return m.Account
	}
	return nil
}

type GetLoginRealmRequest struct {
	ClientId             string            `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty" db:"client_id,omitempty" url:"client_id,omitempty"`
	Email                string            `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty" db:"email,omitempty" url:"email,omitempty"`
	RequestCarrier       map[string]string `protobuf:"bytes,3,rep,name=request_carrier,json=requestCarrier,proto3" json:"request_carrier,omitempty" redact:"-" db:"request_carrier,omitempty" url:"request_carrier,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	OrgResourceId        string            `protobuf:"bytes,4,opt,name=org_resource_id,json=orgResourceId,proto3" json:"org_resource_id,omitempty" db:"org_resource_id,omitempty" url:"org_resource_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetLoginRealmRequest) Reset()         { *m = GetLoginRealmRequest{} }
func (m *GetLoginRealmRequest) String() string { return proto.CompactTextString(m) }
func (*GetLoginRealmRequest) ProtoMessage()    {}
func (*GetLoginRealmRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{6}
}
func (m *GetLoginRealmRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLoginRealmRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLoginRealmRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLoginRealmRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLoginRealmRequest.Merge(m, src)
}
func (m *GetLoginRealmRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLoginRealmRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLoginRealmRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLoginRealmRequest proto.InternalMessageInfo

func (m *GetLoginRealmRequest) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *GetLoginRealmRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *GetLoginRealmRequest) GetRequestCarrier() map[string]string {
	if m != nil {
		return m.RequestCarrier
	}
	return nil
}

func (m *GetLoginRealmRequest) GetOrgResourceId() string {
	if m != nil {
		return m.OrgResourceId
	}
	return ""
}

type GetLoginRealmReply struct {
	Realm                string   `protobuf:"bytes,1,opt,name=realm,proto3" json:"realm,omitempty" db:"realm,omitempty" url:"realm,omitempty"`
	IsSso                bool     `protobuf:"varint,2,opt,name=is_sso,json=isSso,proto3" json:"is_sso,omitempty" db:"is_sso,omitempty" url:"is_sso,omitempty"`
	Error                *Error   `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	MfaRequired          bool     `protobuf:"varint,4,opt,name=mfa_required,json=mfaRequired,proto3" json:"mfa_required,omitempty" db:"mfa_required,omitempty" url:"mfa_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLoginRealmReply) Reset()         { *m = GetLoginRealmReply{} }
func (m *GetLoginRealmReply) String() string { return proto.CompactTextString(m) }
func (*GetLoginRealmReply) ProtoMessage()    {}
func (*GetLoginRealmReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{7}
}
func (m *GetLoginRealmReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLoginRealmReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLoginRealmReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLoginRealmReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLoginRealmReply.Merge(m, src)
}
func (m *GetLoginRealmReply) XXX_Size() int {
	return m.Size()
}
func (m *GetLoginRealmReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLoginRealmReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetLoginRealmReply proto.InternalMessageInfo

func (m *GetLoginRealmReply) GetRealm() string {
	if m != nil {
		return m.Realm
	}
	return ""
}

func (m *GetLoginRealmReply) GetIsSso() bool {
	if m != nil {
		return m.IsSso
	}
	return false
}

func (m *GetLoginRealmReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetLoginRealmReply) GetMfaRequired() bool {
	if m != nil {
		return m.MfaRequired
	}
	return false
}

type CreateEmailVerificationRequest struct {
	// Only username is required
	Credentials          *Credentials      `protobuf:"bytes,1,opt,name=credentials,proto3" json:"credentials,omitempty" db:"credentials,omitempty" url:"credentials,omitempty"`
	RequestCarrier       map[string]string `protobuf:"bytes,2,rep,name=request_carrier,json=requestCarrier,proto3" json:"request_carrier,omitempty" redact:"-" db:"request_carrier,omitempty" url:"request_carrier,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CreateEmailVerificationRequest) Reset()         { *m = CreateEmailVerificationRequest{} }
func (m *CreateEmailVerificationRequest) String() string { return proto.CompactTextString(m) }
func (*CreateEmailVerificationRequest) ProtoMessage()    {}
func (*CreateEmailVerificationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{8}
}
func (m *CreateEmailVerificationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateEmailVerificationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateEmailVerificationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateEmailVerificationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateEmailVerificationRequest.Merge(m, src)
}
func (m *CreateEmailVerificationRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateEmailVerificationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateEmailVerificationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateEmailVerificationRequest proto.InternalMessageInfo

func (m *CreateEmailVerificationRequest) GetCredentials() *Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *CreateEmailVerificationRequest) GetRequestCarrier() map[string]string {
	if m != nil {
		return m.RequestCarrier
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthenticateRequest)(nil), "ccloud.flow.AuthenticateRequest")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.flow.AuthenticateRequest.RequestCarrierEntry")
	proto.RegisterType((*AuthenticateReply)(nil), "ccloud.flow.AuthenticateReply")
	proto.RegisterType((*CreateConnectAuthTokenReply)(nil), "ccloud.flow.CreateConnectAuthTokenReply")
	proto.RegisterType((*CreateDecisionEngineAuthTokenReply)(nil), "ccloud.flow.CreateDecisionEngineAuthTokenReply")
	proto.RegisterType((*GetMeRequest)(nil), "ccloud.flow.GetMeRequest")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.flow.GetMeRequest.RequestCarrierEntry")
	proto.RegisterType((*GetMeReply)(nil), "ccloud.flow.GetMeReply")
	proto.RegisterType((*GetLoginRealmRequest)(nil), "ccloud.flow.GetLoginRealmRequest")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.flow.GetLoginRealmRequest.RequestCarrierEntry")
	proto.RegisterType((*GetLoginRealmReply)(nil), "ccloud.flow.GetLoginRealmReply")
	proto.RegisterType((*CreateEmailVerificationRequest)(nil), "ccloud.flow.CreateEmailVerificationRequest")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.flow.CreateEmailVerificationRequest.RequestCarrierEntry")
}

func init() { proto.RegisterFile("flow/flow.proto", fileDescriptor_3c1fa740027c1208) }

var fileDescriptor_3c1fa740027c1208 = []byte{
	// 1156 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcf, 0x6f, 0xdc, 0x44,
	0x14, 0x96, 0x77, 0x37, 0xc9, 0x76, 0x76, 0x4b, 0x52, 0x27, 0x12, 0xab, 0x20, 0xc5, 0x91, 0x0f,
	0x28, 0x94, 0xac, 0xb7, 0x0d, 0x25, 0xaa, 0xd2, 0xaa, 0x55, 0x36, 0x0d, 0x21, 0x52, 0x51, 0xca,
	0x14, 0x10, 0x82, 0xc3, 0xca, 0xb1, 0x67, 0x37, 0xc3, 0x7a, 0x3d, 0xdb, 0xf1, 0x38, 0x65, 0x7b,
	0x40, 0xfc, 0x0d, 0xdc, 0xf9, 0x03, 0xb8, 0xc1, 0x19, 0x71, 0xe3, 0xc0, 0x91, 0x33, 0x12, 0x16,
	0xca, 0x5f, 0x00, 0x96, 0xb8, 0x70, 0x42, 0x33, 0x63, 0x7b, 0xfd, 0x6b, 0x73, 0x69, 0x42, 0x8b,
	0xd4, 0x4b, 0xbb, 0xfe, 0xbe, 0x99, 0xf7, 0x8d, 0x9f, 0xdf, 0xf7, 0xe6, 0x29, 0x60, 0xb1, 0xef,
	0x90, 0xa7, 0x1d, 0xfe, 0x8f, 0x31, 0xa6, 0x84, 0x11, 0xb5, 0x61, 0x59, 0x0e, 0xf1, 0x6d, 0x83,
	0x43, 0xab, 0x2b, 0x03, 0x32, 0x20, 0x02, 0xef, 0xf0, 0x5f, 0x72, 0xc9, 0xea, 0x92, 0x45, 0x28,
	0xea, 0x20, 0x4a, 0x09, 0x8d, 0x90, 0xab, 0x84, 0x0e, 0x3a, 0x84, 0x0e, 0xa2, 0xc7, 0xa6, 0x87,
	0x18, 0x43, 0x11, 0xa9, 0x7f, 0x53, 0x07, 0xcb, 0xbb, 0x3e, 0x3b, 0x41, 0x2e, 0xc3, 0x96, 0xc9,
	0x10, 0x44, 0x4f, 0x7c, 0xe4, 0x31, 0xf5, 0x01, 0x98, 0x43, 0x23, 0x13, 0x3b, 0x2d, 0x65, 0x5d,
	0xd9, 0xb8, 0xd2, 0x35, 0xc2, 0x40, 0xbb, 0x6e, 0x1f, 0xef, 0xe8, 0x02, 0xdc, 0x24, 0x23, 0xcc,
	0xd0, 0x68, 0xcc, 0x26, 0xfa, 0xba, 0x4f, 0x9d, 0x22, 0x0a, 0xe5, 0x66, 0xf5, 0x73, 0x50, 0x1f,
	0x9b, 0x9e, 0xf7, 0x94, 0x50, 0xbb, 0x55, 0x11, 0x81, 0xee, 0x87, 0x81, 0x76, 0x87, 0x22, 0xdb,
	0xb4, 0xd8, 0x8e, 0xde, 0xd6, 0xd7, 0x79, 0xcc, 0x78, 0x49, 0x21, 0x6c, 0x09, 0x01, 0x93, 0x80,
	0xea, 0xf7, 0x0a, 0x58, 0xa4, 0xf2, 0xb8, 0x3d, 0xcb, 0xa4, 0x14, 0x23, 0xda, 0xaa, 0xae, 0x57,
	0x37, 0x1a, 0x5b, 0xb7, 0x8c, 0x54, 0x9e, 0x8c, 0x92, 0xd7, 0x33, 0xa2, 0xff, 0xf7, 0xe4, 0xb6,
	0x7d, 0x97, 0xd1, 0x49, 0xf7, 0xc3, 0x30, 0xd0, 0x0e, 0x73, 0x47, 0xcb, 0xc5, 0x2f, 0x9c, 0x70,
	0x36, 0xff, 0xe7, 0x3f, 0x6f, 0x2b, 0xf0, 0x35, 0x9a, 0xd1, 0x51, 0x8f, 0x40, 0x1d, 0xdb, 0x3d,
	0x46, 0x86, 0xc8, 0x6d, 0xd5, 0x44, 0x3e, 0x6e, 0x85, 0x81, 0x76, 0x83, 0x2b, 0xc5, 0x78, 0x41,
	0xa2, 0x84, 0x80, 0x0b, 0xd8, 0xfe, 0x88, 0x63, 0xea, 0x57, 0x60, 0x05, 0x7d, 0xc9, 0x10, 0x75,
	0x4d, 0xa7, 0x47, 0x4c, 0x9f, 0x9d, 0x44, 0xc1, 0xe7, 0x44, 0xf0, 0x87, 0x61, 0xa0, 0xbd, 0x2f,
	0xbe, 0x5a, 0xc9, 0x9a, 0xe2, 0x47, 0x3c, 0x7f, 0x11, 0x54, 0xe3, 0x05, 0x47, 0x9c, 0x97, 0xfa,
	0x5f, 0x80, 0x45, 0x42, 0x07, 0x3d, 0x8a, 0x3c, 0xe2, 0x53, 0x0b, 0xf5, 0xb0, 0xdd, 0x9a, 0x17,
	0xd2, 0xdd, 0x30, 0xd0, 0xee, 0x71, 0xe9, 0x1c, 0x5d, 0x50, 0x9d, 0xcd, 0x43, 0x5e, 0xb8, 0x30,
	0xa2, 0x0e, 0x6d, 0xd5, 0x02, 0x57, 0xb1, 0xcd, 0x3f, 0x24, 0x9b, 0xf4, 0xc6, 0x84, 0x38, 0xad,
	0x05, 0xa1, 0x74, 0x2f, 0x0c, 0xb4, 0x1d, 0x99, 0xc1, 0x14, 0x59, 0x92, 0xc6, 0x72, 0x16, 0x36,
	0x63, 0xe6, 0x11, 0x21, 0x0e, 0x17, 0xa1, 0xa8, 0x4f, 0x91, 0x17, 0x67, 0xb2, 0x9e, 0x15, 0xc9,
	0x90, 0x25, 0xe5, 0x50, 0xce, 0xc2, 0x66, 0xc4, 0x88, 0xac, 0xad, 0x7e, 0xab, 0x80, 0xe5, 0x92,
	0x0a, 0x54, 0xef, 0x82, 0xea, 0x10, 0x4d, 0x22, 0xcb, 0x5d, 0x0f, 0x03, 0xed, 0x4d, 0x2e, 0x39,
	0x44, 0x93, 0x82, 0x50, 0x16, 0x83, 0x7c, 0x1b, 0xb7, 0xec, 0xa9, 0xe9, 0xf8, 0x28, 0x72, 0x5a,
	0x62, 0x59, 0x01, 0x16, 0x22, 0xe4, 0x51, 0x28, 0x37, 0xef, 0x54, 0x6e, 0x2b, 0xfa, 0xef, 0x35,
	0x70, 0x2d, 0xeb, 0x9a, 0xb1, 0x23, 0xe2, 0xcb, 0x94, 0xe4, 0x5a, 0x42, 0x79, 0x2a, 0x0a, 0x29,
	0x90, 0x9b, 0xd5, 0x4f, 0xc1, 0x9c, 0x68, 0x4e, 0xe2, 0x94, 0x8d, 0x2d, 0x35, 0xb6, 0x2a, 0x6f,
	0x5b, 0xc6, 0x3e, 0x67, 0x52, 0xcd, 0x86, 0x3f, 0x16, 0xeb, 0x34, 0x87, 0x42, 0x19, 0x50, 0x85,
	0xa0, 0xe6, 0x7b, 0xa2, 0x07, 0xf0, 0xc0, 0x4b, 0x71, 0x60, 0xde, 0xf9, 0x3e, 0xf6, 0x10, 0xed,
	0x6e, 0x86, 0x81, 0xb6, 0xc1, 0xc3, 0xf2, 0x55, 0x85, 0xa8, 0x39, 0x10, 0x8a, 0x58, 0xea, 0x33,
	0xd0, 0x24, 0x74, 0x60, 0xba, 0xf8, 0x99, 0xc9, 0x30, 0x91, 0xa6, 0x6d, 0x6c, 0xb5, 0xd2, 0xb1,
	0x8f, 0x52, 0x7c, 0xf7, 0x6e, 0x18, 0x68, 0xb7, 0xa3, 0xb2, 0x4f, 0xd0, 0xb2, 0x9a, 0x2f, 0x23,
	0x61, 0x46, 0xab, 0x58, 0x8a, 0x73, 0x17, 0x5f, 0x8a, 0xaa, 0x07, 0xae, 0x4d, 0x9d, 0x41, 0xc9,
	0x29, 0xb6, 0x11, 0x8d, 0x2c, 0xfc, 0x5e, 0x18, 0x68, 0xdd, 0xac, 0xb1, 0xa2, 0x05, 0xe7, 0x98,
	0xab, 0xb8, 0x02, 0x2e, 0x25, 0x06, 0x8b, 0x48, 0xfd, 0x27, 0x05, 0xbc, 0xb1, 0x47, 0x91, 0xc9,
	0xd0, 0x1e, 0x71, 0x5d, 0x64, 0xb1, 0xdd, 0xb8, 0xa1, 0xc8, 0x4a, 0x4b, 0x6a, 0x44, 0xb9, 0xe8,
	0x1a, 0x49, 0x6a, 0xb8, 0xf2, 0x1c, 0x35, 0xac, 0xff, 0xac, 0x00, 0x5d, 0x9e, 0xff, 0x01, 0xb2,
	0xb0, 0x87, 0x89, 0xbb, 0xef, 0x0e, 0xb0, 0x8b, 0xfe, 0x67, 0xaf, 0xf1, 0x5b, 0x05, 0x34, 0x0f,
	0x10, 0xfb, 0x20, 0xb9, 0xf4, 0xbf, 0x2b, 0xb9, 0x51, 0x15, 0x71, 0xa3, 0xb6, 0x33, 0x37, 0x6a,
	0x7a, 0xd3, 0x0b, 0xba, 0x4a, 0x5f, 0xfa, 0x1e, 0xfa, 0x75, 0x0d, 0x80, 0x28, 0x4f, 0x97, 0x5b,
	0x0b, 0x71, 0xdb, 0xab, 0x5c, 0x62, 0xdb, 0xab, 0xfe, 0x87, 0x6d, 0x0f, 0x81, 0xba, 0x69, 0x59,
	0xc4, 0x77, 0x99, 0xd7, 0xaa, 0x89, 0xe2, 0x5b, 0x4e, 0xeb, 0xee, 0x4a, 0x6e, 0x3a, 0x38, 0xc5,
	0x8b, 0x0b, 0x72, 0x25, 0x04, 0x4c, 0x42, 0xab, 0x26, 0x58, 0x88, 0x7e, 0x8b, 0xbe, 0x3a, 0x43,
	0x65, 0x2b, 0x0c, 0x34, 0x23, 0xa5, 0x32, 0x4b, 0x24, 0x33, 0x9c, 0x45, 0x98, 0xfe, 0x57, 0x0d,
	0xac, 0x1c, 0x20, 0xf6, 0x90, 0x0c, 0xb0, 0x0b, 0x91, 0xe9, 0x8c, 0x62, 0x9f, 0x3d, 0x06, 0x57,
	0x2c, 0x07, 0x23, 0x97, 0xf1, 0x79, 0x49, 0x56, 0xea, 0x76, 0x18, 0x68, 0x5b, 0x5c, 0x28, 0x21,
	0x0a, 0x52, 0x65, 0x0c, 0xac, 0x4b, 0xf4, 0xd0, 0x9e, 0x4e, 0xec, 0x95, 0xe7, 0x99, 0xd8, 0x7f,
	0x98, 0x39, 0x54, 0xbf, 0x9b, 0x6f, 0x01, 0x85, 0xf7, 0x7a, 0x51, 0x53, 0x75, 0xc9, 0x10, 0x5a,
	0xbb, 0xa4, 0x21, 0xf4, 0xa5, 0x6f, 0x3b, 0x41, 0x05, 0xa8, 0xb9, 0x6f, 0x13, 0xcd, 0x6e, 0x94,
	0x3f, 0xe5, 0x67, 0x37, 0x01, 0x96, 0xe4, 0x3f, 0x8b, 0x42, 0xb9, 0x59, 0x3d, 0x00, 0xf3, 0xd8,
	0xeb, 0x79, 0x1e, 0x11, 0xe7, 0xac, 0x77, 0x6f, 0x84, 0x81, 0xb6, 0x29, 0x26, 0x04, 0x81, 0x16,
	0xc7, 0x82, 0x3c, 0x0c, 0xe7, 0xb0, 0xf7, 0xd8, 0x23, 0xd3, 0x6e, 0x58, 0xbd, 0xe8, 0x6e, 0xd8,
	0x03, 0xcd, 0x51, 0xdf, 0xec, 0xf1, 0x0a, 0xc1, 0x14, 0xc9, 0x42, 0xa8, 0x4f, 0xfb, 0x53, 0x9a,
	0x2b, 0xc4, 0x9c, 0x41, 0xc2, 0xc6, 0xa8, 0x6f, 0xc2, 0x08, 0xd7, 0xff, 0xae, 0x82, 0x35, 0x79,
	0xf7, 0xef, 0x73, 0xc3, 0x7c, 0x82, 0x28, 0xee, 0xf3, 0x21, 0x19, 0x13, 0x37, 0xb6, 0xb7, 0x0f,
	0x1a, 0x16, 0x45, 0x62, 0xe8, 0x31, 0x1d, 0x2f, 0xea, 0xf8, 0xaf, 0xa7, 0xdb, 0xcb, 0xde, 0x94,
	0xee, 0xee, 0x84, 0x81, 0xb6, 0x2d, 0x9c, 0x3f, 0x05, 0x8b, 0xde, 0x2f, 0xe5, 0x60, 0x5a, 0x47,
	0xfd, 0xb1, 0xc4, 0xba, 0x15, 0x61, 0xdd, 0xfb, 0x19, 0xeb, 0x9e, 0x7f, 0xfa, 0x57, 0xf7, 0x79,
	0xa9, 0xb1, 0xba, 0x4f, 0x7e, 0x39, 0x5b, 0x53, 0x7e, 0x3d, 0x5b, 0x53, 0xfe, 0x38, 0x5b, 0x53,
	0xc0, 0x5b, 0x98, 0x18, 0x16, 0x71, 0xfb, 0x8e, 0x8f, 0x5c, 0x66, 0xc8, 0xe4, 0x8a, 0x3f, 0xa8,
	0x1c, 0xfb, 0x7d, 0x63, 0x68, 0xf6, 0x87, 0xa6, 0xcc, 0xf5, 0xe9, 0xcd, 0x47, 0xca, 0x67, 0xdb,
	0x03, 0xcc, 0x4e, 0xfc, 0x63, 0xc3, 0x22, 0xa3, 0x4e, 0xb2, 0x09, 0xbb, 0x56, 0x47, 0x7e, 0x95,
	0xb6, 0x67, 0x0f, 0xdb, 0x03, 0xd2, 0x3e, 0xbd, 0xd9, 0x1e, 0xfb, 0xc7, 0x0e, 0xb6, 0xee, 0x48,
	0xfc, 0x78, 0x5e, 0x44, 0x7c, 0xe7, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd9, 0xfe, 0xb6, 0x43,
	0x07, 0x12, 0x00, 0x00,
}

func (m *AuthenticateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.RequestCarrier) > 0 {
		for k, _ := range m.RequestCarrier {
			dAtA[i] = 0x1a
			i++
			v := m.RequestCarrier[k]
			mapSize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			i = encodeVarintFlow(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.IdToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.IdToken)))
		i += copy(dAtA[i:], m.IdToken)
	}
	if len(m.ExternalOauthToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ExternalOauthToken)))
		i += copy(dAtA[i:], m.ExternalOauthToken)
	}
	if len(m.OrgResourceId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.OrgResourceId)))
		i += copy(dAtA[i:], m.OrgResourceId)
	}
	if len(m.IdentityPool) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.IdentityPool)))
		i += copy(dAtA[i:], m.IdentityPool)
	}
	if len(m.RefreshToken) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshToken)))
		i += copy(dAtA[i:], m.RefreshToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthenticateReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticateReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.Error.Size()))
		n1, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.User != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.User.Size()))
		n2, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Organization != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.Organization.Size()))
		n3, err := m.Organization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.RefreshToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.RefreshToken)))
		i += copy(dAtA[i:], m.RefreshToken)
	}
	if len(m.IdentityProvider) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.IdentityProvider)))
		i += copy(dAtA[i:], m.IdentityProvider)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateConnectAuthTokenReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateConnectAuthTokenReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.Error.Size()))
		n4, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateDecisionEngineAuthTokenReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDecisionEngineAuthTokenReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.Error.Size()))
		n5, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetMeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestCarrier) > 0 {
		for k, _ := range m.RequestCarrier {
			dAtA[i] = 0xa
			i++
			v := m.RequestCarrier[k]
			mapSize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			i = encodeVarintFlow(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetMeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.Error.Size()))
		n6, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.User != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.User.Size()))
		n7, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Organization != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.Organization.Size()))
		n8, err := m.Organization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Accounts) > 0 {
		for _, msg := range m.Accounts {
			dAtA[i] = 0x22
			i++
			i = encodeVarintFlow(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Account != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.Account.Size()))
		n9, err := m.Account.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetLoginRealmRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLoginRealmRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.RequestCarrier) > 0 {
		for k, _ := range m.RequestCarrier {
			dAtA[i] = 0x1a
			i++
			v := m.RequestCarrier[k]
			mapSize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			i = encodeVarintFlow(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.OrgResourceId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.OrgResourceId)))
		i += copy(dAtA[i:], m.OrgResourceId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetLoginRealmReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLoginRealmReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Realm) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Realm)))
		i += copy(dAtA[i:], m.Realm)
	}
	if m.IsSso {
		dAtA[i] = 0x10
		i++
		if m.IsSso {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Error != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.Error.Size()))
		n10, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.MfaRequired {
		dAtA[i] = 0x20
		i++
		if m.MfaRequired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateEmailVerificationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateEmailVerificationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Credentials != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlow(dAtA, i, uint64(m.Credentials.Size()))
		n11, err := m.Credentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.RequestCarrier) > 0 {
		for k, _ := range m.RequestCarrier {
			dAtA[i] = 0x12
			i++
			v := m.RequestCarrier[k]
			mapSize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			i = encodeVarintFlow(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintFlow(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintFlow(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthenticateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.RequestCarrier) > 0 {
		for k, v := range m.RequestCarrier {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	l = len(m.IdToken)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.ExternalOauthToken)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.OrgResourceId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.IdentityPool)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticateReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Organization != nil {
		l = m.Organization.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.IdentityProvider)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateConnectAuthTokenReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDecisionEngineAuthTokenReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestCarrier) > 0 {
		for k, v := range m.RequestCarrier {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMeReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Organization != nil {
		l = m.Organization.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLoginRealmRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.RequestCarrier) > 0 {
		for k, v := range m.RequestCarrier {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	l = len(m.OrgResourceId)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLoginRealmReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Realm)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.IsSso {
		n += 2
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.MfaRequired {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateEmailVerificationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.RequestCarrier) > 0 {
		for k, v := range m.RequestCarrier {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + 1 + len(v) + sovFlow(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFlow(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFlow(x uint64) (n int) {
	return sovFlow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthenticateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCarrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestCarrier == nil {
				m.RequestCarrier = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestCarrier[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalOauthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalOauthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdentityPool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticateReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticateReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticateReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Organization == nil {
				m.Organization = &Organization{}
			}
			if err := m.Organization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdentityProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateConnectAuthTokenReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateConnectAuthTokenReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateConnectAuthTokenReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDecisionEngineAuthTokenReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDecisionEngineAuthTokenReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDecisionEngineAuthTokenReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCarrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestCarrier == nil {
				m.RequestCarrier = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestCarrier[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Organization == nil {
				m.Organization = &Organization{}
			}
			if err := m.Organization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, &Account{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &Account{}
			}
			if err := m.Account.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLoginRealmRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLoginRealmRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLoginRealmRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCarrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestCarrier == nil {
				m.RequestCarrier = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestCarrier[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLoginRealmReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLoginRealmReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLoginRealmReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Realm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSso", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSso = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MfaRequired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MfaRequired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateEmailVerificationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateEmailVerificationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateEmailVerificationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &Credentials{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCarrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestCarrier == nil {
				m.RequestCarrier = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestCarrier[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlow(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlow
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthFlow
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFlow(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthFlow
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFlow = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlow   = fmt.Errorf("proto: integer overflow")
)
