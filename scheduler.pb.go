// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: scheduler/scheduler.proto

package ccloud

import (
	fmt "fmt"
	_ "github.com/confluentinc/proto-go-setter"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	_ "github.com/travisjeffery/proto-go-sql"
	io "io"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type NetworkType int32

const (
	NetworkType_UNKNOWN_TYPE    NetworkType = 0
	NetworkType_PUBLIC          NetworkType = 1
	NetworkType_PRIVATE_LINK    NetworkType = 2
	NetworkType_TRANSIT_GATEWAY NetworkType = 3
	NetworkType_VPC_PEERING     NetworkType = 4
	// INTERNAL requires that source traffic origniates from the NetworkRegion's requested CIDR.
	NetworkType_INTERNAL NetworkType = 5
)

var NetworkType_name = map[int32]string{
	0: "UNKNOWN_TYPE",
	1: "PUBLIC",
	2: "PRIVATE_LINK",
	3: "TRANSIT_GATEWAY",
	4: "VPC_PEERING",
	5: "INTERNAL",
}

var NetworkType_value = map[string]int32{
	"UNKNOWN_TYPE":    0,
	"PUBLIC":          1,
	"PRIVATE_LINK":    2,
	"TRANSIT_GATEWAY": 3,
	"VPC_PEERING":     4,
	"INTERNAL":        5,
}

func (x NetworkType) String() string {
	return proto.EnumName(NetworkType_name, int32(x))
}

func (NetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{0}
}

type GlobalSchemaRegistryLocation int32

const (
	GlobalSchemaRegistryLocation_NONE GlobalSchemaRegistryLocation = 0
	GlobalSchemaRegistryLocation_US   GlobalSchemaRegistryLocation = 1
	GlobalSchemaRegistryLocation_EU   GlobalSchemaRegistryLocation = 2
	GlobalSchemaRegistryLocation_APAC GlobalSchemaRegistryLocation = 3
)

var GlobalSchemaRegistryLocation_name = map[int32]string{
	0: "NONE",
	1: "US",
	2: "EU",
	3: "APAC",
}

var GlobalSchemaRegistryLocation_value = map[string]int32{
	"NONE": 0,
	"US":   1,
	"EU":   2,
	"APAC": 3,
}

func (x GlobalSchemaRegistryLocation) String() string {
	return proto.EnumName(GlobalSchemaRegistryLocation_name, int32(x))
}

func (GlobalSchemaRegistryLocation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{1}
}

type ClusterStatus int32

const (
	ClusterStatus_PROVISIONING      ClusterStatus = 0
	ClusterStatus_UP                ClusterStatus = 1
	ClusterStatus_DOWN              ClusterStatus = 2
	ClusterStatus_DELETING          ClusterStatus = 3
	ClusterStatus_DELETED           ClusterStatus = 4
	ClusterStatus_EXPANSION_PENDING ClusterStatus = 5
	ClusterStatus_EXPANDING         ClusterStatus = 6
	ClusterStatus_SHRINK_PENDING    ClusterStatus = 7
	ClusterStatus_SHRINKING         ClusterStatus = 8
	ClusterStatus_STORAGE_EXPANDING ClusterStatus = 9
)

var ClusterStatus_name = map[int32]string{
	0: "PROVISIONING",
	1: "UP",
	2: "DOWN",
	3: "DELETING",
	4: "DELETED",
	5: "EXPANSION_PENDING",
	6: "EXPANDING",
	7: "SHRINK_PENDING",
	8: "SHRINKING",
	9: "STORAGE_EXPANDING",
}

var ClusterStatus_value = map[string]int32{
	"PROVISIONING":      0,
	"UP":                1,
	"DOWN":              2,
	"DELETING":          3,
	"DELETED":           4,
	"EXPANSION_PENDING": 5,
	"EXPANDING":         6,
	"SHRINK_PENDING":    7,
	"SHRINKING":         8,
	"STORAGE_EXPANDING": 9,
}

func (x ClusterStatus) String() string {
	return proto.EnumName(ClusterStatus_name, int32(x))
}

func (ClusterStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{2}
}

type APICredentials struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" db:"key,omitempty" url:"key,omitempty"`
	Secret               string   `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty" redact:"-" db:"secret,omitempty" url:"secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *APICredentials) Reset()         { *m = APICredentials{} }
func (m *APICredentials) String() string { return proto.CompactTextString(m) }
func (*APICredentials) ProtoMessage()    {}
func (*APICredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{0}
}
func (m *APICredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *APICredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_APICredentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *APICredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_APICredentials.Merge(m, src)
}
func (m *APICredentials) XXX_Size() int {
	return m.Size()
}
func (m *APICredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_APICredentials.DiscardUnknown(m)
}

var xxx_messageInfo_APICredentials proto.InternalMessageInfo

func (m *APICredentials) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *APICredentials) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

type Schedulability struct {
	SharedNetwork        *Schedulability_Tenancy `protobuf:"bytes,1,opt,name=shared_network,json=sharedNetwork,proto3" json:"shared_network,omitempty" db:"shared_network,omitempty" url:"shared_network,omitempty"`
	DedicatedNetwork     *Schedulability_Tenancy `protobuf:"bytes,2,opt,name=dedicated_network,json=dedicatedNetwork,proto3" json:"dedicated_network,omitempty" db:"dedicated_network,omitempty" url:"dedicated_network,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Schedulability) Reset()         { *m = Schedulability{} }
func (m *Schedulability) String() string { return proto.CompactTextString(m) }
func (*Schedulability) ProtoMessage()    {}
func (*Schedulability) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{1}
}
func (m *Schedulability) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schedulability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schedulability.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schedulability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schedulability.Merge(m, src)
}
func (m *Schedulability) XXX_Size() int {
	return m.Size()
}
func (m *Schedulability) XXX_DiscardUnknown() {
	xxx_messageInfo_Schedulability.DiscardUnknown(m)
}

var xxx_messageInfo_Schedulability proto.InternalMessageInfo

func (m *Schedulability) GetSharedNetwork() *Schedulability_Tenancy {
	if m != nil {
		return m.SharedNetwork
	}
	return nil
}

func (m *Schedulability) GetDedicatedNetwork() *Schedulability_Tenancy {
	if m != nil {
		return m.DedicatedNetwork
	}
	return nil
}

type Schedulability_Tenancy struct {
	SharedCluster        *Schedulability_Tenancy_Durability `protobuf:"bytes,1,opt,name=shared_cluster,json=sharedCluster,proto3" json:"shared_cluster,omitempty" db:"shared_cluster,omitempty" url:"shared_cluster,omitempty"`
	DedicatedCluster     *Schedulability_Tenancy_Durability `protobuf:"bytes,2,opt,name=dedicated_cluster,json=dedicatedCluster,proto3" json:"dedicated_cluster,omitempty" db:"dedicated_cluster,omitempty" url:"dedicated_cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *Schedulability_Tenancy) Reset()         { *m = Schedulability_Tenancy{} }
func (m *Schedulability_Tenancy) String() string { return proto.CompactTextString(m) }
func (*Schedulability_Tenancy) ProtoMessage()    {}
func (*Schedulability_Tenancy) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{1, 0}
}
func (m *Schedulability_Tenancy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schedulability_Tenancy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schedulability_Tenancy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schedulability_Tenancy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schedulability_Tenancy.Merge(m, src)
}
func (m *Schedulability_Tenancy) XXX_Size() int {
	return m.Size()
}
func (m *Schedulability_Tenancy) XXX_DiscardUnknown() {
	xxx_messageInfo_Schedulability_Tenancy.DiscardUnknown(m)
}

var xxx_messageInfo_Schedulability_Tenancy proto.InternalMessageInfo

func (m *Schedulability_Tenancy) GetSharedCluster() *Schedulability_Tenancy_Durability {
	if m != nil {
		return m.SharedCluster
	}
	return nil
}

func (m *Schedulability_Tenancy) GetDedicatedCluster() *Schedulability_Tenancy_Durability {
	if m != nil {
		return m.DedicatedCluster
	}
	return nil
}

type Schedulability_Tenancy_Durability struct {
	Low                  []NetworkType `protobuf:"varint,1,rep,packed,name=low,proto3,enum=ccloud.scheduler.NetworkType" json:"LOW" db:"low,omitempty" url:"low,omitempty"`
	High                 []NetworkType `protobuf:"varint,2,rep,packed,name=high,proto3,enum=ccloud.scheduler.NetworkType" json:"HIGH" db:"high,omitempty" url:"high,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Schedulability_Tenancy_Durability) Reset()         { *m = Schedulability_Tenancy_Durability{} }
func (m *Schedulability_Tenancy_Durability) String() string { return proto.CompactTextString(m) }
func (*Schedulability_Tenancy_Durability) ProtoMessage()    {}
func (*Schedulability_Tenancy_Durability) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{1, 0, 0}
}
func (m *Schedulability_Tenancy_Durability) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schedulability_Tenancy_Durability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schedulability_Tenancy_Durability.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schedulability_Tenancy_Durability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schedulability_Tenancy_Durability.Merge(m, src)
}
func (m *Schedulability_Tenancy_Durability) XXX_Size() int {
	return m.Size()
}
func (m *Schedulability_Tenancy_Durability) XXX_DiscardUnknown() {
	xxx_messageInfo_Schedulability_Tenancy_Durability.DiscardUnknown(m)
}

var xxx_messageInfo_Schedulability_Tenancy_Durability proto.InternalMessageInfo

func (m *Schedulability_Tenancy_Durability) GetLow() []NetworkType {
	if m != nil {
		return m.Low
	}
	return nil
}

func (m *Schedulability_Tenancy_Durability) GetHigh() []NetworkType {
	if m != nil {
		return m.High
	}
	return nil
}

type AvailabilityZone struct {
	// us-west-2
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	// AWS:   zone id
	// GCP:   zone name
	// AZURE: zone name
	ZoneId string `protobuf:"bytes,3,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty" db:"zone_id,omitempty" url:"zone_id,omitempty"`
	// The internal mothership zone id
	Id                   string           `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	RegionId             string           `protobuf:"bytes,5,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty" db:"region_id,omitempty" url:"region_id,omitempty"`
	SniEnabled           *types.BoolValue `protobuf:"bytes,6,opt,name=sni_enabled,json=sniEnabled,proto3" json:"sni_enabled,omitempty" db:"sni_enabled,omitempty" url:"sni_enabled,omitempty"`
	Schedulable          *types.BoolValue `protobuf:"bytes,7,opt,name=schedulable,proto3" json:"schedulable,omitempty" db:"schedulable,omitempty" url:"schedulable,omitempty"`
	Created              *time.Time       `protobuf:"bytes,8,opt,name=created,proto3,stdtime" json:"created,omitempty" db:"created,omitempty" url:"created,omitempty"`
	Modified             *time.Time       `protobuf:"bytes,9,opt,name=modified,proto3,stdtime" json:"modified,omitempty" db:"modified,omitempty" url:"modified,omitempty"`
	Deactivated          *time.Time       `protobuf:"bytes,10,opt,name=deactivated,proto3,stdtime" json:"deactivated,omitempty" db:"deactivated,omitempty" url:"deactivated,omitempty"`
	Realm                string           `protobuf:"bytes,12,opt,name=realm,proto3" json:"realm,omitempty" db:"realm,omitempty" url:"realm,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AvailabilityZone) Reset()         { *m = AvailabilityZone{} }
func (m *AvailabilityZone) String() string { return proto.CompactTextString(m) }
func (*AvailabilityZone) ProtoMessage()    {}
func (*AvailabilityZone) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{2}
}
func (m *AvailabilityZone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AvailabilityZone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AvailabilityZone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AvailabilityZone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvailabilityZone.Merge(m, src)
}
func (m *AvailabilityZone) XXX_Size() int {
	return m.Size()
}
func (m *AvailabilityZone) XXX_DiscardUnknown() {
	xxx_messageInfo_AvailabilityZone.DiscardUnknown(m)
}

var xxx_messageInfo_AvailabilityZone proto.InternalMessageInfo

func (m *AvailabilityZone) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AvailabilityZone) GetZoneId() string {
	if m != nil {
		return m.ZoneId
	}
	return ""
}

func (m *AvailabilityZone) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AvailabilityZone) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

func (m *AvailabilityZone) GetSniEnabled() *types.BoolValue {
	if m != nil {
		return m.SniEnabled
	}
	return nil
}

func (m *AvailabilityZone) GetSchedulable() *types.BoolValue {
	if m != nil {
		return m.Schedulable
	}
	return nil
}

func (m *AvailabilityZone) GetCreated() *time.Time {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *AvailabilityZone) GetModified() *time.Time {
	if m != nil {
		return m.Modified
	}
	return nil
}

func (m *AvailabilityZone) GetDeactivated() *time.Time {
	if m != nil {
		return m.Deactivated
	}
	return nil
}

func (m *AvailabilityZone) GetRealm() string {
	if m != nil {
		return m.Realm
	}
	return ""
}

type Region struct {
	Id    string              `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	Cloud string              `protobuf:"bytes,2,opt,name=cloud,proto3" json:"cloud,omitempty" db:"cloud,omitempty" url:"cloud,omitempty"`
	Zones []*AvailabilityZone `protobuf:"bytes,3,rep,name=zones,proto3" json:"zones,omitempty" db:"zones,omitempty" url:"zones,omitempty"`
	Name  string              `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	// This field will be calcuated at runtime. Default to false
	// e.g. when there is available physical cluster for logical cluster provision, it will be set to true
	IsSchedulable bool `protobuf:"varint,5,opt,name=is_schedulable,json=isSchedulable,proto3" json:"is_schedulable,omitempty" db:"is_schedulable,omitempty" url:"is_schedulable,omitempty"`
	// This field will be calcuated at runtime. Default to false
	// e.g. when there is available physical cluster for logical cluster provision, and its Durability==High, it will be set to true
	IsMultizoneEnabled bool           `protobuf:"varint,6,opt,name=is_multizone_enabled,json=isMultizoneEnabled,proto3" json:"is_multizone_enabled,omitempty" db:"is_multizone_enabled,omitempty" url:"is_multizone_enabled,omitempty"`
	Config             *Region_Config `protobuf:"bytes,7,opt,name=config,proto3" json:"config,omitempty" db:"config,omitempty" url:"config,omitempty"`
	// This is a vanity field. This means that it is not persisted to the DB
	// but computed at runtime.
	Schedulability       *Schedulability `protobuf:"bytes,8,opt,name=schedulability,proto3" json:"schedulability,omitempty" db:"schedulability,omitempty" url:"schedulability,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Region) Reset()         { *m = Region{} }
func (m *Region) String() string { return proto.CompactTextString(m) }
func (*Region) ProtoMessage()    {}
func (*Region) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{3}
}
func (m *Region) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Region) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Region.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Region) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Region.Merge(m, src)
}
func (m *Region) XXX_Size() int {
	return m.Size()
}
func (m *Region) XXX_DiscardUnknown() {
	xxx_messageInfo_Region.DiscardUnknown(m)
}

var xxx_messageInfo_Region proto.InternalMessageInfo

func (m *Region) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Region) GetCloud() string {
	if m != nil {
		return m.Cloud
	}
	return ""
}

func (m *Region) GetZones() []*AvailabilityZone {
	if m != nil {
		return m.Zones
	}
	return nil
}

func (m *Region) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Region) GetIsSchedulable() bool {
	if m != nil {
		return m.IsSchedulable
	}
	return false
}

func (m *Region) GetIsMultizoneEnabled() bool {
	if m != nil {
		return m.IsMultizoneEnabled
	}
	return false
}

func (m *Region) GetConfig() *Region_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Region) GetSchedulability() *Schedulability {
	if m != nil {
		return m.Schedulability
	}
	return nil
}

type Region_Docker struct {
	Repo                 string   `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty" db:"repo,omitempty" url:"repo,omitempty"`
	ImagePrefix          string   `protobuf:"bytes,2,opt,name=image_prefix,json=imagePrefix,proto3" json:"image_prefix,omitempty" db:"image_prefix,omitempty" url:"image_prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Region_Docker) Reset()         { *m = Region_Docker{} }
func (m *Region_Docker) String() string { return proto.CompactTextString(m) }
func (*Region_Docker) ProtoMessage()    {}
func (*Region_Docker) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{3, 0}
}
func (m *Region_Docker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Region_Docker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Region_Docker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Region_Docker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Region_Docker.Merge(m, src)
}
func (m *Region_Docker) XXX_Size() int {
	return m.Size()
}
func (m *Region_Docker) XXX_DiscardUnknown() {
	xxx_messageInfo_Region_Docker.DiscardUnknown(m)
}

var xxx_messageInfo_Region_Docker proto.InternalMessageInfo

func (m *Region_Docker) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *Region_Docker) GetImagePrefix() string {
	if m != nil {
		return m.ImagePrefix
	}
	return ""
}

type Region_Config struct {
	Docker               *Region_Docker `protobuf:"bytes,1,opt,name=docker,proto3" json:"docker,omitempty" db:"docker,omitempty" url:"docker,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Region_Config) Reset()         { *m = Region_Config{} }
func (m *Region_Config) String() string { return proto.CompactTextString(m) }
func (*Region_Config) ProtoMessage()    {}
func (*Region_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{3, 1}
}
func (m *Region_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Region_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Region_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Region_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Region_Config.Merge(m, src)
}
func (m *Region_Config) XXX_Size() int {
	return m.Size()
}
func (m *Region_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Region_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Region_Config proto.InternalMessageInfo

func (m *Region_Config) GetDocker() *Region_Docker {
	if m != nil {
		return m.Docker
	}
	return nil
}

type AccountMetadata struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccountMetadata) Reset()         { *m = AccountMetadata{} }
func (m *AccountMetadata) String() string { return proto.CompactTextString(m) }
func (*AccountMetadata) ProtoMessage()    {}
func (*AccountMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{4}
}
func (m *AccountMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountMetadata.Merge(m, src)
}
func (m *AccountMetadata) XXX_Size() int {
	return m.Size()
}
func (m *AccountMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_AccountMetadata proto.InternalMessageInfo

func (m *AccountMetadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type CloudMetadata struct {
	Id                   string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	Regions              []*Region          `protobuf:"bytes,2,rep,name=regions,proto3" json:"regions,omitempty" db:"regions,omitempty" url:"regions,omitempty"`
	Name                 string             `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	Accounts             []*AccountMetadata `protobuf:"bytes,4,rep,name=accounts,proto3" json:"accounts,omitempty" db:"accounts,omitempty" url:"accounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CloudMetadata) Reset()         { *m = CloudMetadata{} }
func (m *CloudMetadata) String() string { return proto.CompactTextString(m) }
func (*CloudMetadata) ProtoMessage()    {}
func (*CloudMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{5}
}
func (m *CloudMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudMetadata.Merge(m, src)
}
func (m *CloudMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CloudMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CloudMetadata proto.InternalMessageInfo

func (m *CloudMetadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CloudMetadata) GetRegions() []*Region {
	if m != nil {
		return m.Regions
	}
	return nil
}

func (m *CloudMetadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CloudMetadata) GetAccounts() []*AccountMetadata {
	if m != nil {
		return m.Accounts
	}
	return nil
}

type SchemaRegistryLocation struct {
	Id                    GlobalSchemaRegistryLocation `protobuf:"varint,1,opt,name=id,proto3,enum=ccloud.scheduler.GlobalSchemaRegistryLocation" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"` // Deprecated: Do not use.
	Name                  string                       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`                                             // Deprecated: Do not use.
	ClusterId             string                       `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty" db:"cluster_id,omitempty" url:"cluster_id,omitempty"`
	ServiceProvider       string                       `protobuf:"bytes,4,opt,name=service_provider,json=serviceProvider,proto3" json:"service_provider,omitempty" db:"service_provider,omitempty" url:"service_provider,omitempty"`
	Package               []string                     `protobuf:"bytes,5,rep,name=package,proto3" json:"package,omitempty" db:"package,omitempty" url:"package,omitempty"`
	ServiceProviderRegion string                       `protobuf:"bytes,6,opt,name=service_provider_region,json=serviceProviderRegion,proto3" json:"service_provider_region,omitempty" db:"service_provider_region,omitempty" url:"service_provider_region,omitempty"`
	RegionDisplayName     string                       `protobuf:"bytes,7,opt,name=region_display_name,json=regionDisplayName,proto3" json:"region_display_name,omitempty" db:"region_display_name,omitempty" url:"region_display_name,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                     `json:"-"`
	XXX_unrecognized      []byte                       `json:"-"`
	XXX_sizecache         int32                        `json:"-"`
}

func (m *SchemaRegistryLocation) Reset()         { *m = SchemaRegistryLocation{} }
func (m *SchemaRegistryLocation) String() string { return proto.CompactTextString(m) }
func (*SchemaRegistryLocation) ProtoMessage()    {}
func (*SchemaRegistryLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{6}
}
func (m *SchemaRegistryLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaRegistryLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaRegistryLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaRegistryLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaRegistryLocation.Merge(m, src)
}
func (m *SchemaRegistryLocation) XXX_Size() int {
	return m.Size()
}
func (m *SchemaRegistryLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaRegistryLocation.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaRegistryLocation proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *SchemaRegistryLocation) GetId() GlobalSchemaRegistryLocation {
	if m != nil {
		return m.Id
	}
	return GlobalSchemaRegistryLocation_NONE
}

// Deprecated: Do not use.
func (m *SchemaRegistryLocation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaRegistryLocation) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *SchemaRegistryLocation) GetServiceProvider() string {
	if m != nil {
		return m.ServiceProvider
	}
	return ""
}

func (m *SchemaRegistryLocation) GetPackage() []string {
	if m != nil {
		return m.Package
	}
	return nil
}

func (m *SchemaRegistryLocation) GetServiceProviderRegion() string {
	if m != nil {
		return m.ServiceProviderRegion
	}
	return ""
}

func (m *SchemaRegistryLocation) GetRegionDisplayName() string {
	if m != nil {
		return m.RegionDisplayName
	}
	return ""
}

type EnvironmentStatus struct {
	Info                 string   `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty" db:"info,omitempty" url:"info,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvironmentStatus) Reset()         { *m = EnvironmentStatus{} }
func (m *EnvironmentStatus) String() string { return proto.CompactTextString(m) }
func (*EnvironmentStatus) ProtoMessage()    {}
func (*EnvironmentStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{7}
}
func (m *EnvironmentStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvironmentStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvironmentStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvironmentStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvironmentStatus.Merge(m, src)
}
func (m *EnvironmentStatus) XXX_Size() int {
	return m.Size()
}
func (m *EnvironmentStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvironmentStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EnvironmentStatus proto.InternalMessageInfo

func (m *EnvironmentStatus) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *EnvironmentStatus) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type GetEnvironmentMetadataReply struct {
	Error                   *Error                    `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	Clouds                  []*CloudMetadata          `protobuf:"bytes,2,rep,name=clouds,proto3" json:"clouds,omitempty" db:"clouds,omitempty" url:"clouds,omitempty"`
	Status                  *EnvironmentStatus        `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty" db:"status,omitempty" url:"status,omitempty"`
	SchemaRegistryLocations []*SchemaRegistryLocation `protobuf:"bytes,4,rep,name=schema_registry_locations,json=schemaRegistryLocations,proto3" json:"schema_registry_locations,omitempty" db:"schema_registry_locations,omitempty" url:"schema_registry_locations,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                  `json:"-"`
	XXX_unrecognized        []byte                    `json:"-"`
	XXX_sizecache           int32                     `json:"-"`
}

func (m *GetEnvironmentMetadataReply) Reset()         { *m = GetEnvironmentMetadataReply{} }
func (m *GetEnvironmentMetadataReply) String() string { return proto.CompactTextString(m) }
func (*GetEnvironmentMetadataReply) ProtoMessage()    {}
func (*GetEnvironmentMetadataReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{8}
}
func (m *GetEnvironmentMetadataReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEnvironmentMetadataReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEnvironmentMetadataReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEnvironmentMetadataReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEnvironmentMetadataReply.Merge(m, src)
}
func (m *GetEnvironmentMetadataReply) XXX_Size() int {
	return m.Size()
}
func (m *GetEnvironmentMetadataReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEnvironmentMetadataReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetEnvironmentMetadataReply proto.InternalMessageInfo

func (m *GetEnvironmentMetadataReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetEnvironmentMetadataReply) GetClouds() []*CloudMetadata {
	if m != nil {
		return m.Clouds
	}
	return nil
}

func (m *GetEnvironmentMetadataReply) GetStatus() *EnvironmentStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *GetEnvironmentMetadataReply) GetSchemaRegistryLocations() []*SchemaRegistryLocation {
	if m != nil {
		return m.SchemaRegistryLocations
	}
	return nil
}

type CreateSchemaRegistryClusterRequest struct {
	Config               *SchemaRegistryClusterConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty" db:"config,omitempty" url:"config,omitempty"`
	RequestCarrier       map[string]string            `protobuf:"bytes,2,rep,name=request_carrier,json=requestCarrier,proto3" json:"request_carrier,omitempty" redact:"-" db:"request_carrier,omitempty" url:"request_carrier,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Cluster              *SchemaRegistryCluster       `protobuf:"bytes,4,opt,name=cluster,proto3" json:"cluster,omitempty" db:"cluster,omitempty" url:"cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *CreateSchemaRegistryClusterRequest) Reset()         { *m = CreateSchemaRegistryClusterRequest{} }
func (m *CreateSchemaRegistryClusterRequest) String() string { return proto.CompactTextString(m) }
func (*CreateSchemaRegistryClusterRequest) ProtoMessage()    {}
func (*CreateSchemaRegistryClusterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{9}
}
func (m *CreateSchemaRegistryClusterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSchemaRegistryClusterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSchemaRegistryClusterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSchemaRegistryClusterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSchemaRegistryClusterRequest.Merge(m, src)
}
func (m *CreateSchemaRegistryClusterRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateSchemaRegistryClusterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSchemaRegistryClusterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSchemaRegistryClusterRequest proto.InternalMessageInfo

func (m *CreateSchemaRegistryClusterRequest) GetConfig() *SchemaRegistryClusterConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *CreateSchemaRegistryClusterRequest) GetRequestCarrier() map[string]string {
	if m != nil {
		return m.RequestCarrier
	}
	return nil
}

func (m *CreateSchemaRegistryClusterRequest) GetCluster() *SchemaRegistryCluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

type CreateSchemaRegistryClusterReply struct {
	Error *Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	// {"field name": "err msg"}
	ValidationErrors     map[string]string      `protobuf:"bytes,2,rep,name=validation_errors,json=validationErrors,proto3" json:"validation_errors,omitempty" db:"validation_errors,omitempty" url:"validation_errors,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Cluster              *SchemaRegistryCluster `protobuf:"bytes,3,opt,name=cluster,proto3" json:"cluster,omitempty" db:"cluster,omitempty" url:"cluster,omitempty"`
	Credentials          *APICredentials        `protobuf:"bytes,4,opt,name=credentials,proto3" json:"credentials,omitempty" db:"credentials,omitempty" url:"credentials,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CreateSchemaRegistryClusterReply) Reset()         { *m = CreateSchemaRegistryClusterReply{} }
func (m *CreateSchemaRegistryClusterReply) String() string { return proto.CompactTextString(m) }
func (*CreateSchemaRegistryClusterReply) ProtoMessage()    {}
func (*CreateSchemaRegistryClusterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{10}
}
func (m *CreateSchemaRegistryClusterReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSchemaRegistryClusterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSchemaRegistryClusterReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSchemaRegistryClusterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSchemaRegistryClusterReply.Merge(m, src)
}
func (m *CreateSchemaRegistryClusterReply) XXX_Size() int {
	return m.Size()
}
func (m *CreateSchemaRegistryClusterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSchemaRegistryClusterReply.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSchemaRegistryClusterReply proto.InternalMessageInfo

func (m *CreateSchemaRegistryClusterReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CreateSchemaRegistryClusterReply) GetValidationErrors() map[string]string {
	if m != nil {
		return m.ValidationErrors
	}
	return nil
}

func (m *CreateSchemaRegistryClusterReply) GetCluster() *SchemaRegistryCluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *CreateSchemaRegistryClusterReply) GetCredentials() *APICredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type GetSchemaRegistryClustersReply struct {
	Error                *Error                   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	Clusters             []*SchemaRegistryCluster `protobuf:"bytes,2,rep,name=clusters,proto3" json:"clusters,omitempty" db:"clusters,omitempty" url:"clusters,omitempty"`
	NextPageToken        string                   `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty" db:"next_page_token,omitempty" url:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetSchemaRegistryClustersReply) Reset()         { *m = GetSchemaRegistryClustersReply{} }
func (m *GetSchemaRegistryClustersReply) String() string { return proto.CompactTextString(m) }
func (*GetSchemaRegistryClustersReply) ProtoMessage()    {}
func (*GetSchemaRegistryClustersReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{11}
}
func (m *GetSchemaRegistryClustersReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSchemaRegistryClustersReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSchemaRegistryClustersReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSchemaRegistryClustersReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSchemaRegistryClustersReply.Merge(m, src)
}
func (m *GetSchemaRegistryClustersReply) XXX_Size() int {
	return m.Size()
}
func (m *GetSchemaRegistryClustersReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSchemaRegistryClustersReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetSchemaRegistryClustersReply proto.InternalMessageInfo

func (m *GetSchemaRegistryClustersReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetSchemaRegistryClustersReply) GetClusters() []*SchemaRegistryCluster {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *GetSchemaRegistryClustersReply) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type GetSchemaRegistryClusterReply struct {
	Error                *Error                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	Cluster              *SchemaRegistryCluster `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty" db:"cluster,omitempty" url:"cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *GetSchemaRegistryClusterReply) Reset()         { *m = GetSchemaRegistryClusterReply{} }
func (m *GetSchemaRegistryClusterReply) String() string { return proto.CompactTextString(m) }
func (*GetSchemaRegistryClusterReply) ProtoMessage()    {}
func (*GetSchemaRegistryClusterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{12}
}
func (m *GetSchemaRegistryClusterReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSchemaRegistryClusterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSchemaRegistryClusterReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSchemaRegistryClusterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSchemaRegistryClusterReply.Merge(m, src)
}
func (m *GetSchemaRegistryClusterReply) XXX_Size() int {
	return m.Size()
}
func (m *GetSchemaRegistryClusterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSchemaRegistryClusterReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetSchemaRegistryClusterReply proto.InternalMessageInfo

func (m *GetSchemaRegistryClusterReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetSchemaRegistryClusterReply) GetCluster() *SchemaRegistryCluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

type UpdateSchemaRegistryClusterRequest struct {
	Cluster              *SchemaRegistryCluster `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty" db:"cluster,omitempty" url:"cluster,omitempty"`
	RequestCarrier       map[string]string      `protobuf:"bytes,2,rep,name=request_carrier,json=requestCarrier,proto3" json:"request_carrier,omitempty" redact:"-" db:"request_carrier,omitempty" url:"request_carrier,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpdateSchemaRegistryClusterRequest) Reset()         { *m = UpdateSchemaRegistryClusterRequest{} }
func (m *UpdateSchemaRegistryClusterRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateSchemaRegistryClusterRequest) ProtoMessage()    {}
func (*UpdateSchemaRegistryClusterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{13}
}
func (m *UpdateSchemaRegistryClusterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSchemaRegistryClusterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSchemaRegistryClusterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSchemaRegistryClusterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSchemaRegistryClusterRequest.Merge(m, src)
}
func (m *UpdateSchemaRegistryClusterRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSchemaRegistryClusterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSchemaRegistryClusterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSchemaRegistryClusterRequest proto.InternalMessageInfo

func (m *UpdateSchemaRegistryClusterRequest) GetCluster() *SchemaRegistryCluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *UpdateSchemaRegistryClusterRequest) GetRequestCarrier() map[string]string {
	if m != nil {
		return m.RequestCarrier
	}
	return nil
}

type UpdateSchemaRegistryClusterReply struct {
	Error                *Error                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	ValidationErrors     map[string]string      `protobuf:"bytes,2,rep,name=validation_errors,json=validationErrors,proto3" json:"validation_errors,omitempty" db:"validation_errors,omitempty" url:"validation_errors,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Cluster              *SchemaRegistryCluster `protobuf:"bytes,3,opt,name=cluster,proto3" json:"cluster,omitempty" db:"cluster,omitempty" url:"cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpdateSchemaRegistryClusterReply) Reset()         { *m = UpdateSchemaRegistryClusterReply{} }
func (m *UpdateSchemaRegistryClusterReply) String() string { return proto.CompactTextString(m) }
func (*UpdateSchemaRegistryClusterReply) ProtoMessage()    {}
func (*UpdateSchemaRegistryClusterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{14}
}
func (m *UpdateSchemaRegistryClusterReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSchemaRegistryClusterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSchemaRegistryClusterReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSchemaRegistryClusterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSchemaRegistryClusterReply.Merge(m, src)
}
func (m *UpdateSchemaRegistryClusterReply) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSchemaRegistryClusterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSchemaRegistryClusterReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSchemaRegistryClusterReply proto.InternalMessageInfo

func (m *UpdateSchemaRegistryClusterReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *UpdateSchemaRegistryClusterReply) GetValidationErrors() map[string]string {
	if m != nil {
		return m.ValidationErrors
	}
	return nil
}

func (m *UpdateSchemaRegistryClusterReply) GetCluster() *SchemaRegistryCluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

type DeleteSchemaValidationResourcesRequest struct {
	LogicalClusterId     string   `protobuf:"bytes,1,opt,name=logical_cluster_id,json=logicalClusterId,proto3" json:"logical_cluster_id,omitempty" db:"logical_cluster_id,omitempty" url:"logical_cluster_id,omitempty"`
	OrganizationId       int32    `protobuf:"varint,2,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty" db:"organization_id,omitempty" url:"organization_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteSchemaValidationResourcesRequest) Reset() {
	*m = DeleteSchemaValidationResourcesRequest{}
}
func (m *DeleteSchemaValidationResourcesRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteSchemaValidationResourcesRequest) ProtoMessage()    {}
func (*DeleteSchemaValidationResourcesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{15}
}
func (m *DeleteSchemaValidationResourcesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteSchemaValidationResourcesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteSchemaValidationResourcesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteSchemaValidationResourcesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSchemaValidationResourcesRequest.Merge(m, src)
}
func (m *DeleteSchemaValidationResourcesRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteSchemaValidationResourcesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSchemaValidationResourcesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSchemaValidationResourcesRequest proto.InternalMessageInfo

func (m *DeleteSchemaValidationResourcesRequest) GetLogicalClusterId() string {
	if m != nil {
		return m.LogicalClusterId
	}
	return ""
}

func (m *DeleteSchemaValidationResourcesRequest) GetOrganizationId() int32 {
	if m != nil {
		return m.OrganizationId
	}
	return 0
}

type DeleteSchemaValidationResourcesReply struct {
	Error                *Error   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty" db:"error,omitempty" url:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteSchemaValidationResourcesReply) Reset()         { *m = DeleteSchemaValidationResourcesReply{} }
func (m *DeleteSchemaValidationResourcesReply) String() string { return proto.CompactTextString(m) }
func (*DeleteSchemaValidationResourcesReply) ProtoMessage()    {}
func (*DeleteSchemaValidationResourcesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{16}
}
func (m *DeleteSchemaValidationResourcesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteSchemaValidationResourcesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteSchemaValidationResourcesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteSchemaValidationResourcesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSchemaValidationResourcesReply.Merge(m, src)
}
func (m *DeleteSchemaValidationResourcesReply) XXX_Size() int {
	return m.Size()
}
func (m *DeleteSchemaValidationResourcesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSchemaValidationResourcesReply.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSchemaValidationResourcesReply proto.InternalMessageInfo

func (m *DeleteSchemaValidationResourcesReply) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type SchemaRegistryClusterConfig struct {
	Name                  string                       `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"` // Deprecated: Do not use.
	KafkaClusterId        string                       `protobuf:"bytes,1,opt,name=kafka_cluster_id,json=kafkaClusterId,proto3" json:"kafka_cluster_id,omitempty" db:"kafka_cluster_id,omitempty" url:"kafka_cluster_id,omitempty"`
	Servers               int32                        `protobuf:"varint,2,opt,name=servers,proto3" json:"servers,omitempty" db:"servers,omitempty" url:"servers,omitempty"`
	AccountId             string                       `protobuf:"bytes,3,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty" db:"account_id,omitempty" url:"account_id,omitempty"`
	Location              GlobalSchemaRegistryLocation `protobuf:"varint,5,opt,name=location,proto3,enum=ccloud.scheduler.GlobalSchemaRegistryLocation" json:"location,omitempty" db:"location,omitempty" url:"location,omitempty"` // Deprecated: Do not use.
	ServiceProvider       string                       `protobuf:"bytes,6,opt,name=service_provider,json=serviceProvider,proto3" json:"service_provider,omitempty" db:"service_provider,omitempty" url:"service_provider,omitempty"`
	PhysicalClusterId     string                       `protobuf:"bytes,7,opt,name=physical_cluster_id,json=physicalClusterId,proto3" json:"physical_cluster_id,omitempty" db:"physical_cluster_id,omitempty" url:"physical_cluster_id,omitempty"`
	Package               string                       `protobuf:"bytes,8,opt,name=package,proto3" json:"package,omitempty" db:"package,omitempty" url:"package,omitempty"`
	ServiceProviderRegion string                       `protobuf:"bytes,9,opt,name=service_provider_region,json=serviceProviderRegion,proto3" json:"service_provider_region,omitempty" db:"service_provider_region,omitempty" url:"service_provider_region,omitempty"`
	Region                *StreamGovernanceRegion      `protobuf:"bytes,10,opt,name=region,proto3" json:"region,omitempty" db:"region,omitempty" url:"region,omitempty"`
	Dedicated             bool                         `protobuf:"varint,11,opt,name=dedicated,proto3" json:"dedicated,omitempty" db:"dedicated,omitempty" url:"dedicated,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                     `json:"-"`
	XXX_unrecognized      []byte                       `json:"-"`
	XXX_sizecache         int32                        `json:"-"`
}

func (m *SchemaRegistryClusterConfig) Reset()         { *m = SchemaRegistryClusterConfig{} }
func (m *SchemaRegistryClusterConfig) String() string { return proto.CompactTextString(m) }
func (*SchemaRegistryClusterConfig) ProtoMessage()    {}
func (*SchemaRegistryClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{17}
}
func (m *SchemaRegistryClusterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaRegistryClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaRegistryClusterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaRegistryClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaRegistryClusterConfig.Merge(m, src)
}
func (m *SchemaRegistryClusterConfig) XXX_Size() int {
	return m.Size()
}
func (m *SchemaRegistryClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaRegistryClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaRegistryClusterConfig proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *SchemaRegistryClusterConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaRegistryClusterConfig) GetKafkaClusterId() string {
	if m != nil {
		return m.KafkaClusterId
	}
	return ""
}

func (m *SchemaRegistryClusterConfig) GetServers() int32 {
	if m != nil {
		return m.Servers
	}
	return 0
}

func (m *SchemaRegistryClusterConfig) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

// Deprecated: Do not use.
func (m *SchemaRegistryClusterConfig) GetLocation() GlobalSchemaRegistryLocation {
	if m != nil {
		return m.Location
	}
	return GlobalSchemaRegistryLocation_NONE
}

func (m *SchemaRegistryClusterConfig) GetServiceProvider() string {
	if m != nil {
		return m.ServiceProvider
	}
	return ""
}

func (m *SchemaRegistryClusterConfig) GetPhysicalClusterId() string {
	if m != nil {
		return m.PhysicalClusterId
	}
	return ""
}

func (m *SchemaRegistryClusterConfig) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *SchemaRegistryClusterConfig) GetServiceProviderRegion() string {
	if m != nil {
		return m.ServiceProviderRegion
	}
	return ""
}

func (m *SchemaRegistryClusterConfig) GetRegion() *StreamGovernanceRegion {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *SchemaRegistryClusterConfig) GetDedicated() bool {
	if m != nil {
		return m.Dedicated
	}
	return false
}

type SchemaRegistryCluster struct {
	Id                string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" db:"id,omitempty" url:"id,omitempty"`
	Name              string           `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty" db:"name,omitempty" url:"name,omitempty"`
	KafkaClusterId    string           `protobuf:"bytes,2,opt,name=kafka_cluster_id,json=kafkaClusterId,proto3" json:"kafka_cluster_id,omitempty" db:"kafka_cluster_id,omitempty" url:"kafka_cluster_id,omitempty"`
	Endpoint          string           `protobuf:"bytes,3,opt,name=endpoint,proto3" json:"endpoint,omitempty" db:"endpoint,omitempty" url:"endpoint,omitempty"`
	Created           *types.Timestamp `protobuf:"bytes,4,opt,name=created,proto3" json:"created,omitempty" db:"created,omitempty" url:"created,omitempty"`
	Modified          *types.Timestamp `protobuf:"bytes,5,opt,name=modified,proto3" json:"modified,omitempty" db:"modified,omitempty" url:"modified,omitempty"`
	Status            ClusterStatus    `protobuf:"varint,6,opt,name=status,proto3,enum=ccloud.scheduler.ClusterStatus" json:"status,omitempty" db:"status,omitempty" url:"status,omitempty"`
	PhysicalClusterId string           `protobuf:"bytes,7,opt,name=physical_cluster_id,json=physicalClusterId,proto3" json:"physical_cluster_id,omitempty" db:"physical_cluster_id,omitempty" url:"physical_cluster_id,omitempty"`
	AccountId         string           `protobuf:"bytes,8,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty" url:"account_id" db:"account_id,omitempty"`
	OrganizationId    int32            `protobuf:"varint,9,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty" db:"organization_id,omitempty" url:"organization_id,omitempty"`
	// maximum number of schemas allowed for this logical cluster
	MaxSchemas            int32                   `protobuf:"varint,11,opt,name=max_schemas,json=maxSchemas,proto3" json:"max_schemas,omitempty" db:"max_schemas,omitempty" url:"max_schemas,omitempty"`
	OrgResourceId         string                  `protobuf:"bytes,12,opt,name=org_resource_id,json=orgResourceId,proto3" json:"org_resource_id,omitempty" db:"org_resource_id,omitempty" url:"org_resource_id,omitempty"`
	Package               string                  `protobuf:"bytes,13,opt,name=package,proto3" json:"package,omitempty" db:"package,omitempty" url:"package,omitempty"`
	ServiceProvider       string                  `protobuf:"bytes,17,opt,name=service_provider,json=serviceProvider,proto3" json:"service_provider,omitempty" db:"service_provider,omitempty" url:"service_provider,omitempty"`
	ServiceProviderRegion string                  `protobuf:"bytes,18,opt,name=service_provider_region,json=serviceProviderRegion,proto3" json:"service_provider_region,omitempty" db:"service_provider_region,omitempty" url:"service_provider_region,omitempty"`
	Region                *StreamGovernanceRegion `protobuf:"bytes,19,opt,name=region,proto3" json:"region,omitempty" db:"region,omitempty" url:"region,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                `json:"-"`
	XXX_unrecognized      []byte                  `json:"-"`
	XXX_sizecache         int32                   `json:"-"`
}

func (m *SchemaRegistryCluster) Reset()         { *m = SchemaRegistryCluster{} }
func (m *SchemaRegistryCluster) String() string { return proto.CompactTextString(m) }
func (*SchemaRegistryCluster) ProtoMessage()    {}
func (*SchemaRegistryCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d8db78ba60fec18, []int{18}
}
func (m *SchemaRegistryCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaRegistryCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaRegistryCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaRegistryCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaRegistryCluster.Merge(m, src)
}
func (m *SchemaRegistryCluster) XXX_Size() int {
	return m.Size()
}
func (m *SchemaRegistryCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaRegistryCluster.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaRegistryCluster proto.InternalMessageInfo

func (m *SchemaRegistryCluster) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SchemaRegistryCluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaRegistryCluster) GetKafkaClusterId() string {
	if m != nil {
		return m.KafkaClusterId
	}
	return ""
}

func (m *SchemaRegistryCluster) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *SchemaRegistryCluster) GetCreated() *types.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *SchemaRegistryCluster) GetModified() *types.Timestamp {
	if m != nil {
		return m.Modified
	}
	return nil
}

func (m *SchemaRegistryCluster) GetStatus() ClusterStatus {
	if m != nil {
		return m.Status
	}
	return ClusterStatus_PROVISIONING
}

func (m *SchemaRegistryCluster) GetPhysicalClusterId() string {
	if m != nil {
		return m.PhysicalClusterId
	}
	return ""
}

func (m *SchemaRegistryCluster) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *SchemaRegistryCluster) GetOrganizationId() int32 {
	if m != nil {
		return m.OrganizationId
	}
	return 0
}

func (m *SchemaRegistryCluster) GetMaxSchemas() int32 {
	if m != nil {
		return m.MaxSchemas
	}
	return 0
}

func (m *SchemaRegistryCluster) GetOrgResourceId() string {
	if m != nil {
		return m.OrgResourceId
	}
	return ""
}

func (m *SchemaRegistryCluster) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *SchemaRegistryCluster) GetServiceProvider() string {
	if m != nil {
		return m.ServiceProvider
	}
	return ""
}

func (m *SchemaRegistryCluster) GetServiceProviderRegion() string {
	if m != nil {
		return m.ServiceProviderRegion
	}
	return ""
}

func (m *SchemaRegistryCluster) GetRegion() *StreamGovernanceRegion {
	if m != nil {
		return m.Region
	}
	return nil
}

func init() {
	proto.RegisterEnum("ccloud.scheduler.NetworkType", NetworkType_name, NetworkType_value)
	proto.RegisterEnum("ccloud.scheduler.GlobalSchemaRegistryLocation", GlobalSchemaRegistryLocation_name, GlobalSchemaRegistryLocation_value)
	proto.RegisterEnum("ccloud.scheduler.ClusterStatus", ClusterStatus_name, ClusterStatus_value)
	proto.RegisterType((*APICredentials)(nil), "ccloud.scheduler.APICredentials")
	proto.RegisterType((*Schedulability)(nil), "ccloud.scheduler.Schedulability")
	proto.RegisterType((*Schedulability_Tenancy)(nil), "ccloud.scheduler.Schedulability.Tenancy")
	proto.RegisterType((*Schedulability_Tenancy_Durability)(nil), "ccloud.scheduler.Schedulability.Tenancy.Durability")
	proto.RegisterType((*AvailabilityZone)(nil), "ccloud.scheduler.AvailabilityZone")
	proto.RegisterType((*Region)(nil), "ccloud.scheduler.Region")
	proto.RegisterType((*Region_Docker)(nil), "ccloud.scheduler.Region.Docker")
	proto.RegisterType((*Region_Config)(nil), "ccloud.scheduler.Region.Config")
	proto.RegisterType((*AccountMetadata)(nil), "ccloud.scheduler.AccountMetadata")
	proto.RegisterType((*CloudMetadata)(nil), "ccloud.scheduler.CloudMetadata")
	proto.RegisterType((*SchemaRegistryLocation)(nil), "ccloud.scheduler.SchemaRegistryLocation")
	proto.RegisterType((*EnvironmentStatus)(nil), "ccloud.scheduler.EnvironmentStatus")
	proto.RegisterType((*GetEnvironmentMetadataReply)(nil), "ccloud.scheduler.GetEnvironmentMetadataReply")
	proto.RegisterType((*CreateSchemaRegistryClusterRequest)(nil), "ccloud.scheduler.CreateSchemaRegistryClusterRequest")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.scheduler.CreateSchemaRegistryClusterRequest.RequestCarrierEntry")
	proto.RegisterType((*CreateSchemaRegistryClusterReply)(nil), "ccloud.scheduler.CreateSchemaRegistryClusterReply")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.scheduler.CreateSchemaRegistryClusterReply.ValidationErrorsEntry")
	proto.RegisterType((*GetSchemaRegistryClustersReply)(nil), "ccloud.scheduler.GetSchemaRegistryClustersReply")
	proto.RegisterType((*GetSchemaRegistryClusterReply)(nil), "ccloud.scheduler.GetSchemaRegistryClusterReply")
	proto.RegisterType((*UpdateSchemaRegistryClusterRequest)(nil), "ccloud.scheduler.UpdateSchemaRegistryClusterRequest")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.scheduler.UpdateSchemaRegistryClusterRequest.RequestCarrierEntry")
	proto.RegisterType((*UpdateSchemaRegistryClusterReply)(nil), "ccloud.scheduler.UpdateSchemaRegistryClusterReply")
	proto.RegisterMapType((map[string]string)(nil), "ccloud.scheduler.UpdateSchemaRegistryClusterReply.ValidationErrorsEntry")
	proto.RegisterType((*DeleteSchemaValidationResourcesRequest)(nil), "ccloud.scheduler.DeleteSchemaValidationResourcesRequest")
	proto.RegisterType((*DeleteSchemaValidationResourcesReply)(nil), "ccloud.scheduler.DeleteSchemaValidationResourcesReply")
	proto.RegisterType((*SchemaRegistryClusterConfig)(nil), "ccloud.scheduler.SchemaRegistryClusterConfig")
	proto.RegisterType((*SchemaRegistryCluster)(nil), "ccloud.scheduler.SchemaRegistryCluster")
}

func init() { proto.RegisterFile("scheduler/scheduler.proto", fileDescriptor_3d8db78ba60fec18) }

var fileDescriptor_3d8db78ba60fec18 = []byte{
	// 2834 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x5a, 0x4d, 0x6c, 0xe3, 0xc6,
	0x15, 0x2e, 0xf5, 0x67, 0x69, 0xe4, 0x1f, 0x7a, 0x36, 0xdb, 0xa8, 0x4e, 0xb3, 0x74, 0xd5, 0x20,
	0x59, 0x6c, 0xb2, 0x72, 0xe2, 0x2c, 0xb6, 0x8b, 0x4d, 0x10, 0xc4, 0xb2, 0x14, 0xaf, 0xbc, 0x8e,
	0xac, 0x8e, 0xb5, 0xbb, 0x49, 0x7a, 0x10, 0x68, 0x72, 0x2c, 0x33, 0xa6, 0x48, 0x85, 0xa4, 0xb4,
	0xab, 0x45, 0x1b, 0xb4, 0x39, 0x06, 0x28, 0x90, 0x5e, 0x7a, 0x69, 0x83, 0x1e, 0x7a, 0xe9, 0xa9,
	0x3d, 0xf5, 0xd6, 0xde, 0x7a, 0xe8, 0xa1, 0x87, 0x02, 0x45, 0x0e, 0xbd, 0xa8, 0x6d, 0x4e, 0x6d,
	0x4e, 0x81, 0x0e, 0x05, 0xda, 0x53, 0x31, 0xc3, 0x21, 0x45, 0x72, 0x48, 0x6b, 0x6d, 0xd7, 0x9b,
	0x14, 0x3d, 0xd9, 0x7a, 0xdf, 0xbc, 0x9f, 0x79, 0xf3, 0xe6, 0xbd, 0xc7, 0x47, 0x82, 0xaf, 0xd9,
	0xca, 0x21, 0x56, 0x07, 0x3a, 0xb6, 0xd6, 0xfc, 0xff, 0x2a, 0x7d, 0xcb, 0x74, 0x4c, 0x28, 0x2a,
	0x8a, 0x6e, 0x0e, 0xd4, 0x8a, 0x4f, 0x5f, 0x79, 0xa2, 0x6b, 0x76, 0x4d, 0x0a, 0xae, 0x91, 0xff,
	0xdc, 0x75, 0x2b, 0x52, 0xd7, 0x34, 0xbb, 0x3a, 0x5e, 0xa3, 0xbf, 0xf6, 0x07, 0x07, 0x6b, 0x8e,
	0xd6, 0xc3, 0xb6, 0x23, 0xf7, 0xfa, 0x6c, 0xc1, 0xa5, 0xe8, 0x82, 0xfb, 0x96, 0xdc, 0xef, 0x63,
	0xcb, 0x66, 0xb8, 0xa8, 0x98, 0x16, 0x5e, 0xc3, 0x96, 0x65, 0x32, 0xd5, 0x2b, 0xcf, 0xd9, 0x8e,
	0x85, 0xe5, 0x5e, 0xd7, 0x1c, 0x62, 0xcb, 0x90, 0x0d, 0x05, 0xaf, 0x45, 0x09, 0x6c, 0xe1, 0xbc,
	0x8d, 0x1d, 0xc7, 0xb3, 0x78, 0xa5, 0x60, 0xbf, 0xa7, 0xbb, 0xff, 0x96, 0x7f, 0x2e, 0x80, 0xc5,
	0x8d, 0x56, 0x63, 0xd3, 0xc2, 0x2a, 0x36, 0x1c, 0x4d, 0xd6, 0x6d, 0xf8, 0x2a, 0x48, 0x1f, 0xe1,
	0x51, 0x49, 0x58, 0x15, 0x2e, 0x17, 0xaa, 0x57, 0x26, 0x63, 0xe9, 0x59, 0x75, 0xff, 0x66, 0xf9,
	0x08, 0x8f, 0x5e, 0x30, 0x7b, 0x9a, 0x83, 0x7b, 0x7d, 0x67, 0x54, 0x5e, 0x1d, 0x58, 0x7a, 0x94,
	0x86, 0x08, 0x1b, 0xdc, 0x03, 0x39, 0x1b, 0x2b, 0x16, 0x76, 0x4a, 0x29, 0x2a, 0xe0, 0x95, 0xc9,
	0x58, 0xfa, 0x96, 0x85, 0x55, 0x59, 0x71, 0x6e, 0x96, 0xaf, 0x96, 0x57, 0x89, 0x2c, 0x77, 0x01,
	0x27, 0x8e, 0x23, 0x23, 0x26, 0xaa, 0xfc, 0xcf, 0x1c, 0x58, 0xdc, 0x73, 0xdd, 0x2b, 0xef, 0x6b,
	0xba, 0xe6, 0x8c, 0xe0, 0x8f, 0x04, 0xb0, 0x68, 0x1f, 0xca, 0x16, 0x56, 0x3b, 0x06, 0x76, 0xee,
	0x9b, 0xd6, 0x11, 0xb5, 0xb8, 0xb8, 0x7e, 0xb9, 0x12, 0x3d, 0x8f, 0x4a, 0x98, 0xb5, 0xd2, 0xc6,
	0xc4, 0x35, 0xa3, 0xea, 0xeb, 0x93, 0xb1, 0xf4, 0x2a, 0xb5, 0x27, 0x24, 0x87, 0xb7, 0x2b, 0x09,
	0x46, 0x0b, 0x2e, 0xd4, 0x74, 0x11, 0xf8, 0xb1, 0x00, 0x96, 0x55, 0xac, 0x6a, 0x8a, 0xec, 0x04,
	0xcc, 0x4a, 0x9d, 0xd0, 0xac, 0x37, 0x26, 0x63, 0xa9, 0x4a, 0xcc, 0xe2, 0x44, 0x71, 0x96, 0x1d,
	0xb7, 0x02, 0x89, 0x3e, 0xca, 0xec, 0x5b, 0xf9, 0x55, 0x06, 0xcc, 0x31, 0x2d, 0xf0, 0xa7, 0x53,
	0xff, 0x29, 0xfa, 0xc0, 0x76, 0xb0, 0xc5, 0xfc, 0xf7, 0xf2, 0xa3, 0x1a, 0x5a, 0xa9, 0x0d, 0x2c,
	0x46, 0xe2, 0x5c, 0xc9, 0x44, 0x26, 0xb9, 0x92, 0x87, 0x3d, 0x57, 0x6e, 0xba, 0x08, 0xfc, 0x45,
	0xc8, 0x95, 0x9e, 0x85, 0xa9, 0xd3, 0x5b, 0x18, 0xe3, 0xd5, 0x24, 0x23, 0x8f, 0x5b, 0x11, 0xf0,
	0x2a, 0x33, 0x75, 0xe5, 0xcf, 0x02, 0x00, 0x53, 0x45, 0x70, 0x1f, 0xa4, 0x75, 0xf3, 0x7e, 0x49,
	0x58, 0x4d, 0x5f, 0x5e, 0x5c, 0x7f, 0x9a, 0x37, 0x95, 0x1d, 0x46, 0x7b, 0xd4, 0xc7, 0xd5, 0x97,
	0x3e, 0x1b, 0x4b, 0xe9, 0x9d, 0xdd, 0x7b, 0xde, 0x25, 0xd3, 0xcd, 0xfb, 0x9c, 0x35, 0x61, 0x1a,
	0x22, 0xc2, 0x61, 0x17, 0x64, 0x0e, 0xb5, 0xee, 0x61, 0x29, 0xf5, 0x28, 0x4a, 0xae, 0x7d, 0x36,
	0x96, 0x32, 0xb7, 0x1a, 0x5b, 0xb7, 0x26, 0x63, 0xe9, 0x32, 0xd1, 0x42, 0x58, 0x39, 0x35, 0x11,
	0x22, 0xa2, 0x0a, 0xca, 0x7f, 0x9a, 0x03, 0xe2, 0xc6, 0x50, 0xd6, 0x3c, 0xcf, 0xbe, 0x63, 0x1a,
	0x18, 0xbe, 0x0e, 0x32, 0x86, 0xdc, 0xc3, 0xec, 0x82, 0xbf, 0xe0, 0x89, 0x25, 0x34, 0x4e, 0x6c,
	0x84, 0x88, 0x28, 0x27, 0xbc, 0x0d, 0xe6, 0x1e, 0x9a, 0x06, 0xee, 0x68, 0x6a, 0x29, 0x4d, 0x85,
	0xac, 0x4f, 0xc6, 0x52, 0x85, 0x08, 0x61, 0x64, 0x4e, 0x0e, 0x4f, 0x47, 0x39, 0x42, 0x6b, 0xa8,
	0xf0, 0x06, 0x48, 0x69, 0x6a, 0x29, 0x43, 0xe5, 0x5c, 0x9e, 0x8c, 0xa5, 0x67, 0x88, 0x9c, 0x18,
	0x11, 0x61, 0xee, 0x94, 0xa6, 0xc2, 0x3d, 0x50, 0xb0, 0x70, 0x57, 0x33, 0x0d, 0x62, 0x48, 0x96,
	0x0a, 0xb8, 0x3e, 0x19, 0x4b, 0xeb, 0x44, 0x80, 0x0f, 0x70, 0x72, 0xe2, 0x10, 0x94, 0x77, 0xa9,
	0x0d, 0x15, 0xde, 0x07, 0x45, 0xdb, 0xd0, 0x3a, 0xd8, 0x90, 0xf7, 0x75, 0xac, 0x96, 0x72, 0x34,
	0x64, 0x57, 0x2a, 0x6e, 0x6e, 0xaf, 0x78, 0xb9, 0xbd, 0x52, 0x35, 0x4d, 0xfd, 0xae, 0xac, 0x0f,
	0x70, 0xf5, 0xe6, 0x64, 0x2c, 0x5d, 0xa7, 0x77, 0x67, 0xca, 0xc6, 0x5f, 0x9c, 0x58, 0x0c, 0x01,
	0xdb, 0xd0, 0xea, 0x2e, 0x19, 0x3e, 0x00, 0x45, 0xdb, 0xbb, 0x06, 0x3a, 0x2e, 0xcd, 0x9d, 0x40,
	0xf1, 0x94, 0x8d, 0x57, 0x1c, 0x8b, 0xa1, 0xa0, 0x2a, 0xa8, 0x83, 0x39, 0xc5, 0xc2, 0xe4, 0x4e,
	0x94, 0xf2, 0x09, 0x5a, 0xdb, 0x5e, 0xad, 0xa3, 0x1e, 0xa6, 0x47, 0xcd, 0x58, 0x38, 0x8d, 0x3c,
	0xfd, 0xa3, 0xbf, 0x48, 0x02, 0xf2, 0x54, 0xc0, 0x3e, 0xc8, 0xf7, 0x4c, 0x55, 0x3b, 0xd0, 0xb0,
	0x5a, 0x2a, 0xcc, 0x54, 0x77, 0x63, 0x32, 0x96, 0x5e, 0x24, 0xea, 0x3c, 0x1e, 0x4e, 0x5f, 0x0c,
	0x40, 0x15, 0xfa, 0x5a, 0xe0, 0x77, 0x41, 0x51, 0xc5, 0xb2, 0xe2, 0x68, 0x43, 0xba, 0x47, 0x30,
	0x53, 0xe9, 0x6b, 0x9e, 0x67, 0x03, 0x6c, 0x31, 0x69, 0x26, 0x0e, 0xa3, 0xaa, 0x83, 0xea, 0x60,
	0x0d, 0x64, 0x2d, 0x2c, 0xeb, 0xbd, 0xd2, 0x3c, 0x8d, 0xd0, 0xca, 0x64, 0x2c, 0x5d, 0x71, 0x23,
	0x54, 0xd6, 0x7b, 0x31, 0xd1, 0x19, 0xa6, 0x22, 0x97, 0x79, 0x3b, 0x93, 0x17, 0xc4, 0xd4, 0x76,
	0x26, 0x5f, 0x14, 0xe7, 0xcb, 0x7f, 0xc8, 0x83, 0x1c, 0xa2, 0xf1, 0xca, 0x2e, 0x8f, 0x70, 0x8a,
	0xcb, 0x53, 0x03, 0x59, 0x9a, 0x75, 0x58, 0x1a, 0xf0, 0xcd, 0xa2, 0x44, 0xfe, 0x50, 0x23, 0x54,
	0xe4, 0x32, 0xc3, 0x43, 0x90, 0x25, 0xd7, 0xd8, 0x2e, 0xa5, 0x57, 0xd3, 0x97, 0x8b, 0xeb, 0x65,
	0x3e, 0x95, 0x45, 0xd3, 0xcf, 0x54, 0x13, 0x65, 0x8c, 0xcd, 0x14, 0x76, 0x48, 0x13, 0xa5, 0xf8,
	0x59, 0x2b, 0x73, 0xea, 0xac, 0xd5, 0x05, 0x8b, 0x9a, 0xdd, 0x09, 0xde, 0x31, 0x92, 0x33, 0xf2,
	0xd3, 0xe2, 0x17, 0x46, 0x79, 0x1f, 0x26, 0xc1, 0x68, 0x41, 0xb3, 0xf7, 0x02, 0xf7, 0xe9, 0x7d,
	0xf0, 0x84, 0x66, 0x77, 0x7a, 0x03, 0xdd, 0xd1, 0x68, 0xde, 0x0b, 0xe6, 0x92, 0x7c, 0x75, 0x67,
	0x32, 0x96, 0x6e, 0x31, 0x75, 0xdc, 0x9a, 0x38, 0xa5, 0xc7, 0x2d, 0x42, 0x50, 0xb3, 0xdf, 0xf4,
	0x70, 0x2f, 0x93, 0x68, 0x20, 0xa7, 0x98, 0xc6, 0x81, 0xd6, 0x65, 0x49, 0x44, 0xe2, 0x4f, 0xc5,
	0x0d, 0x9f, 0xca, 0x26, 0x5d, 0x56, 0x7d, 0x71, 0x32, 0x96, 0x5e, 0xa0, 0x87, 0x4f, 0x7f, 0xf3,
	0xa7, 0x1f, 0x25, 0x23, 0xa6, 0x00, 0x7e, 0x48, 0xda, 0x90, 0x50, 0xf1, 0x66, 0x29, 0x64, 0x75,
	0x56, 0x91, 0x0f, 0xf4, 0x1c, 0x21, 0x7a, 0x72, 0x06, 0x8b, 0xc2, 0x28, 0xa2, 0x79, 0xe5, 0xd7,
	0x02, 0xc8, 0xd5, 0x4c, 0xe5, 0x08, 0x5b, 0x24, 0x5a, 0x2c, 0xdc, 0x37, 0xd9, 0xcd, 0xf0, 0xa3,
	0x85, 0xd0, 0x62, 0xae, 0x5c, 0x88, 0x88, 0x28, 0x27, 0xec, 0x80, 0x79, 0xad, 0x27, 0x77, 0x71,
	0xa7, 0x6f, 0xe1, 0x03, 0xed, 0x01, 0xbb, 0x26, 0xaf, 0x4e, 0xc6, 0xd2, 0x0d, 0x7a, 0x78, 0x01,
	0x8c, 0x3f, 0xb4, 0x78, 0x10, 0x15, 0x29, 0xd0, 0xa2, 0xf4, 0x9b, 0xf9, 0x0f, 0xff, 0xf5, 0x7c,
	0xe6, 0x5d, 0xdb, 0x34, 0x56, 0xbe, 0x07, 0x72, 0xee, 0x41, 0x90, 0x93, 0x53, 0xe9, 0x06, 0x58,
	0x33, 0x97, 0x7c, 0x72, 0xee, 0x3e, 0xa7, 0x27, 0xe7, 0xb2, 0xf1, 0x49, 0x2a, 0x4a, 0x46, 0x4c,
	0xc1, 0x54, 0x7d, 0xf9, 0x0e, 0x58, 0xda, 0x50, 0x14, 0x73, 0x60, 0x38, 0x6f, 0x62, 0x47, 0x56,
	0x65, 0x47, 0x3e, 0x7d, 0x5a, 0x09, 0x88, 0xfd, 0x7b, 0x0a, 0x2c, 0x6c, 0x12, 0xe3, 0xcf, 0x2e,
	0x15, 0x1e, 0x80, 0x39, 0xb7, 0x40, 0xdb, 0xb4, 0x67, 0x2a, 0xae, 0x97, 0x92, 0x1c, 0x33, 0x6d,
	0x45, 0x18, 0x43, 0x42, 0xfd, 0x0f, 0xa5, 0x18, 0x4f, 0xb8, 0x9f, 0x64, 0xd2, 0xa7, 0x4e, 0x32,
	0x36, 0xc8, 0xcb, 0xae, 0x33, 0xed, 0x52, 0x86, 0x9a, 0xfa, 0x8d, 0x98, 0x9c, 0x18, 0x76, 0x77,
	0xf5, 0x9a, 0x57, 0xe4, 0x3c, 0x56, 0x4e, 0x59, 0x0c, 0x80, 0x7c, 0x45, 0xe5, 0x7f, 0x64, 0xc1,
	0x57, 0xc9, 0xed, 0xea, 0xc9, 0xc4, 0x09, 0xb6, 0x63, 0x8d, 0x76, 0x4c, 0x45, 0x76, 0x48, 0x81,
	0x78, 0xd7, 0xf7, 0xf9, 0xe2, 0x7a, 0x85, 0xb7, 0x64, 0x4b, 0x37, 0xf7, 0x65, 0x3d, 0x9e, 0x97,
	0x3e, 0x3c, 0x3e, 0xd2, 0x19, 0x95, 0x04, 0x7a, 0x4a, 0xd5, 0x50, 0x63, 0x59, 0x39, 0x89, 0xf7,
	0x4a, 0x02, 0xf3, 0xdf, 0x3d, 0x00, 0x58, 0xd7, 0x3e, 0xed, 0x2e, 0x49, 0x0f, 0x70, 0xcd, 0xad,
	0x4d, 0x1e, 0x12, 0x53, 0xa0, 0x62, 0x20, 0x54, 0x60, 0xe4, 0x86, 0x0a, 0x4d, 0x20, 0xda, 0xd8,
	0x1a, 0x6a, 0x0a, 0xb9, 0x98, 0xe6, 0x50, 0x53, 0xb1, 0xc5, 0x6a, 0x49, 0x6d, 0x32, 0x96, 0x5e,
	0x77, 0x9f, 0x6b, 0xc3, 0x78, 0xcc, 0x13, 0x6e, 0xe2, 0x02, 0xb4, 0xc4, 0xc0, 0x16, 0xc3, 0xe0,
	0x0e, 0x98, 0xeb, 0xcb, 0xca, 0x91, 0xdc, 0x25, 0x75, 0x26, 0x1d, 0x6c, 0x92, 0x19, 0x99, 0x13,
	0xcf, 0xd3, 0x91, 0x27, 0x82, 0x24, 0xda, 0x27, 0xa3, 0xea, 0x3b, 0x6e, 0xd8, 0xd2, 0xba, 0x52,
	0xa8, 0xa2, 0xc9, 0x58, 0x6a, 0xc6, 0x6d, 0x83, 0x2d, 0x9b, 0xb9, 0x1b, 0x7e, 0x1d, 0xba, 0x18,
	0xd9, 0x14, 0xeb, 0x3a, 0x1e, 0x82, 0x0b, 0xac, 0x8b, 0x56, 0x35, 0xbb, 0xaf, 0xcb, 0xa3, 0x0e,
	0x3d, 0xf7, 0x39, 0x6a, 0xc7, 0xf6, 0x64, 0x2c, 0xbd, 0x11, 0x68, 0xc1, 0x83, 0x4b, 0x92, 0x9a,
	0xf1, 0x84, 0x35, 0x68, 0xd9, 0xc5, 0x6b, 0x2e, 0xdc, 0x94, 0x7b, 0xb8, 0xfc, 0x13, 0x01, 0x2c,
	0xd7, 0x8d, 0xa1, 0x66, 0x99, 0x46, 0x0f, 0x1b, 0xce, 0x9e, 0x23, 0x3b, 0x03, 0x7a, 0x71, 0x35,
	0xe3, 0x80, 0xcb, 0xf7, 0x84, 0xc6, 0x87, 0x6e, 0x98, 0x88, 0x28, 0x27, 0xe9, 0x87, 0xe8, 0x68,
	0x26, 0xda, 0x0f, 0x51, 0x22, 0x27, 0x23, 0x4a, 0x45, 0x2e, 0x73, 0xf9, 0xa3, 0x0c, 0x78, 0x6a,
	0x0b, 0x3b, 0x01, 0x03, 0xbd, 0x4b, 0x8e, 0x70, 0x5f, 0x1f, 0xc1, 0xb7, 0x3c, 0x2d, 0x6e, 0x7e,
	0x87, 0xde, 0x8d, 0x54, 0x4c, 0x0b, 0x57, 0xea, 0x04, 0x39, 0xa5, 0x66, 0x5a, 0xf4, 0x89, 0x28,
	0x2f, 0x43, 0xc6, 0x94, 0x8e, 0x50, 0x36, 0x0e, 0x14, 0x7d, 0xca, 0x16, 0xdf, 0xf2, 0xd9, 0xe1,
	0xa2, 0x4f, 0x49, 0xb0, 0x07, 0x72, 0x36, 0x75, 0x3b, 0xbd, 0x9f, 0xc5, 0xf5, 0x6f, 0xf2, 0xaa,
	0xb8, 0x13, 0x9a, 0xaa, 0x73, 0x59, 0xf9, 0x68, 0x8c, 0x92, 0x11, 0x53, 0x02, 0x7f, 0x23, 0xb8,
	0xe3, 0xbb, 0x9e, 0x4c, 0x23, 0x94, 0xa4, 0xa8, 0x8e, 0xce, 0x72, 0x94, 0x97, 0x64, 0x13, 0xc6,
	0x33, 0x31, 0x49, 0xed, 0xee, 0x64, 0x2c, 0x21, 0xaf, 0xed, 0x88, 0x15, 0x19, 0xdb, 0x81, 0xcc,
	0x5a, 0x89, 0x9e, 0xb4, 0x63, 0xf5, 0xd9, 0xe5, 0x1f, 0x64, 0x41, 0x79, 0x93, 0x3e, 0xfb, 0x84,
	0x2d, 0x62, 0xf3, 0x07, 0x84, 0xdf, 0x1b, 0x60, 0xdb, 0x81, 0xf7, 0xfd, 0xa6, 0xcd, 0x0d, 0x8d,
	0xab, 0xb3, 0x76, 0xc4, 0xf8, 0xcf, 0xdc, 0xc2, 0xfd, 0x4e, 0x00, 0x4b, 0x96, 0x6b, 0x44, 0x47,
	0x91, 0x2d, 0x4b, 0xa3, 0x83, 0x1a, 0xe2, 0xd4, 0x5b, 0x31, 0x21, 0x34, 0x73, 0x23, 0x15, 0xf6,
	0x77, 0xd3, 0x15, 0x55, 0x37, 0x1c, 0x6b, 0x54, 0xfd, 0xf6, 0x64, 0x2c, 0x35, 0x22, 0x53, 0xc4,
	0x88, 0xce, 0x98, 0xd4, 0x90, 0x84, 0x7f, 0xfe, 0xef, 0xe7, 0x05, 0xb4, 0x68, 0x85, 0xf4, 0xc0,
	0x01, 0x98, 0xf3, 0xc6, 0x4c, 0x19, 0xea, 0xc0, 0xe7, 0x1e, 0xd1, 0x81, 0xd3, 0xbc, 0x9c, 0x34,
	0x50, 0x8a, 0x19, 0x23, 0x79, 0xba, 0x56, 0x3e, 0x16, 0xc0, 0x85, 0x98, 0x1d, 0x9f, 0x71, 0x0a,
	0x5b, 0x03, 0xd9, 0x21, 0x79, 0xc6, 0x8f, 0x26, 0x23, 0x4a, 0xe4, 0x24, 0x44, 0xa9, 0xc8, 0x65,
	0xbe, 0x99, 0xba, 0x21, 0x6c, 0x67, 0xf2, 0x69, 0x31, 0x53, 0xfe, 0x24, 0x0b, 0x56, 0x8f, 0x3d,
	0xba, 0xf3, 0xcd, 0x4d, 0xbf, 0x15, 0xc0, 0xf2, 0x50, 0xd6, 0x35, 0x95, 0x5e, 0x89, 0x0e, 0x25,
	0xda, 0xa7, 0x0c, 0xb2, 0xbe, 0x3e, 0xaa, 0xdc, 0xf5, 0x65, 0x51, 0xb3, 0x6c, 0x37, 0xc8, 0xfc,
	0x11, 0x21, 0xa7, 0x2a, 0xce, 0x63, 0x89, 0x2b, 0x90, 0x38, 0x8c, 0x88, 0x0f, 0xc6, 0x56, 0xfa,
	0xf1, 0xc5, 0x16, 0x7c, 0x1f, 0x14, 0x95, 0xe9, 0x60, 0x9f, 0x85, 0x75, 0xcc, 0x83, 0x55, 0xf8,
	0x05, 0xc0, 0x74, 0x2e, 0x14, 0x60, 0x8e, 0x9b, 0xd2, 0xc4, 0x60, 0x28, 0xa8, 0x70, 0xe5, 0x67,
	0x02, 0xb8, 0x18, 0xeb, 0xea, 0x2f, 0x4b, 0x74, 0x97, 0xff, 0x96, 0x02, 0x97, 0xb6, 0xb0, 0x13,
	0xeb, 0x7b, 0xfb, 0xbc, 0xa3, 0x7a, 0x04, 0xf2, 0xec, 0xa4, 0xbc, 0x58, 0x7e, 0xe4, 0xb0, 0xf0,
	0x1b, 0x7e, 0x4f, 0x40, 0x52, 0x5c, 0x84, 0x1b, 0x7e, 0x8f, 0x08, 0xdf, 0x05, 0x4b, 0x06, 0x7e,
	0xe0, 0x74, 0xfa, 0xe4, 0x39, 0xd3, 0x31, 0x8f, 0xb0, 0xc1, 0x5a, 0xe5, 0xea, 0x64, 0x2c, 0xbd,
	0x46, 0x9b, 0xee, 0x30, 0xcc, 0xf7, 0xdf, 0x89, 0x38, 0x5a, 0x20, 0x58, 0x4b, 0xee, 0xe2, 0x36,
	0x41, 0xca, 0x9f, 0x0b, 0xe0, 0xe9, 0x24, 0x1f, 0x9f, 0xb7, 0x8b, 0x03, 0x17, 0x2f, 0xf5, 0xf8,
	0x2e, 0x5e, 0xf9, 0x83, 0x0c, 0x28, 0xdf, 0xe9, 0xab, 0xb3, 0x4a, 0x76, 0xc0, 0x3a, 0xe1, 0x31,
	0xa6, 0x85, 0x13, 0x15, 0xec, 0xd9, 0xdb, 0xf8, 0x82, 0x0a, 0xf6, 0x97, 0xbd, 0x72, 0x96, 0x3f,
	0xc9, 0x80, 0xd5, 0x63, 0xbd, 0xf7, 0xa5, 0xaa, 0x99, 0xb3, 0x2c, 0xfd, 0x3f, 0xa9, 0x99, 0xff,
	0x03, 0x35, 0xeb, 0x87, 0x29, 0xf0, 0x6c, 0x0d, 0xeb, 0xd8, 0x3b, 0xad, 0xa9, 0xb5, 0x08, 0xdb,
	0xe6, 0xc0, 0x52, 0xb0, 0xed, 0x25, 0x98, 0x21, 0x80, 0xba, 0xd9, 0xd5, 0x14, 0x59, 0xef, 0x04,
	0x86, 0x22, 0xee, 0x0e, 0x6e, 0x4d, 0xc6, 0x52, 0xcd, 0x7d, 0xe9, 0x18, 0x5d, 0x11, 0xf3, 0x0e,
	0xf2, 0x98, 0x25, 0x48, 0x64, 0xf0, 0xa6, 0x3f, 0x2b, 0x39, 0x02, 0x4b, 0xa6, 0xd5, 0x95, 0x0d,
	0xed, 0xa1, 0x7b, 0xde, 0x9a, 0xfb, 0x96, 0x20, 0x3b, 0x2d, 0x2f, 0x11, 0x98, 0xd3, 0x98, 0x8c,
	0xa3, 0xc5, 0x20, 0xd6, 0x50, 0xcb, 0xdf, 0x17, 0xc0, 0x33, 0x33, 0xfd, 0x71, 0xae, 0x77, 0xad,
	0xfc, 0xe3, 0x02, 0x78, 0xea, 0x98, 0x87, 0x2b, 0x7f, 0xb0, 0x95, 0x39, 0xc3, 0x60, 0xcb, 0x00,
	0xe2, 0x91, 0x7c, 0x70, 0x24, 0xf3, 0x27, 0xe9, 0xcf, 0x9f, 0xa2, 0x38, 0x1f, 0x98, 0xc9, 0x0b,
	0xd0, 0x22, 0x05, 0xa7, 0x67, 0xb8, 0x03, 0xe6, 0x6c, 0x6c, 0x0d, 0xdd, 0xe6, 0x84, 0x9c, 0x9d,
	0x7f, 0xad, 0x18, 0x39, 0x76, 0x1e, 0x14, 0xe9, 0x38, 0x3c, 0x11, 0xf0, 0x1e, 0x00, 0x6c, 0xda,
	0x18, 0x33, 0x96, 0x9b, 0x22, 0x49, 0x73, 0xcb, 0xe8, 0x58, 0x8e, 0x91, 0x1b, 0x2a, 0xfc, 0x40,
	0x00, 0x79, 0xef, 0x79, 0x9a, 0xbe, 0x8f, 0x39, 0xf9, 0x98, 0xf2, 0xba, 0xd7, 0x4c, 0x79, 0x72,
	0x62, 0xe2, 0x9f, 0x03, 0x4a, 0x02, 0xf2, 0xf5, 0xc6, 0xce, 0x06, 0x73, 0xe7, 0x39, 0x1b, 0x7c,
	0x08, 0x2e, 0xf4, 0x0f, 0x47, 0x76, 0xf4, 0x66, 0x47, 0x06, 0x68, 0x31, 0x4b, 0xf8, 0x99, 0xe1,
	0xb1, 0x6b, 0xd0, 0xb2, 0x87, 0x87, 0x02, 0xc3, 0x9b, 0x4b, 0xe6, 0xc3, 0x2f, 0xef, 0xff, 0xdb,
	0x73, 0xc9, 0xc2, 0xe3, 0x9e, 0x4b, 0x8e, 0x40, 0x8e, 0xa9, 0x76, 0xdf, 0xf1, 0xae, 0xf9, 0x91,
	0x14, 0xfd, 0xac, 0x6a, 0x8f, 0x12, 0xb6, 0x7c, 0x02, 0x7b, 0x79, 0xe0, 0x4f, 0x51, 0x12, 0x4c,
	0xe3, 0x2d, 0x61, 0x0a, 0x61, 0x1b, 0x14, 0xfc, 0x2f, 0x4b, 0x4a, 0x45, 0xfa, 0xa2, 0xcf, 0xff,
	0x16, 0xc1, 0x07, 0x92, 0x3f, 0x55, 0x09, 0xdd, 0x0e, 0x9f, 0x5a, 0x9e, 0xcc, 0x83, 0x8b, 0xb1,
	0x89, 0xe9, 0x0c, 0xef, 0x52, 0xbc, 0x77, 0x1c, 0xe0, 0xd4, 0xef, 0x38, 0xe2, 0x52, 0x59, 0xea,
	0x1c, 0x53, 0x59, 0x0b, 0xe4, 0xb1, 0xa1, 0xf6, 0x4d, 0xcd, 0x70, 0x58, 0xea, 0xf1, 0x9f, 0x9f,
	0x3c, 0x3a, 0x9f, 0xea, 0x79, 0x00, 0xf9, 0x52, 0xe0, 0xe1, 0xf4, 0x8b, 0x87, 0xcc, 0xcc, 0xaf,
	0x01, 0xd6, 0x4f, 0xfe, 0xc5, 0xc3, 0xf4, 0x6b, 0x07, 0x3d, 0xf0, 0xb5, 0x43, 0x76, 0xa6, 0xaa,
	0x6b, 0xa7, 0xf9, 0xda, 0x21, 0xf0, 0xa5, 0x83, 0xe6, 0x4f, 0x66, 0x73, 0x34, 0x95, 0xc6, 0x0e,
	0x81, 0xa9, 0x5b, 0xcf, 0x3c, 0x95, 0xfd, 0x22, 0x53, 0xd8, 0x9b, 0xa1, 0x6a, 0x94, 0x9f, 0x76,
	0x64, 0x91, 0x9a, 0xe3, 0x3e, 0xb7, 0xcc, 0xac, 0x41, 0x31, 0xed, 0x4e, 0xe1, 0xbc, 0xda, 0x1d,
	0xf8, 0x1d, 0x50, 0xec, 0xc9, 0x0f, 0x3a, 0xee, 0xb4, 0xd8, 0xa6, 0xa9, 0x22, 0x3b, 0x1d, 0xd9,
	0x04, 0x20, 0xfe, 0xe8, 0x63, 0x31, 0x04, 0x7a, 0xf2, 0x03, 0x37, 0x47, 0xd0, 0xb9, 0x80, 0x69,
	0x75, 0x3b, 0x16, 0x6b, 0x9c, 0xc8, 0x4e, 0xe6, 0xc3, 0x73, 0x81, 0x08, 0x1c, 0xb7, 0x93, 0x04,
	0x1c, 0x2d, 0x98, 0x56, 0xd7, 0x6b, 0xc9, 0xc2, 0x75, 0x64, 0xe1, 0xec, 0x75, 0x24, 0xae, 0x04,
	0x2f, 0x9f, 0x67, 0x09, 0x3e, 0xae, 0x70, 0xc1, 0x2f, 0xae, 0x70, 0x5d, 0x78, 0xcc, 0x85, 0x6b,
	0x3b, 0x93, 0x5f, 0x14, 0x97, 0xb6, 0x33, 0xf9, 0x25, 0x51, 0xdc, 0xce, 0xe4, 0x45, 0x71, 0xf9,
	0xca, 0x7b, 0xa0, 0x18, 0xf8, 0xfe, 0x10, 0x8a, 0x60, 0xfe, 0x4e, 0xf3, 0x76, 0x73, 0xf7, 0x5e,
	0xb3, 0xd3, 0x7e, 0xbb, 0x55, 0x17, 0xbf, 0x02, 0x01, 0xc8, 0xb5, 0xee, 0x54, 0x77, 0x1a, 0x9b,
	0xa2, 0x40, 0xd0, 0x16, 0x6a, 0xdc, 0xdd, 0x68, 0xd7, 0x3b, 0x3b, 0x8d, 0xe6, 0x6d, 0x31, 0x05,
	0x2f, 0x80, 0xa5, 0x36, 0xda, 0x68, 0xee, 0x35, 0xda, 0x9d, 0xad, 0x8d, 0x76, 0xfd, 0xde, 0xc6,
	0xdb, 0x62, 0x1a, 0x2e, 0x81, 0xe2, 0xdd, 0xd6, 0x66, 0xa7, 0x55, 0xaf, 0xa3, 0x46, 0x73, 0x4b,
	0xcc, 0xc0, 0x79, 0x90, 0x6f, 0x34, 0xdb, 0x75, 0xd4, 0xdc, 0xd8, 0x11, 0xb3, 0x57, 0xaa, 0xe0,
	0xeb, 0xc7, 0xb5, 0x78, 0x30, 0x0f, 0x32, 0xcd, 0xdd, 0x26, 0xd1, 0x9d, 0x03, 0xa9, 0x3b, 0x7b,
	0xa2, 0x40, 0xfe, 0xd6, 0xef, 0x88, 0x29, 0x82, 0x6c, 0xb4, 0x36, 0x36, 0xc5, 0xf4, 0x95, 0x5f,
	0x0a, 0x60, 0x21, 0x94, 0xdc, 0x5c, 0xdb, 0x76, 0xef, 0x36, 0xf6, 0x1a, 0xbb, 0x4d, 0xa2, 0xd5,
	0xe5, 0x6e, 0x89, 0x02, 0xe1, 0xaa, 0xed, 0xde, 0x6b, 0x8a, 0x29, 0x62, 0x47, 0xad, 0xbe, 0x53,
	0x6f, 0x13, 0x3c, 0x0d, 0x8b, 0x60, 0x8e, 0xfe, 0xaa, 0xd7, 0xc4, 0x0c, 0xbc, 0x08, 0x96, 0xeb,
	0x6f, 0xb5, 0xc8, 0x4e, 0x76, 0x9b, 0x9d, 0x56, 0xbd, 0x59, 0x23, 0x6b, 0xb2, 0x70, 0x01, 0x14,
	0x28, 0x99, 0xfe, 0xcc, 0x41, 0x08, 0x16, 0xf7, 0x6e, 0xa1, 0x46, 0xf3, 0xb6, 0xbf, 0x64, 0x8e,
	0x2c, 0x71, 0x69, 0xe4, 0x67, 0x9e, 0x08, 0xda, 0x6b, 0xef, 0xa2, 0x8d, 0xad, 0x7a, 0x67, 0xca,
	0x59, 0xa8, 0x0e, 0x7f, 0xff, 0xe9, 0x25, 0xe1, 0x8f, 0x9f, 0x5e, 0x12, 0xfe, 0xfa, 0xe9, 0x25,
	0x01, 0x54, 0x34, 0xb3, 0xa2, 0x98, 0xc6, 0x81, 0x3e, 0xc0, 0x86, 0x53, 0x71, 0x4f, 0xdf, 0xaf,
	0x10, 0xb4, 0x20, 0x06, 0x92, 0xf8, 0xf0, 0xa5, 0x96, 0xf0, 0xce, 0xf5, 0xae, 0xe6, 0x1c, 0x0e,
	0xf6, 0x2b, 0x8a, 0xd9, 0x5b, 0xf3, 0x39, 0x35, 0x43, 0x59, 0x73, 0x63, 0xe7, 0xaa, 0xad, 0x1e,
	0x5d, 0xed, 0x9a, 0x57, 0x87, 0x2f, 0x5d, 0xed, 0x0f, 0xf6, 0x75, 0x4d, 0x79, 0xc5, 0xa5, 0xef,
	0xe7, 0xa8, 0xd8, 0x97, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x72, 0x50, 0x9e, 0xb6, 0x14, 0x2f,
	0x00, 0x00,
}

func (m *APICredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *APICredentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Secret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Schedulability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schedulability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SharedNetwork != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.SharedNetwork.Size()))
		n1, err := m.SharedNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.DedicatedNetwork != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.DedicatedNetwork.Size()))
		n2, err := m.DedicatedNetwork.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Schedulability_Tenancy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schedulability_Tenancy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SharedCluster != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.SharedCluster.Size()))
		n3, err := m.SharedCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DedicatedCluster != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.DedicatedCluster.Size()))
		n4, err := m.DedicatedCluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Schedulability_Tenancy_Durability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schedulability_Tenancy_Durability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Low) > 0 {
		dAtA6 := make([]byte, len(m.Low)*10)
		var j5 int
		for _, num := range m.Low {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.High) > 0 {
		dAtA8 := make([]byte, len(m.High)*10)
		var j7 int
		for _, num := range m.High {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AvailabilityZone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvailabilityZone) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ZoneId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.ZoneId)))
		i += copy(dAtA[i:], m.ZoneId)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.RegionId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.RegionId)))
		i += copy(dAtA[i:], m.RegionId)
	}
	if m.SniEnabled != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.SniEnabled.Size()))
		n9, err := m.SniEnabled.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Schedulable != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Schedulable.Size()))
		n10, err := m.Schedulable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Created != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.Created)))
		n11, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Created, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Modified != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.Modified)))
		n12, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Modified, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Deactivated != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.Deactivated)))
		n13, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Deactivated, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Realm) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Realm)))
		i += copy(dAtA[i:], m.Realm)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Region) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Region) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Cloud) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Cloud)))
		i += copy(dAtA[i:], m.Cloud)
	}
	if len(m.Zones) > 0 {
		for _, msg := range m.Zones {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.IsSchedulable {
		dAtA[i] = 0x28
		i++
		if m.IsSchedulable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsMultizoneEnabled {
		dAtA[i] = 0x30
		i++
		if m.IsMultizoneEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Config != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Config.Size()))
		n14, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Schedulability != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Schedulability.Size()))
		n15, err := m.Schedulability.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Region_Docker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Region_Docker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Repo)))
		i += copy(dAtA[i:], m.Repo)
	}
	if len(m.ImagePrefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.ImagePrefix)))
		i += copy(dAtA[i:], m.ImagePrefix)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Region_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Region_Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Docker != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Docker.Size()))
		n16, err := m.Docker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AccountMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CloudMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Regions) > 0 {
		for _, msg := range m.Regions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Accounts) > 0 {
		for _, msg := range m.Accounts {
			dAtA[i] = 0x22
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SchemaRegistryLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaRegistryLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ClusterId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.ClusterId)))
		i += copy(dAtA[i:], m.ClusterId)
	}
	if len(m.ServiceProvider) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.ServiceProvider)))
		i += copy(dAtA[i:], m.ServiceProvider)
	}
	if len(m.Package) > 0 {
		for _, s := range m.Package {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ServiceProviderRegion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.ServiceProviderRegion)))
		i += copy(dAtA[i:], m.ServiceProviderRegion)
	}
	if len(m.RegionDisplayName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.RegionDisplayName)))
		i += copy(dAtA[i:], m.RegionDisplayName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvironmentStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvironmentStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Info)))
		i += copy(dAtA[i:], m.Info)
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetEnvironmentMetadataReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEnvironmentMetadataReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Error.Size()))
		n17, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Clouds) > 0 {
		for _, msg := range m.Clouds {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Status.Size()))
		n18, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.SchemaRegistryLocations) > 0 {
		for _, msg := range m.SchemaRegistryLocations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateSchemaRegistryClusterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSchemaRegistryClusterRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Config.Size()))
		n19, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.RequestCarrier) > 0 {
		for k, _ := range m.RequestCarrier {
			dAtA[i] = 0x12
			i++
			v := m.RequestCarrier[k]
			mapSize := 1 + len(k) + sovScheduler(uint64(len(k))) + 1 + len(v) + sovScheduler(uint64(len(v)))
			i = encodeVarintScheduler(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Cluster != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Cluster.Size()))
		n20, err := m.Cluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateSchemaRegistryClusterReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSchemaRegistryClusterReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Error.Size()))
		n21, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.ValidationErrors) > 0 {
		for k, _ := range m.ValidationErrors {
			dAtA[i] = 0x12
			i++
			v := m.ValidationErrors[k]
			mapSize := 1 + len(k) + sovScheduler(uint64(len(k))) + 1 + len(v) + sovScheduler(uint64(len(v)))
			i = encodeVarintScheduler(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Cluster != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Cluster.Size()))
		n22, err := m.Cluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Credentials != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Credentials.Size()))
		n23, err := m.Credentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetSchemaRegistryClustersReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSchemaRegistryClustersReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Error.Size()))
		n24, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.Clusters) > 0 {
		for _, msg := range m.Clusters {
			dAtA[i] = 0x12
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetSchemaRegistryClusterReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSchemaRegistryClusterReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Error.Size()))
		n25, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Cluster != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Cluster.Size()))
		n26, err := m.Cluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateSchemaRegistryClusterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSchemaRegistryClusterRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cluster != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Cluster.Size()))
		n27, err := m.Cluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.RequestCarrier) > 0 {
		for k, _ := range m.RequestCarrier {
			dAtA[i] = 0x12
			i++
			v := m.RequestCarrier[k]
			mapSize := 1 + len(k) + sovScheduler(uint64(len(k))) + 1 + len(v) + sovScheduler(uint64(len(v)))
			i = encodeVarintScheduler(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateSchemaRegistryClusterReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSchemaRegistryClusterReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Error.Size()))
		n28, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if len(m.ValidationErrors) > 0 {
		for k, _ := range m.ValidationErrors {
			dAtA[i] = 0x12
			i++
			v := m.ValidationErrors[k]
			mapSize := 1 + len(k) + sovScheduler(uint64(len(k))) + 1 + len(v) + sovScheduler(uint64(len(v)))
			i = encodeVarintScheduler(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintScheduler(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Cluster != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Cluster.Size()))
		n29, err := m.Cluster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteSchemaValidationResourcesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteSchemaValidationResourcesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LogicalClusterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.LogicalClusterId)))
		i += copy(dAtA[i:], m.LogicalClusterId)
	}
	if m.OrganizationId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.OrganizationId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteSchemaValidationResourcesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteSchemaValidationResourcesReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Error.Size()))
		n30, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SchemaRegistryClusterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaRegistryClusterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KafkaClusterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.KafkaClusterId)))
		i += copy(dAtA[i:], m.KafkaClusterId)
	}
	if m.Servers != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Servers))
	}
	if len(m.AccountId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Location != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Location))
	}
	if len(m.ServiceProvider) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.ServiceProvider)))
		i += copy(dAtA[i:], m.ServiceProvider)
	}
	if len(m.PhysicalClusterId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.PhysicalClusterId)))
		i += copy(dAtA[i:], m.PhysicalClusterId)
	}
	if len(m.Package) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Package)))
		i += copy(dAtA[i:], m.Package)
	}
	if len(m.ServiceProviderRegion) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.ServiceProviderRegion)))
		i += copy(dAtA[i:], m.ServiceProviderRegion)
	}
	if m.Region != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Region.Size()))
		n31, err := m.Region.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Dedicated {
		dAtA[i] = 0x58
		i++
		if m.Dedicated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SchemaRegistryCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaRegistryCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.KafkaClusterId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.KafkaClusterId)))
		i += copy(dAtA[i:], m.KafkaClusterId)
	}
	if len(m.Endpoint) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Endpoint)))
		i += copy(dAtA[i:], m.Endpoint)
	}
	if m.Created != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Created.Size()))
		n32, err := m.Created.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Modified != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Modified.Size()))
		n33, err := m.Modified.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Status != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Status))
	}
	if len(m.PhysicalClusterId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.PhysicalClusterId)))
		i += copy(dAtA[i:], m.PhysicalClusterId)
	}
	if len(m.AccountId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	if m.OrganizationId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.OrganizationId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.MaxSchemas != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.MaxSchemas))
	}
	if len(m.OrgResourceId) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.OrgResourceId)))
		i += copy(dAtA[i:], m.OrgResourceId)
	}
	if len(m.Package) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.Package)))
		i += copy(dAtA[i:], m.Package)
	}
	if len(m.ServiceProvider) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.ServiceProvider)))
		i += copy(dAtA[i:], m.ServiceProvider)
	}
	if len(m.ServiceProviderRegion) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(len(m.ServiceProviderRegion)))
		i += copy(dAtA[i:], m.ServiceProviderRegion)
	}
	if m.Region != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintScheduler(dAtA, i, uint64(m.Region.Size()))
		n34, err := m.Region.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintScheduler(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *APICredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Schedulability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SharedNetwork != nil {
		l = m.SharedNetwork.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.DedicatedNetwork != nil {
		l = m.DedicatedNetwork.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Schedulability_Tenancy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SharedCluster != nil {
		l = m.SharedCluster.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.DedicatedCluster != nil {
		l = m.DedicatedCluster.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Schedulability_Tenancy_Durability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Low) > 0 {
		l = 0
		for _, e := range m.Low {
			l += sovScheduler(uint64(e))
		}
		n += 1 + sovScheduler(uint64(l)) + l
	}
	if len(m.High) > 0 {
		l = 0
		for _, e := range m.High {
			l += sovScheduler(uint64(e))
		}
		n += 1 + sovScheduler(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AvailabilityZone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.ZoneId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.SniEnabled != nil {
		l = m.SniEnabled.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Schedulable != nil {
		l = m.Schedulable.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Created != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Created)
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Modified != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Modified)
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Deactivated != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Deactivated)
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.Realm)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Region) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.Cloud)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.Zones) > 0 {
		for _, e := range m.Zones {
			l = e.Size()
			n += 1 + l + sovScheduler(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.IsSchedulable {
		n += 2
	}
	if m.IsMultizoneEnabled {
		n += 2
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Schedulability != nil {
		l = m.Schedulability.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Region_Docker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.ImagePrefix)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Region_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Docker != nil {
		l = m.Docker.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloudMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.Regions) > 0 {
		for _, e := range m.Regions {
			l = e.Size()
			n += 1 + l + sovScheduler(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovScheduler(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchemaRegistryLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovScheduler(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.ServiceProvider)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.Package) > 0 {
		for _, s := range m.Package {
			l = len(s)
			n += 1 + l + sovScheduler(uint64(l))
		}
	}
	l = len(m.ServiceProviderRegion)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.RegionDisplayName)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvironmentStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetEnvironmentMetadataReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.Clouds) > 0 {
		for _, e := range m.Clouds {
			l = e.Size()
			n += 1 + l + sovScheduler(uint64(l))
		}
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.SchemaRegistryLocations) > 0 {
		for _, e := range m.SchemaRegistryLocations {
			l = e.Size()
			n += 1 + l + sovScheduler(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSchemaRegistryClusterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.RequestCarrier) > 0 {
		for k, v := range m.RequestCarrier {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovScheduler(uint64(len(k))) + 1 + len(v) + sovScheduler(uint64(len(v)))
			n += mapEntrySize + 1 + sovScheduler(uint64(mapEntrySize))
		}
	}
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSchemaRegistryClusterReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.ValidationErrors) > 0 {
		for k, v := range m.ValidationErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovScheduler(uint64(len(k))) + 1 + len(v) + sovScheduler(uint64(len(v)))
			n += mapEntrySize + 1 + sovScheduler(uint64(mapEntrySize))
		}
	}
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSchemaRegistryClustersReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovScheduler(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSchemaRegistryClusterReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateSchemaRegistryClusterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.RequestCarrier) > 0 {
		for k, v := range m.RequestCarrier {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovScheduler(uint64(len(k))) + 1 + len(v) + sovScheduler(uint64(len(v)))
			n += mapEntrySize + 1 + sovScheduler(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateSchemaRegistryClusterReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if len(m.ValidationErrors) > 0 {
		for k, v := range m.ValidationErrors {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovScheduler(uint64(len(k))) + 1 + len(v) + sovScheduler(uint64(len(v)))
			n += mapEntrySize + 1 + sovScheduler(uint64(mapEntrySize))
		}
	}
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteSchemaValidationResourcesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LogicalClusterId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.OrganizationId != 0 {
		n += 1 + sovScheduler(uint64(m.OrganizationId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteSchemaValidationResourcesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchemaRegistryClusterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KafkaClusterId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Servers != 0 {
		n += 1 + sovScheduler(uint64(m.Servers))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Location != 0 {
		n += 1 + sovScheduler(uint64(m.Location))
	}
	l = len(m.ServiceProvider)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.PhysicalClusterId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.Package)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.ServiceProviderRegion)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Dedicated {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchemaRegistryCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.KafkaClusterId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Modified != nil {
		l = m.Modified.Size()
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovScheduler(uint64(m.Status))
	}
	l = len(m.PhysicalClusterId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.OrganizationId != 0 {
		n += 1 + sovScheduler(uint64(m.OrganizationId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	if m.MaxSchemas != 0 {
		n += 1 + sovScheduler(uint64(m.MaxSchemas))
	}
	l = len(m.OrgResourceId)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.Package)
	if l > 0 {
		n += 1 + l + sovScheduler(uint64(l))
	}
	l = len(m.ServiceProvider)
	if l > 0 {
		n += 2 + l + sovScheduler(uint64(l))
	}
	l = len(m.ServiceProviderRegion)
	if l > 0 {
		n += 2 + l + sovScheduler(uint64(l))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 2 + l + sovScheduler(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovScheduler(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozScheduler(x uint64) (n int) {
	return sovScheduler(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *APICredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: APICredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: APICredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schedulability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schedulability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schedulability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SharedNetwork == nil {
				m.SharedNetwork = &Schedulability_Tenancy{}
			}
			if err := m.SharedNetwork.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DedicatedNetwork == nil {
				m.DedicatedNetwork = &Schedulability_Tenancy{}
			}
			if err := m.DedicatedNetwork.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schedulability_Tenancy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tenancy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tenancy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SharedCluster == nil {
				m.SharedCluster = &Schedulability_Tenancy_Durability{}
			}
			if err := m.SharedCluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DedicatedCluster == nil {
				m.DedicatedCluster = &Schedulability_Tenancy_Durability{}
			}
			if err := m.DedicatedCluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schedulability_Tenancy_Durability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Durability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Durability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v NetworkType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScheduler
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NetworkType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Low = append(m.Low, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScheduler
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScheduler
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthScheduler
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Low) == 0 {
					m.Low = make([]NetworkType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NetworkType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NetworkType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Low = append(m.Low, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
		case 2:
			if wireType == 0 {
				var v NetworkType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScheduler
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NetworkType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.High = append(m.High, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScheduler
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScheduler
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthScheduler
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.High) == 0 {
					m.High = make([]NetworkType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NetworkType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NetworkType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.High = append(m.High, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvailabilityZone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvailabilityZone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvailabilityZone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZoneId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SniEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SniEnabled == nil {
				m.SniEnabled = &types.BoolValue{}
			}
			if err := m.SniEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedulable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedulable == nil {
				m.Schedulable = &types.BoolValue{}
			}
			if err := m.Schedulable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modified", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modified == nil {
				m.Modified = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Modified, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deactivated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deactivated == nil {
				m.Deactivated = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Deactivated, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Realm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Region) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Region: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Region: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloud", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloud = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zones = append(m.Zones, &AvailabilityZone{})
			if err := m.Zones[len(m.Zones)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSchedulable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSchedulable = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMultizoneEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMultizoneEnabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &Region_Config{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedulability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedulability == nil {
				m.Schedulability = &Schedulability{}
			}
			if err := m.Schedulability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Region_Docker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Docker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Docker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Region_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Docker == nil {
				m.Docker = &Region_Docker{}
			}
			if err := m.Docker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, &Region{})
			if err := m.Regions[len(m.Regions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, &AccountMetadata{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaRegistryLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaRegistryLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaRegistryLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= GlobalSchemaRegistryLocation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Package = append(m.Package, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProviderRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionDisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionDisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvironmentStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvironmentStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvironmentStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEnvironmentMetadataReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEnvironmentMetadataReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEnvironmentMetadataReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clouds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clouds = append(m.Clouds, &CloudMetadata{})
			if err := m.Clouds[len(m.Clouds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EnvironmentStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaRegistryLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaRegistryLocations = append(m.SchemaRegistryLocations, &SchemaRegistryLocation{})
			if err := m.SchemaRegistryLocations[len(m.SchemaRegistryLocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSchemaRegistryClusterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSchemaRegistryClusterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSchemaRegistryClusterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &SchemaRegistryClusterConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCarrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestCarrier == nil {
				m.RequestCarrier = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScheduler
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthScheduler
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthScheduler
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthScheduler
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthScheduler
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScheduler(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScheduler
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestCarrier[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &SchemaRegistryCluster{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSchemaRegistryClusterReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSchemaRegistryClusterReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSchemaRegistryClusterReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidationErrors == nil {
				m.ValidationErrors = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScheduler
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthScheduler
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthScheduler
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthScheduler
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthScheduler
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScheduler(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScheduler
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ValidationErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &SchemaRegistryCluster{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &APICredentials{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSchemaRegistryClustersReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSchemaRegistryClustersReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSchemaRegistryClustersReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &SchemaRegistryCluster{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSchemaRegistryClusterReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSchemaRegistryClusterReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSchemaRegistryClusterReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &SchemaRegistryCluster{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSchemaRegistryClusterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSchemaRegistryClusterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSchemaRegistryClusterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &SchemaRegistryCluster{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCarrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestCarrier == nil {
				m.RequestCarrier = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScheduler
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthScheduler
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthScheduler
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthScheduler
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthScheduler
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScheduler(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScheduler
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestCarrier[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSchemaRegistryClusterReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSchemaRegistryClusterReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSchemaRegistryClusterReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidationErrors == nil {
				m.ValidationErrors = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScheduler
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthScheduler
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthScheduler
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScheduler
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthScheduler
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthScheduler
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScheduler(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScheduler
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ValidationErrors[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &SchemaRegistryCluster{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteSchemaValidationResourcesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteSchemaValidationResourcesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteSchemaValidationResourcesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogicalClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationId", wireType)
			}
			m.OrganizationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrganizationId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteSchemaValidationResourcesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteSchemaValidationResourcesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteSchemaValidationResourcesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaRegistryClusterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaRegistryClusterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaRegistryClusterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KafkaClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			m.Servers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Servers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			m.Location = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Location |= GlobalSchemaRegistryLocation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Package = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProviderRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &StreamGovernanceRegion{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dedicated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dedicated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaRegistryCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaRegistryCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaRegistryCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KafkaClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = &types.Timestamp{}
			}
			if err := m.Created.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modified", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modified == nil {
				m.Modified = &types.Timestamp{}
			}
			if err := m.Modified.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ClusterStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationId", wireType)
			}
			m.OrganizationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrganizationId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSchemas", wireType)
			}
			m.MaxSchemas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSchemas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Package = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProviderRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScheduler
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScheduler
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &StreamGovernanceRegion{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScheduler(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScheduler
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScheduler(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScheduler
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScheduler
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthScheduler
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthScheduler
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowScheduler
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipScheduler(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthScheduler
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthScheduler = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScheduler   = fmt.Errorf("proto: integer overflow")
)
